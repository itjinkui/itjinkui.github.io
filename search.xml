<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Docker]]></title>
      <url>%2F2017%2F06%2F16%2Fdocker-how%2F</url>
      <content type="text"><![CDATA[初始容器与Dockerhttps://docs.docker.com/engine/docker-overview/ 什么是DockerDocker开源项目背景Docker是基于Go语言实现的开源容器项目，诞生于2013年年初，最初发起者是dotCloud公司。Docker自开源后受到广泛的关注和讨论，目前已有多个相关项目（包括Docker三剑客、Kubernetes等），逐渐形成了围绕Docker容器的生态体系。由于Docker在业界造成的影响力实在太大，dotCloud公司后来也直接改名为Docker Inc，并专注于Docker相关技术和产品的开发。 对于Docker，目前的定义是一个开源的容器引擎，可以方便地对容器（关于容器，将在第2章详细介绍）进行管理。其对镜像的打包封装，以及引入的Docker Registry对镜像的统一管理，构建了方便快捷的“Build，Ship and Run”流程，它可以统一整个开发、测试和部署的环境和流程，极大地减少运维成本。 Docker在开发和运维中的优势对开发和运维（DevOps）人员来说，可能最梦寐以求的效果就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行。 1.更快速的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同环境来部署代码。只要开发测试过的代码，就可以确保在生产环境无缝运行。Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。2.更高效的资源利用。Docker容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager以及Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。3.更轻松的迁移和扩展。4.更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。 核心概念1.Docker镜像镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像。与容器相对应，如果说容器提供了一个完整的、隔离的运行环境，那么镜像则是这个运行环境的静态体现，是一个还没有运行起来的“运行环境”。Docker镜像通常是通过Dockerfile来创建的，Dockerfile提供了镜像内容的定制，同时也体现了层级关系的建立。 ps:镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。2.Docker容器在功能上，Docker通过Libcontainer实现对容器生命周期的管理、信息的设置和查询，以及监控和通信等功能。而容器也是对镜像的完美诠释，容器以镜像为基础，同时又为镜像提供了一个标准的和隔离的执行环境。在概念上，容器则很好地诠释了Docker集装箱的理念，集装箱可以存放任何货物，可以通过邮轮将货物运输到世界各地。运输集装箱的邮轮和装载卸载集装箱的码头都不用关心集装箱里的货物，这是一种标准的集装和运输方式。类似的，Docker的容器就是“软件界的集装箱”，它可以安装任意的软件和库文件，做任意的运行环境配置。 3.Docker仓库是Docker集中存放镜像文件的场所。 Install Docker for Machttps://docs.docker.com/docker-for-mac/install/ 1234567891011121314151617~ docker versionClient: Version: 17.03.1-ce API version: 1.27 Go version: go1.7.5 Git commit: c6d412e Built: Tue Mar 28 00:40:02 2017 OS/Arch: darwin/amd64Server: Version: 17.03.1-ce API version: 1.27 (minimum version 1.12) Go version: go1.7.5 Git commit: c6d412e Built: Fri Mar 24 00:00:50 2017 OS/Arch: linux/amd64 Experimental: true 我们看到Client和Server均有输出，则说明Docker for Mac已经正常启动。 CentOS环境下安装DockerOS requirementsTo install Docker, you need the 64-bit version of CentOS 7.我是在Mac上安装的VirtualBox，然后装上CentOS 7镜像。 对于CentOS 7系统，CentOS-Extras源中已内置Docker yum安装12345678[root@centos-docker yum.repos.d]# sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-'EOF'&gt; [dockerrepo]&gt; name=Docker Repository&gt; baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/&gt; enabled=1&gt; gpgcheck=1&gt; gpgkey=https://yum.dockerproject.org/gpg&gt; EOF 之后更新yum软件源缓存，并安装docker-engine 即可。 1234$ sudo yum install -y yum-utils$ sudo yum update$ sudo yum makecache fast$ sudo yum install docker-engine 这是最新的版本。要想随意指定要安装的版本，如下命令，官网上如下。1.List the available versions: $ yum list docker-engine.x86_64 –showduplicates |sort -r 2.Install a specific version by adding the version after docker-engine, separated by a hyphen (-):$ sudo yum install docker-engine-version 脚本安装1.更新系统包到最新。$ yum -y update 2.执行Docker安装脚本 1$ curl -fsSL https://get.docker.com/ | sh 获取镜像Docker Hub 镜像站点 安装／升级你的Docker客户端您可以通过阿里云的镜像仓库下载：mirrors.aliyun.com/help/docker-engine 或执行以下命令： 1curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - 如何使用Docker加速器针对Docker客户端版本大于1.10的用户 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器： sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’{ “registry-mirrors”: [“https://wgqgbfsb.mirror.aliyuncs.com“]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 镜像是运行容器的前提，官方的Docker Hub网站已经提供了数十万个镜像供大家开放下载。可以使用docker pull命令直接从Docker Hub镜像源来下载镜像。该命令的格式为docker pull NAME[：TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。 现在想要获得centos的Docker镜像，1.docker search –no-trunc centos2.docker pull docker.io/jdeathe/centos-ssh 查看镜像信息1.使用images命令列出镜像2.使用tag命令添加镜像标签3.使用inspect命令查看详细信息4.使用history命令查看镜像历史(docker history –no-trunc centos-ssh) 搜寻镜像使用docker search命令可以搜索远端仓库中共享的镜像，默认搜索官方仓库中的镜像。用法为docker search TERM，支持的参数主要包括：·–automated=true|false：仅显示自动创建的镜像，默认为否；·–no-trunc=true|false：输出信息不截断显示，默认为否；·–filter=stars=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像。例如：$ docker search –filter=stars=3 ubuntu$ docker search -f stars=25 centos 删除镜像使用标签删除镜像使用docker rmi命令可以删除镜像，命令格式为docker rmi IMAGE[IMAGE…]，其中IMAGE可以为标签或ID。 创建镜像创建镜像的方法主要有三种：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。本节将重点介绍前两种方法。最后一种基于Dockerfile创建的方法将在后续章节专门予以详细介绍。 基于已有镜像的容器创建该方法主要是使用docker commit命令。命令格式为docker commit[OPTIONS]CONTAINER[REPOSITORY[：TAG]]，主要选项包括：·-a，–author=””：作者信息；·-c，–change=[]：提交的时候执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等；·-m，–message=””：提交消息；·-p，–pause=true：提交时暂停容器运行。 基于本地模板导入要直接导入一个镜像，可以使用OpenVZ提供的模板来创建，或者用其他已导出的镜像模板来创建。OPENVZ模板的下载地址为http://openvz.org/Download/templates/precreated 存出和载入镜像1.存出镜像123[root@centos-docker docker]# docker save -o centos_7.tar.gz daocloud.io/centos:7[root@centos-docker docker]# lscentos_7.tar.gz certs.d daemon.json key.json 2.载入镜像 12[root@centos-docker docker]# docker load --input centos_7.tar.gzLoaded image: daocloud.io/centos:7 或者$ docker load &lt; centos_7.tar.gz这将导入镜像及其相关的元数据信息（包括标签等）。 创建&amp;启动一个容器：123$ docker run -d -p 10022:22 -v /dfile/:/dfile/ -h "centos-d" --name centos-d centos-ssh /usr/sbin/sshd -D$ mount -t vboxsf docker_files /docker 12345[root@centos-d /]# netstat -tunlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1/sshdtcp6 0 0 :::22 :::* LISTEN 1/sshd 其中10022是宿主主机的端口，22是容器的SSH服务监听端口：-p 10022:22使用HostPort：ContainerPort格式将本地的10022端口映射到容器的22端口。 在宿主主机或其他主机上，可以通过SSH访问10022端口来登录容器。 使用docker inspect来查看容器的 -v /dfile(主机):/dfile(容器):ro上面的命令加载主机的/dfile目录到容器的/dfile目录。ps：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。 Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读。 mount -t vboxsf the_share_name /a_folder_nameps:VirtualBox与Mac共享文件夹为：docker_filesps: $ docker ps -a查看容器。 123456[root@centos-docker docker]# docker start centos-dcentos-d[root@centos-docker docker]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdb802d85c70f centos-ssh "/usr/sbin/sshd -D" 11 weeks ago Exited (0) 3 weeks ago centos-ssh0ffb8ab3f777 centos-ssh "/usr/sbin/sshd -D" 11 weeks ago Up 12 seconds 0.0.0.0:10022-&gt;22/tcp centos-d $ docker-enter centos-d 进入容器。可以按Ctrl+d或输入exit命令来退出容器，通过exit命令或Ctrl+d来退出终端时，所创建的容器立刻终止，处于stopped状态。 create命令与容器运行模式相关的选项-d, –detach=true|false (是否在后台运行容器，默认为否)-P, –publish-all=true|false (通过NAT机制将容器标记暴露的端口自动映射到本地主机的临时端口)-p, –publish=[] (指定如何映射到本地主机端口)–rm=true|false （容器退出后是否自动删除，不能跟-d同时使用）-i, –interactive=true|false (保持标准输入打开，默认为false)-t, –tty=true|false (是否分配一个伪终端，默认是false)–expose=[] (指定容器会暴露出来的端口或端口范围)–group-add=[] (运行容器的用户组)-v|–volume[=[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]] (挂载主机上的文件卷到容器内)-w, –workdir=”” (容器内的默认工作目录) create命令与容器环境和配置相关的选项–add-host=[] (在容器内添加一个主机名到IP地址的映射关系（通过/etc/hosts文件）)-h, –hostname=”” (指定容器内的主机名)–name=”” (指定容器的别名) create命令与容器资源限制和安全保护相关的选项–privileged=true|false (是否给容器以高权限，这意味着容器内应用将不受权限下限制，一般不推荐)–read-only=true|false (是否让容器内的文件系统只读) 启动容器说明当利用docker run来创建并启动容器时，Docker在后台运行的标准操作包括： ·检查本地是否存在指定的镜像，不存在就从公有仓库下载；·利用镜像创建一个容器，并启动该容器；·分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；·从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；·从网桥的地址池配置一个IP地址给容器；·执行用户指定的应用程序；·执行完毕后容器被自动终止。 终止容器可以使用docker stop来终止一个运行中的容器。该命令的格式为docker stop[-t|–time[=10]][CONTAINER…]。首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器。 进入容器在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。这个时候如果需要进入容器进行操作，有多种方法，包括使用官方的attach或exec命令，以及第三方的nsenter工具等。下面分别介绍一下。 attach命令attach是Docker自带的命令，命令格式为： 支持三个主要选项：·–detach-keys[=[]]：指定退出attach模式的快捷键序列，默认是CTRL-p CTRL-q；·–no-stdin=true|false：是否关闭标准输入，默认是保持打开；·–sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认为true。ps:当多个窗口同时用attach命令连到同一个容器的时候，所有窗口都会同步显示。不常用。 exec命令Docker从1.3.0版本起提供了一个更加方便的exec命令，可以在容器内直接执行任意命令。比较重要的参数有：·-i，–interactive=true|false：打开标准输入接受用户输入命令，默认为false；·–privileged=true|false：是否给执行命令以高权限，默认为false；·-t，–tty=true|false：分配伪终端，默认为false；·-u，–user=””：执行命令的用户名或ID。例如进入到刚创建的容器中，并启动一个bash： 123[root@centos-docker docker]# docker exec -it centos-d /bin/bash[root@centos-d /]# pwd/ 可以看到，一个bash终端打开了，在不影响容器内其他应用的前提下，用户可以很容易与容器进行交互。注意通过指定-it参数来保持标准输入打开，并且分配一个伪终端。通过exec命令对容器执行操作是最为推荐的方式。 nsenter工具在util-linux软件包版本2.23+中包含nsenter工具。 123456789101112[root@centos-docker docker]# docker start centos-dcentos-d[root@centos-docker docker]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0ffb8ab3f777 centos-ssh "/usr/sbin/sshd -D" 11 weeks ago Up 6 seconds 0.0.0.0:10022-&gt;22/tcp centos-d[root@centos-docker docker]# PID=$(docker inspect --format "&#123;&#123; .State.Pid &#125;&#125;" centos-d)[root@centos-docker docker]# nsenter --target $PID --mount --uts --ipc --net --pid[root@centos-d /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 06:04 ? 00:00:00 /usr/sbin/sshd -Droot 5 0 0 06:07 ? 00:00:00 -bashroot 19 5 0 06:09 ? 00:00:00 ps -ef 删除容器可以使用docker rm命令来删除处于终止或退出状态的容器，命令格式为docker rm[-f|–force][-l|–link][-v|–volumes]CONTAINER[CONTAINER…]。主要支持的选项包括：·-f，–force=false：是否强行终止并删除一个运行中的容器；·-l，–link=false：删除容器的连接，但保留容器；·-v，–volumes=false：删除容器挂载的数据卷。 导入和导出容器某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用Docker的导入和导出功能。这也是Docker自身提供的一个重要特性。 导出容器导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令，该命令的格式为docker export[-o|–output[=””]]CONTAINER。其中，可以通过-o选项来指定导出的tar文件名，也可以直接通过重定向来实现。ps:实现容器的迁移 123456[root@centos-docker docker]# docker export -o test_centos-d.tar.gz centos-d[root@centos-docker docker]# lsa.txt b.txt c.txt epel-release-7-9.noarch.rpm test_centos-d.tar.gz[root@centos-docker docker]# docker export centos-d &gt;test2_centos-d.tar.gz[root@centos-docker docker]# lsa.txt b.txt c.txt epel-release-7-9.noarch.rpm test2_centos-d.tar.gz test_centos-d.tar.gz 实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 完）参考资料：Docker技术入门与实践Docker进阶与实战 作者：华为Docker实践小组]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux]]></title>
      <url>%2F2017%2F05%2F25%2Fsystemd%2F</url>
      <content type="text"><![CDATA[Systemd 入门教程：命令篇Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。 本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。 一、由来历史上，Linux 的启动一直采用init进程。 下面的命令用来启动服务。 12[root@localhost /]# service httpd startRedirecting to /bin/systemctl start httpd.service ps:Centos7已经不支持了喔！ 这种方法有两个缺点。 一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。 二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。 二、Systemd 概述Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。 （上图为 Systemd 作者 Lennart Poettering） 使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。 1$ systemctl --version 上面的命令查看 Systemd 的版本。 Systemd 的优点是功能强大，使用方便，缺点是系统庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反“keep simple, keep stupid”的Unix 哲学。 （上图为 Systemd 架构图） 三、系统管理Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 3.1 systemctlsystemctl是 Systemd 的主命令，用于管理系统。 1234567891011121314151617181920# 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue 3.2 systemd-analyzesystemd-analyze命令用于查看启动耗时。 1234567891011# 查看启动耗时$ systemd-analyze # 查看每个服务的启动耗时$ systemd-analyze blame# 显示瀑布状的启动过程流$ systemd-analyze critical-chain# 显示指定服务的启动流(eg:sshd.service)$ systemd-analyze critical-chain sshd.service 3.3 hostnamectlhostnamectl命令用于查看当前主机的信息。 12345# 显示当前主机的信息$ hostnamectl# 设置主机名。$ sudo hostnamectl set-hostname CentOS-Docker 3.4 localectllocalectl命令用于查看本地化设置。 123456# 查看本地化设置$ localectl# 设置本地化参数。$ sudo localectl set-locale LANG=zh_CN.UTF-8$ sudo localectl set-keymap cn 3.5 timedatectltimedatectl命令用于查看当前时区设置。 12345678910# 查看当前时区设置$ timedatectl# 显示所有可用的时区$ timedatectl list-timezones # 设置当前时区$ sudo timedatectl set-timezone America/New_York$ sudo timedatectl set-time YYYY-MM-DD$ sudo timedatectl set-time HH:MM:SS 3.6 loginctlloginctl命令用于查看当前登录的用户。 12345678# 列出当前session$ loginctl list-sessions# 列出当前登录用户$ loginctl list-users# 列出显示指定用户的信息$ loginctl show-user root 四、Unit4.1 含义Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。 Unit 一共分成12种。 Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 systemctl list-units命令可以查看当前系统的所有 Unit 。 1234567891011121314# 列出正在运行的 Unit$ systemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的$ systemctl list-units --all# 列出所有没有运行的 Unit$ systemctl list-units --all --state=inactive# 列出所有加载失败的 Unit$ systemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unit$ systemctl list-units --type=service 4.2 Unit 的状态systemctl status命令用于查看系统状态和单个 Unit 的状态。 12345678# 显示系统状态$ systemctl status# 显示单个 Unit 的状态$ sysystemctl status httpd.service# 显示远程主机的某个 Unit 的状态$ systemctl -H root@rhel7.example.com status httpd.service 除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。 12345678# 显示某个 Unit 是否正在运行$ systemctl is-active httpd.service# 显示某个 Unit 是否处于启动失败状态$ systemctl is-failed httpd.service# 显示某个 Unit 服务是否建立了启动链接$ systemctl is-enabled httpd.service 4.3 Unit 管理对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。 123456789101112131415161718# 立即启动一个服务$ sudo systemctl start httpd.service# 立即停止一个服务$ sudo systemctl stop httpd.service# 重启一个服务$ sudo systemctl restart httpd.service# 杀死一个服务的所有子进程$ sudo systemctl kill httpd.service# 重新加载一个服务的配置文件$ sudo systemctl reload httpd.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service 4.4 依赖关系Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。 systemctl list-dependencies命令列出一个 Unit 的所有依赖。 1$ systemctl list-dependencies nginx.service 上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。 1$ systemctl list-dependencies --all nginx.service 五、Unit 的配置文件5.1 概述每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。 Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在这个目录。 systemctl enable命令用于在上面两个目录之间，建立符号链接关系。 123$ sudo systemctl enable sshd.service# 等同于$ sudo ln -s '/usr/lib/systemd/system/sshd.service' '/etc/systemd/system/multi-user.target.wants/sshd.service' 如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。 与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。 1$ sudo systemctl disable sshd.service 配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。 5.2 配置文件的状态systemctl list-unit-files命令用于列出所有配置文件。 12345# 列出所有配置文件$ systemctl list-unit-files# 列出指定类型的配置文件$ systemctl list-unit-files --type=service 这个命令会输出一个列表。 123456$ systemctl list-unit-filesUNIT FILE STATEchronyd.service enabledclamd@.service staticsshd.service disabled 这个列表显示每个配置文件的状态，一共有四种。 enabled：已建立启动链接 disabled：没建立启动链接 static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖 masked：该配置文件被禁止建立启动链接 注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。 1$ systemctl status httpd.service 一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。 12$ sudo systemctl daemon-reload$ sudo systemctl restart httpd.service 5.3 配置文件的格式配置文件就是普通的文本文件，可以用文本编辑器打开。 systemctl cat命令可以查看配置文件的内容。 1234567891011$ systemctl cat atd.service[Unit]Description=ATD daemon[Service]Type=forkingExecStart=/usr/bin/atd[Install]WantedBy=multi-user.target 从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。 每个区块内部是一些等号连接的键值对。 12345[Section]Directive1=valueDirective2=value. . . 注意，键值对的等号两侧不能有空格。 5.4 配置文件的区块[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。 Description：简短描述 Documentation：文档地址 Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败 Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败 BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行 Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动 Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行 Condition...：当前 Unit 运行必须满足的条件，否则不会运行 Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败 [Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。 WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中 RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中 Alias：当前 Unit 可用于启动的别名 Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit [Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。 Type：定义启动时的进程行为。它有以下几种值。 simple：默认值，执行ExecStart指定的命令，启动主进程 forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出 oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行 dbus：当前服务通过D-Bus启动 notify：当前服务启动完毕，会通知Systemd，再继续往下执行 idle：若有其他任务执行完毕，当前服务才会运行 ExecStart：启动当前服务的命令 ExecStartPre：启动当前服务之前执行的命令 ExecStartPost：启动当前服务之后执行的命令 ExecReload：重启当前服务时执行的命令 ExecStop：停止当前服务时执行的命令 ExecStopPost：停止当其服务之后执行的命令 RestartSec：自动重启当前服务间隔的秒数 Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数 Environment：指定环境变量 Unit 配置文件的完整字段清单，请参考官方文档。 六、Target简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于“状态点”，启动某个 Target 就好比启动到某种状态。 传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 12345678910111213141516# 查看当前系统的所有 Target$ systemctl list-unit-files --type=target# 查看一个 Target 包含的所有 Unit$ systemctl list-dependencies multi-user.target# 查看启动时的默认 Target$ systemctl get-default# 设置启动时的默认 Target$ sudo systemctl set-default multi-user.target# 切换 Target 时，默认不关闭前一个 Target 启动的进程，# systemctl isolate 命令改变这种行为，# 关闭前一个 Target 里面所有不属于后一个 Target 的进程$ sudo systemctl isolate multi-user.target Target 与 传统 RunLevel 的对应关系如下。 123456789Traditional runlevel New target name Symbolically linked to...Runlevel 0 | runlevel0.target -&gt; poweroff.targetRunlevel 1 | runlevel1.target -&gt; rescue.targetRunlevel 2 | runlevel2.target -&gt; multi-user.targetRunlevel 3 | runlevel3.target -&gt; multi-user.targetRunlevel 4 | runlevel4.target -&gt; multi-user.targetRunlevel 5 | runlevel5.target -&gt; graphical.targetRunlevel 6 | runlevel6.target -&gt; reboot.target 它与init进程的主要差别如下。 （1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。 （2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。 （3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。 七、日志管理Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。 journalctl功能强大，用法非常多。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# 查看所有日志（默认情况下 ，只保存本次启动的日志）$ sudo journalctl# 查看内核日志（不显示应用日志）$ sudo journalctl -k# 查看系统本次启动的日志$ sudo journalctl -b$ sudo journalctl -b -0# 查看上一次启动的日志（需更改设置）$ sudo journalctl -b -1# 查看指定时间的日志$ sudo journalctl --since="2012-10-30 18:17:16"$ sudo journalctl --since "20 min ago"$ sudo journalctl --since yesterday$ sudo journalctl --since 09:00 --until "1 hour ago"# 显示尾部的最新10行日志$ sudo journalctl -n# 显示尾部指定行数的日志$ sudo journalctl -n 20# 实时滚动显示最新日志$ sudo journalctl -f# 查看指定服务的日志$ sudo journalctl /usr/lib/systemd/systemd# 查看指定进程的日志$ sudo journalctl _PID=1# 查看某个路径的脚本的日志$ sudo journalctl /usr/bin/bash# 查看指定用户的日志$ sudo journalctl _UID=33 --since today# 查看某个 Unit 的日志$ sudo journalctl -u nginx.service$ sudo journalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志$ sudo journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debug$ sudo journalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出$ sudo journalctl --no-pager# 以 JSON 格式（单行）输出$ sudo journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好$ sudo journalctl -b -u nginx.serviceqq -o json-pretty# 显示日志占据的硬盘空间$ sudo journalctl --disk-usage# 指定日志文件占据的最大空间$ sudo journalctl --vacuum-size=1G# 指定日志文件保存多久$ sudo journalctl --vacuum-time=1years （完）转载于http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html如何编写 Unit 的配置文件 What is an init system? systemd: Converting sysvinit scripts systemd: Unit dependencies and order Systemd Packaging:Systemd Writing systemd service files How to write startup script for systemd]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git]]></title>
      <url>%2F2017%2F05%2F11%2Fgit-how%2F</url>
      <content type="text"><![CDATA[#Git 闲话 1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“只干了两件事啊，毫不夸张的说：惊天地泣鬼神。第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。再接下来，Git 就是我们的主题了，记录以备忘。 Git安装与配置安装Mac 上brew安装算是最便捷的了 123456~ brew install git ~ brew --versionHomebrew 1.1.13Homebrew/homebrew-core (git revision ea163; last commit 2017-04-20)~ git --versiongit version 2.11.0 配置可以通过 git config –list –global 命令来查看： 123456~ git config --list --globaluser.email=1250114609@qq.comuser.name=千古不见一人闲color.ui=autoalias.st=statusalias.lg=log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit 可以看到有两个alias出现，这里使用了别名。 配置别名 这个功能在shell中是很常用的。我们可以做一些别名来取代比较复杂的指令。比如上面就是使用了以下两个配置 123~ git config --global alias.st status~ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 身份认证当本地git仓库与git远程仓库通信的时候，需要进行SSH身份认证。打开根目录下的.ssh目录： 12~/.ssh la. .. config github_rsa github_rsa.pub id_rsa id_rsa.pub known_hosts 如果没有id_rsa和id_rsa.pub这两个文件，就通过如下的命令生成： ssh-keygen -t rsa -C “youremail@example.com”id_rsa和id_rsa.pub这两个文件，就是SSH Key的秘钥对，id_rsa是私钥，id_rsa.pub是公钥，用在github上表明身份。在GitHub上的SSH keys中添加刚刚生成的key。(id_rsa.pub) 创建Git仓库创建一个目录，并cd到目录下，通过调用git init来将现有目录初始化为git仓库，或者直接在git init后面跟上目录名，同样也可以创建一个新的仓库。 git clone 直接clone一个远程仓库也是可以的。 提交修改1234567891011~/Documents/workspace git_springboot~/Documents/workspace/git_springboot(master ✔) la. .. .git~/Documents/workspace/git_springboot(master ✔) touch README.md~/Documents/workspace/git_springboot(master ✗) vim README.md~/Documents/workspace/git_springboot(master ✗) git add README.md~/Documents/workspace/git_springboot(master ✗) git commit -m "add README.md"[master be9081a] add README.md 1 file changed, 1 insertion(+) create mode 100644 README.md~/Documents/workspace/git_springboot(master ✔) 查看修改修改README.md文件，git st查看修改 1234567891011~/Documents/workspace/git_springboot(master ✗) git stOn branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") Git 比较不同版本文件差异的常用命令格式： git diff 查看尚未暂存的文件更新了哪些部分 git diff filename 查看尚未暂存的某个文件更新了哪些 git diff –cached 查看已经暂存起来的文件和上次提交的版本之间的差异 git diff –cached filename 查看已经暂存起来的某个文件和上次提交的版本之间的差异 使用git diff README.md 命令看一下修改的具体内容 diff –git a/README.md b/README.mdindex e8281cd..f1729fb 100644— a/README.md+++ b/README.md@@ -1 +1 @@-this’s ok.+this’s ok,modify. add和commit之后，我们都使用status来查看下状态，可以发现，在commit之后，git提示我们，工作区是干净的。 1234567891011121314151617181920~/Documents/workspace/git_springboot(master ✗) git stOn branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a")~/Documents/workspace/git_springboot(master ✗) git add README.md~/Documents/workspace/git_springboot(master ✗) git commit -m "modify README.md"[master a77107b] modify README.md 1 file changed, 1 insertion(+), 1 deletion(-)~/Documents/workspace/git_springboot(master ✔) git stOn branch masterYour branch is ahead of 'origin/master' by 2 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean 版本记录使用git lg 命令来查看也可以使用gitk命令来查看图形化的log记录 工作区与暂存区Git通常是工作在三个区域上： 工作区暂存区历史区其中工作区就是我们平时工作、修改代码的区域；而历史区，用来保存各个版本；而暂存区，则是Git的核心所在。Git官网图解Git 版本回退回退版本是必不可少的操作啊 我们来考虑以下常见的几种情况： 文件已经修改，但是还没有git add 文件已经add到暂存区，又作了修改 文件的修改已经add到了暂存区 分别执行以下操作： ➜git checkout – README.md修改被删除，完全还原到上次commit的状态，也就是服务器版本(1.)最后的修改被删除，还原到上次add的状态，也就是修改前的暂存区状态(2.)➜git reset HEAD README.md(3.) 1234567891011121314151617181920212223~/Documents/workspace/git_springboot(master ✗) git stOn branch masterYour branch is ahead of 'origin/master' by 2 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md~/Documents/workspace/git_springboot(master ✗) git reset HEAD README.mdUnstaged changes after reset:M README.md~/Documents/workspace/git_springboot(master ✗) git stOn branch masterYour branch is ahead of 'origin/master' by 2 commits. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdno changes added to commit (use "git add" and/or "git commit -a") 通过git reset HEAD README.md，我们就把暂存区的文件清除了。这样，在本地就是add前的状态，通过checkout操作，就可以进行修改回退了。在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^。（git reset –hard HEAD）要回退到哪个版本，也可以写commit id。 前进版本如果我们回退到了旧的版本，但是却后悔了想回到后面某个新的版本,git reflog 查看操作历史。找到 commit id。版本号没必要写全，前7位就可以了，Git会自动去找。 文件暂存这里的暂存不是前面说的暂存区，而是只一次备份与恢复操作。git stash指令来将当前修改暂存，这样就可以切换到其他分支或者就在当前干净的分支上checkout了。比如你checkout了一个issue分支，修改了bug，使用git merge合并到了master分支，删除issue分支，切换到dev分支，想继续之前的新功能开发。这时候，就需要恢复现场了： git stash list指令来查看当前暂存的内容记录。然后，通过git stash apply或者git stash pop来进行恢复，它们的区别是，前者不会删除记录（当然你可以使用git stash drop来删除），而后者会。 远程仓库&amp;同步协作现在你在本地建立了git仓库，想与远程git仓库同步。 我们先在github上创建一个repo（仓库），创建之后，github给我们提示：可以看出，执行以下指令就和远程仓库建立关联了，自然也就可以多人同步协作开发了。 12git remote add origin git@github.com:itjinkui/git_springboot.gitgit push -u origin master 结语git 入门操作算是完成了。企业可以通过GitLab搭建自己的版本管理系统。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F28%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
