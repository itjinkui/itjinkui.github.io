<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://itjinkui.github.io/"/>
  <updated>2017-06-16T06:05:20.000Z</updated>
  <id>http://itjinkui.github.io/</id>
  
  <author>
    <name>千古不见一人闲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker</title>
    <link href="http://itjinkui.github.io/2017/06/16/docker-how-1/"/>
    <id>http://itjinkui.github.io/2017/06/16/docker-how-1/</id>
    <published>2017-06-16T06:04:53.000Z</published>
    <updated>2017-06-16T06:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始容器与Docker"><a href="#初始容器与Docker" class="headerlink" title="初始容器与Docker"></a>初始容器与Docker</h1><p><a href="https://docs.docker.com/engine/docker-overview/" target="_blank" rel="external">https://docs.docker.com/engine/docker-overview/</a></p>
<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><h3 id="Docker开源项目背景"><a href="#Docker开源项目背景" class="headerlink" title="Docker开源项目背景"></a>Docker开源项目背景</h3><p>Docker是基于Go语言实现的开源容器项目，诞生于2013年年初，最初发起者是dotCloud公司。Docker自开源后受到广泛的关注和讨论，目前已有多个相关项目（包括Docker三剑客、Kubernetes等），逐渐形成了围绕Docker容器的生态体系。<br>由于Docker在业界造成的影响力实在太大，dotCloud公司后来也直接改名为Docker Inc，并专注于Docker相关技术和产品的开发。</p>
<p>对于Docker，目前的定义是一个开源的容器引擎，可以方便地对容器（关于容器，将在第2章详细介绍）进行管理。其对镜像的打包封装，以及引入的Docker Registry对镜像的统一管理，构建了方便快捷的“Build，Ship and Run”流程，它可以统一整个开发、测试和部署的环境和流程，极大地减少运维成本。<br><a id="more"></a></p>
<h3 id="Docker在开发和运维中的优势"><a href="#Docker在开发和运维中的优势" class="headerlink" title="Docker在开发和运维中的优势"></a>Docker在开发和运维中的优势</h3><p>对开发和运维（DevOps）人员来说，可能最梦寐以求的效果就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行。</p>
<p>1.更快速的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同环境来部署代码。只要开发测试过的代码，就可以确保在生产环境无缝运行。Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。<br>2.更高效的资源利用。Docker容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager以及Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。<br>3.更轻松的迁移和扩展。<br>4.更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>1.Docker镜像<br>镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像。<br>与容器相对应，如果说容器提供了一个完整的、隔离的运行环境，那么镜像则是这个运行环境的静态体现，是一个还没有运行起来的“运行环境”。<br>Docker镜像通常是通过Dockerfile来创建的，Dockerfile提供了镜像内容的定制，同时也体现了层级关系的建立。</p>
<p>ps:镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。<br>2.Docker容器<br>在功能上，Docker通过Libcontainer实现对容器生命周期的管理、信息的设置和查询，以及监控和通信等功能。而容器也是对镜像的完美诠释，容器以镜像为基础，同时又为镜像提供了一个标准的和隔离的执行环境。<br>在概念上，容器则很好地诠释了Docker集装箱的理念，集装箱可以存放任何货物，可以通过邮轮将货物运输到世界各地。运输集装箱的邮轮和装载卸载集装箱的码头都不用关心集装箱里的货物，这是一种标准的集装和运输方式。类似的，Docker的容器就是“软件界的集装箱”，它可以安装任意的软件和库文件，做任意的运行环境配置。</p>
<p>3.Docker仓库<br>是Docker集中存放镜像文件的场所。</p>
<h2 id="Install-Docker-for-Mac"><a href="#Install-Docker-for-Mac" class="headerlink" title="Install Docker for Mac"></a>Install Docker for Mac</h2><p><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="external">https://docs.docker.com/docker-for-mac/install/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">~ docker version</div><div class="line">Client:</div><div class="line"> Version:      17.03.1-ce</div><div class="line"> API version:  1.27</div><div class="line"> Go version:   go1.7.5</div><div class="line"> Git commit:   c6d412e</div><div class="line"> Built:        Tue Mar 28 00:40:02 2017</div><div class="line"> OS/Arch:      darwin/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.03.1-ce</div><div class="line"> API version:  1.27 (minimum version 1.12)</div><div class="line"> Go version:   go1.7.5</div><div class="line"> Git commit:   c6d412e</div><div class="line"> Built:        Fri Mar 24 00:00:50 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>我们看到Client和Server均有输出，则说明Docker for Mac已经正常启动。</p>
<h2 id="CentOS环境下安装Docker"><a href="#CentOS环境下安装Docker" class="headerlink" title="CentOS环境下安装Docker"></a>CentOS环境下安装Docker</h2><p>OS requirements<br>To install Docker, you need the 64-bit version of CentOS 7.<br>我是在Mac上安装的VirtualBox，然后装上CentOS 7镜像。</p>
<p>对于CentOS 7系统，CentOS-Extras源中已内置Docker</p>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker yum.repos.d]<span class="comment"># sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-'EOF'</span></div><div class="line">&gt; [dockerrepo]</div><div class="line">&gt; name=Docker Repository</div><div class="line">&gt; baseurl=https://yum.dockerproject.org/repo/main/centos/<span class="variable">$releasever</span>/</div><div class="line">&gt; enabled=1</div><div class="line">&gt; gpgcheck=1</div><div class="line">&gt; gpgkey=https://yum.dockerproject.org/gpg</div><div class="line">&gt; EOF</div></pre></td></tr></table></figure>
<p>之后更新yum软件源缓存，并安装docker-engine 即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install -y yum-utils</div><div class="line">$ sudo yum update</div><div class="line">$ sudo yum makecache fast</div><div class="line">$ sudo yum install docker-engine</div></pre></td></tr></table></figure>
<p>这是最新的版本。要想随意指定要安装的版本，如下命令，官网上如下。<br>1.List the available versions:</p>
<p>$ yum list docker-engine.x86_64  –showduplicates |sort -r</p>
<p>2.Install a specific version by adding the version after docker-engine, separated by a hyphen (-):<br>$ sudo yum install docker-engine-version</p>
<h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><p>1.更新系统包到最新。<br>$ yum -y update</p>
<p>2.执行Docker安装脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -fsSL https://get.docker.com/ | sh</div></pre></td></tr></table></figure>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>Docker Hub 镜像站点</p>
<p>安装／升级你的Docker客户端<br>您可以通过阿里云的镜像仓库下载：mirrors.aliyun.com/help/docker-engine</p>
<p>或执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="_">-s</span>SL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</div></pre></td></tr></table></figure>
<p>如何使用Docker加速器<br>针对Docker客户端版本大于1.10的用户</p>
<p>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：</p>
<p>sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’<br>{<br>  “registry-mirrors”: [“<a href="https://wgqgbfsb.mirror.aliyuncs.com" target="_blank" rel="external">https://wgqgbfsb.mirror.aliyuncs.com</a>“]<br>}<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker</p>
<p>镜像是运行容器的前提，官方的Docker Hub网站已经提供了数十万个镜像供大家开放下载。<br>可以使用docker pull命令直接从Docker Hub镜像源来下载镜像。该命令的格式为docker pull NAME[：TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。</p>
<p>现在想要获得centos的Docker镜像，<br>1.docker search –no-trunc centos<br>2.docker pull  docker.io/jdeathe/centos-ssh</p>
<h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><p>1.使用images命令列出镜像<br>2.使用tag命令添加镜像标签<br>3.使用inspect命令查看详细信息<br>4.使用history命令查看镜像历史(docker history –no-trunc centos-ssh)</p>
<h3 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h3><p>使用docker search命令可以搜索远端仓库中共享的镜像，默认搜索官方仓库中的镜像。用法为docker search TERM，支持的参数主要包括：<br>·–automated=true|false：仅显示自动创建的镜像，默认为否；<br>·–no-trunc=true|false：输出信息不截断显示，默认为否；<br>·–filter=stars=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像。<br>例如：<br>$ docker search –filter=stars=3 ubuntu<br>$ docker search -f stars=25 centos</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>使用标签删除镜像<br>使用docker rmi命令可以删除镜像，命令格式为docker rmi IMAGE[IMAGE…]，其中IMAGE可以为标签或ID。</p>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>创建镜像的方法主要有三种：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。<br>本节将重点介绍前两种方法。最后一种基于Dockerfile创建的方法将在后续章节专门予以详细介绍。</p>
<h4 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h4><p>该方法主要是使用docker commit命令。命令格式为docker commit[OPTIONS]CONTAINER[REPOSITORY[：TAG]]，主要选项包括：<br>·-a，–author=””：作者信息；<br>·-c，–change=[]：提交的时候执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等；<br>·-m，–message=””：提交消息；<br>·-p，–pause=true：提交时暂停容器运行。</p>
<h4 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h4><p>要直接导入一个镜像，可以使用OpenVZ提供的模板来创建，或者用其他已导出的镜像模板来创建。OPENVZ模板的下载地址为<a href="http://openvz.org/Download/templates/precreated" target="_blank" rel="external">http://openvz.org/Download/templates/precreated</a></p>
<h4 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h4><p>1.存出镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker docker]<span class="comment"># docker save -o centos_7.tar.gz daocloud.io/centos:7</span></div><div class="line">[root@centos-docker docker]<span class="comment"># ls</span></div><div class="line">centos_7.tar.gz  certs.d  daemon.json  key.json</div></pre></td></tr></table></figure></p>
<p>2.载入镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker docker]<span class="comment"># docker load --input centos_7.tar.gz</span></div><div class="line">Loaded image: daocloud.io/centos:7</div></pre></td></tr></table></figure>
<p>或者<br>$ docker load &lt; centos_7.tar.gz<br>这将导入镜像及其相关的元数据信息（包括标签等）。</p>
<h3 id="创建-amp-启动一个容器："><a href="#创建-amp-启动一个容器：" class="headerlink" title="创建&amp;启动一个容器："></a>创建&amp;启动一个容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker run <span class="_">-d</span> -p 10022:22 -v /dfile/:/dfile/ -h <span class="string">"centos-d"</span> --name centos<span class="_">-d</span> centos-ssh /usr/sbin/sshd -D</div><div class="line"></div><div class="line">$ mount -t vboxsf docker_files /docker</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@centos<span class="_">-d</span> /]<span class="comment"># netstat -tunlp</span></div><div class="line">Active Internet connections (only servers)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</div><div class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1/sshd</div><div class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1/sshd</div></pre></td></tr></table></figure>
<p>其中10022是宿主主机的端口，22是容器的SSH服务监听端口：<br>-p 10022:22<br>使用HostPort：ContainerPort格式将本地的10022端口映射到容器的22端口。</p>
<p>在宿主主机或其他主机上，可以通过SSH访问10022端口来登录容器。</p>
<p>使用docker inspect来查看容器的基础信息。<br>参见：<a href="https://docs.docker.com/engine/reference/commandline/inspect/" target="_blank" rel="external">https://docs.docker.com/engine/reference/commandline/inspect/</a></p>
<p>-v /dfile(主机):/dfile(容器):ro<br>上面的命令加载主机的/dfile目录到容器的/dfile目录。<br>ps：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。</p>
<p>Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读。</p>
<p>mount -t vboxsf the_share_name /a_folder_name<br>ps:VirtualBox与Mac共享文件夹为：docker_files<br><img src="VirtualBoxformac.png" alt="VirtualBoxformac"><br>ps: $ docker ps -a<br>查看容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker docker]<span class="comment"># docker start centos-d</span></div><div class="line">centos<span class="_">-d</span></div><div class="line">[root@centos-docker docker]<span class="comment"># docker ps -a</span></div><div class="line">CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS                   PORTS                   NAMES</div><div class="line">db802d85c70f        centos-ssh          <span class="string">"/usr/sbin/sshd -D"</span>   11 weeks ago        Exited (0) 3 weeks ago                           centos-ssh</div><div class="line">0ffb8ab3f777        centos-ssh          <span class="string">"/usr/sbin/sshd -D"</span>   11 weeks ago        Up 12 seconds            0.0.0.0:10022-&gt;22/tcp   centos<span class="_">-d</span></div></pre></td></tr></table></figure>
<p>$ docker-enter centos-d 进入容器。<br>可以按Ctrl+d或输入exit命令来退出容器，<br>通过exit命令或Ctrl+d来退出终端时，所创建的容器立刻终止，处于stopped状态。</p>
<h4 id="create命令与容器运行模式相关的选项"><a href="#create命令与容器运行模式相关的选项" class="headerlink" title="create命令与容器运行模式相关的选项"></a>create命令与容器运行模式相关的选项</h4><p>-d, –detach=true|false (是否在后台运行容器，默认为否)<br>-P, –publish-all=true|false (通过NAT机制将容器标记暴露的端口自动映射到本地主机的临时端口)<br>-p, –publish=[] (指定如何映射到本地主机端口)<br>–rm=true|false （容器退出后是否自动删除，不能跟-d同时使用）<br>-i, –interactive=true|false (保持标准输入打开，默认为false)<br>-t, –tty=true|false (是否分配一个伪终端，默认是false)<br>–expose=[] (指定容器会暴露出来的端口或端口范围)<br>–group-add=[] (运行容器的用户组)<br>-v|–volume[=[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]] (挂载主机上的文件卷到容器内)<br>-w, –workdir=”” (容器内的默认工作目录)</p>
<h4 id="create命令与容器环境和配置相关的选项"><a href="#create命令与容器环境和配置相关的选项" class="headerlink" title="create命令与容器环境和配置相关的选项"></a>create命令与容器环境和配置相关的选项</h4><p>–add-host=[] (在容器内添加一个主机名到IP地址的映射关系（通过/etc/hosts文件）)<br>-h, –hostname=”” (指定容器内的主机名)<br>–name=”” (指定容器的别名)</p>
<h4 id="create命令与容器资源限制和安全保护相关的选项"><a href="#create命令与容器资源限制和安全保护相关的选项" class="headerlink" title="create命令与容器资源限制和安全保护相关的选项"></a>create命令与容器资源限制和安全保护相关的选项</h4><p>–privileged=true|false (是否给容器以高权限，这意味着容器内应用将不受权限下限制，一般不推荐)<br>–read-only=true|false (是否让容器内的文件系统只读)</p>
<h4 id="启动容器说明"><a href="#启动容器说明" class="headerlink" title="启动容器说明"></a>启动容器说明</h4><p>当利用docker run来创建并启动容器时，Docker在后台运行的标准操作包括：</p>
<p>·检查本地是否存在指定的镜像，不存在就从公有仓库下载；<br>·利用镜像创建一个容器，并启动该容器；<br>·分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；<br>·从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；<br>·从网桥的地址池配置一个IP地址给容器；<br>·执行用户指定的应用程序；<br>·执行完毕后容器被自动终止。</p>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用docker stop来终止一个运行中的容器。该命令的格式为docker stop[-t|–time[=10]][CONTAINER…]。<br>首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。<br>这个时候如果需要进入容器进行操作，有多种方法，包括使用官方的attach或exec命令，以及第三方的nsenter工具等。下面分别介绍一下。</p>
<h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h4><p>attach是Docker自带的命令，命令格式为：</p>
<p>支持三个主要选项：<br>·–detach-keys[=[]]：指定退出attach模式的快捷键序列，默认是CTRL-p CTRL-q；<br>·–no-stdin=true|false：是否关闭标准输入，默认是保持打开；<br>·–sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认为true。<br>ps:当多个窗口同时用attach命令连到同一个容器的时候，所有窗口都会同步显示。不常用。</p>
<h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p>Docker从1.3.0版本起提供了一个更加方便的exec命令，可以在容器内直接执行任意命令。<br>比较重要的参数有：<br>·-i，–interactive=true|false：打开标准输入接受用户输入命令，默认为false；<br>·–privileged=true|false：是否给执行命令以高权限，默认为false；<br>·-t，–tty=true|false：分配伪终端，默认为false；<br>·-u，–user=””：执行命令的用户名或ID。<br>例如进入到刚创建的容器中，并启动一个bash：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker docker]<span class="comment"># docker exec -it centos-d /bin/bash</span></div><div class="line">[root@centos<span class="_">-d</span> /]<span class="comment"># pwd</span></div><div class="line">/</div></pre></td></tr></table></figure>
<p>可以看到，一个bash终端打开了，在不影响容器内其他应用的前提下，用户可以很容易与容器进行交互。<br>注意<br>通过指定-it参数来保持标准输入打开，并且分配一个伪终端。通过exec命令对容器执行操作是最为推荐的方式。</p>
<h4 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h4><p>在util-linux软件包版本2.23+中包含nsenter工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker docker]<span class="comment"># docker start centos-d</span></div><div class="line">centos<span class="_">-d</span></div><div class="line">[root@centos-docker docker]<span class="comment"># docker ps</span></div><div class="line">CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                   NAMES</div><div class="line">0ffb8ab3f777        centos-ssh          <span class="string">"/usr/sbin/sshd -D"</span>   11 weeks ago        Up 6 seconds        0.0.0.0:10022-&gt;22/tcp   centos<span class="_">-d</span></div><div class="line">[root@centos-docker docker]<span class="comment"># PID=$(docker inspect --format "&#123;&#123; .State.Pid &#125;&#125;" centos-d)</span></div><div class="line">[root@centos-docker docker]<span class="comment"># nsenter --target $PID --mount --uts --ipc --net --pid</span></div><div class="line">[root@centos<span class="_">-d</span> /]<span class="comment"># ps -ef</span></div><div class="line">UID        PID  PPID  C STIME TTY          TIME CMD</div><div class="line">root         1     0  0 06:04 ?        00:00:00 /usr/sbin/sshd -D</div><div class="line">root         5     0  0 06:07 ?        00:00:00 -bash</div><div class="line">root        19     5  0 06:09 ?        00:00:00 ps -ef</div></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用docker rm命令来删除处于终止或退出状态的容器，命令格式为docker rm[-f|–force][-l|–link][-v|–volumes]CONTAINER[CONTAINER…]。<br>主要支持的选项包括：<br>·-f，–force=false：是否强行终止并删除一个运行中的容器；<br>·-l，–link=false：删除容器的连接，但保留容器；<br>·-v，–volumes=false：删除容器挂载的数据卷。</p>
<h3 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><p>某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用Docker的导入和导出功能。这也是Docker自身提供的一个重要特性。</p>
<h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令，该命令的格式为docker export[-o|–output[=””]]CONTAINER。其中，可以通过-o选项来指定导出的tar文件名，也可以直接通过重定向来实现。<br>ps:实现容器的迁移</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@centos-docker docker]<span class="comment"># docker export -o test_centos-d.tar.gz centos-d</span></div><div class="line">[root@centos-docker docker]<span class="comment"># ls</span></div><div class="line">a.txt  b.txt  c.txt  epel-release-7-9.noarch.rpm  test_centos-d.tar.gz</div><div class="line">[root@centos-docker docker]<span class="comment"># docker export centos-d &gt;test2_centos-d.tar.gz</span></div><div class="line">[root@centos-docker docker]<span class="comment"># ls</span></div><div class="line">a.txt  b.txt  c.txt  epel-release-7-9.noarch.rpm  <span class="built_in">test</span>2_centos-d.tar.gz  test_centos-d.tar.gz</div></pre></td></tr></table></figure>
<p>实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。<br>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>完）<br>参考资料：<a href="https://read.douban.com/reader/ebook/30546100/" target="_blank" rel="external">Docker技术入门与实践</a><br><a href="https://read.douban.com/reader/ebook/17825949/" target="_blank" rel="external">Docker进阶与实战</a> 作者：华为Docker实践小组</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初始容器与Docker&quot;&gt;&lt;a href=&quot;#初始容器与Docker&quot; class=&quot;headerlink&quot; title=&quot;初始容器与Docker&quot;&gt;&lt;/a&gt;初始容器与Docker&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/docker-overview/&quot;&gt;https://docs.docker.com/engine/docker-overview/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h2&gt;&lt;h3 id=&quot;Docker开源项目背景&quot;&gt;&lt;a href=&quot;#Docker开源项目背景&quot; class=&quot;headerlink&quot; title=&quot;Docker开源项目背景&quot;&gt;&lt;/a&gt;Docker开源项目背景&lt;/h3&gt;&lt;p&gt;Docker是基于Go语言实现的开源容器项目，诞生于2013年年初，最初发起者是dotCloud公司。Docker自开源后受到广泛的关注和讨论，目前已有多个相关项目（包括Docker三剑客、Kubernetes等），逐渐形成了围绕Docker容器的生态体系。&lt;br&gt;由于Docker在业界造成的影响力实在太大，dotCloud公司后来也直接改名为Docker Inc，并专注于Docker相关技术和产品的开发。&lt;/p&gt;
&lt;p&gt;对于Docker，目前的定义是一个开源的容器引擎，可以方便地对容器（关于容器，将在第2章详细介绍）进行管理。其对镜像的打包封装，以及引入的Docker Registry对镜像的统一管理，构建了方便快捷的“Build，Ship and Run”流程，它可以统一整个开发、测试和部署的环境和流程，极大地减少运维成本。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://itjinkui.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://itjinkui.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://itjinkui.github.io/2017/05/25/systemd/"/>
    <id>http://itjinkui.github.io/2017/05/25/systemd/</id>
    <published>2017-05-25T09:59:57.000Z</published>
    <updated>2017-05-26T05:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Systemd-入门教程：命令篇"><a href="#Systemd-入门教程：命令篇" class="headerlink" title="Systemd 入门教程：命令篇"></a>Systemd 入门教程：命令篇</h1><p>Systemd 是 Linux 系统工具，用来启动<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="external">守护进程</a>，已成为大多数发行版的标准配置。</p>
<p>本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。</p>
<a id="more"></a>
<h2 id="一、由来"><a href="#一、由来" class="headerlink" title="一、由来"></a>一、由来</h2><p>历史上，<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="external">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="external"><code>init</code></a>进程。</p>
<p>下面的命令用来启动服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost /]<span class="comment"># service httpd start</span></div><div class="line">Redirecting to /bin/systemctl start  httpd.service</div></pre></td></tr></table></figure>
<p>ps:Centos7已经不支持了喔！</p>
<p>这种方法有两个缺点。</p>
<p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p>
<p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>
<h2 id="二、Systemd-概述"><a href="#二、Systemd-概述" class="headerlink" title="二、Systemd 概述"></a>二、Systemd 概述</h2><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p>
<p>根据 Linux 惯例，字母<code>d</code>是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030702.jpg" alt=""></p>
<p>（上图为 Systemd 作者 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering" target="_blank" rel="external">Lennart Poettering</a>）</p>
<p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl --version</div></pre></td></tr></table></figure>
<p>上面的命令查看 Systemd 的版本。</p>
<p>Systemd 的优点是功能强大，使用方便，缺点是系统庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反“keep simple, keep stupid”的<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="external">Unix 哲学</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt=""></p>
<p>（上图为 Systemd 架构图）</p>
<h2 id="三、系统管理"><a href="#三、系统管理" class="headerlink" title="三、系统管理"></a>三、系统管理</h2><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<h3 id="3-1-systemctl"><a href="#3-1-systemctl" class="headerlink" title="3.1 systemctl"></a>3.1 systemctl</h3><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重启系统</span></div><div class="line">$ sudo systemctl reboot</div><div class="line"></div><div class="line"><span class="comment"># 关闭系统，切断电源</span></div><div class="line">$ sudo systemctl poweroff</div><div class="line"></div><div class="line"><span class="comment"># CPU停止工作</span></div><div class="line">$ sudo systemctl halt</div><div class="line"></div><div class="line"><span class="comment"># 暂停系统</span></div><div class="line">$ sudo systemctl <span class="built_in">suspend</span></div><div class="line"></div><div class="line"><span class="comment"># 让系统进入冬眠状态</span></div><div class="line">$ sudo systemctl hibernate</div><div class="line"></div><div class="line"><span class="comment"># 让系统进入交互式休眠状态</span></div><div class="line">$ sudo systemctl hybrid-sleep</div><div class="line"></div><div class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></div><div class="line">$ sudo systemctl rescue</div></pre></td></tr></table></figure>
<h3 id="3-2-systemd-analyze"><a href="#3-2-systemd-analyze" class="headerlink" title="3.2 systemd-analyze"></a>3.2 systemd-analyze</h3><p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看启动耗时</span></div><div class="line">$ systemd-analyze                                                                                       </div><div class="line"></div><div class="line"><span class="comment"># 查看每个服务的启动耗时</span></div><div class="line">$ systemd-analyze blame</div><div class="line"></div><div class="line"><span class="comment"># 显示瀑布状的启动过程流</span></div><div class="line">$ systemd-analyze critical-chain</div><div class="line"></div><div class="line"><span class="comment"># 显示指定服务的启动流(eg:sshd.service)</span></div><div class="line">$ systemd-analyze critical-chain sshd.service</div></pre></td></tr></table></figure>
<h3 id="3-3-hostnamectl"><a href="#3-3-hostnamectl" class="headerlink" title="3.3 hostnamectl"></a>3.3 hostnamectl</h3><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示当前主机的信息</span></div><div class="line">$ hostnamectl</div><div class="line"></div><div class="line"><span class="comment"># 设置主机名。</span></div><div class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname CentOS-Docker</div></pre></td></tr></table></figure>
<h3 id="3-4-localectl"><a href="#3-4-localectl" class="headerlink" title="3.4 localectl"></a>3.4 localectl</h3><p><code>localectl</code>命令用于查看本地化设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看本地化设置</span></div><div class="line">$ localectl</div><div class="line"></div><div class="line"><span class="comment"># 设置本地化参数。</span></div><div class="line">$ sudo localectl <span class="built_in">set</span>-locale LANG=zh_CN.UTF-8</div><div class="line">$ sudo localectl <span class="built_in">set</span>-keymap cn</div></pre></td></tr></table></figure>
<h3 id="3-5-timedatectl"><a href="#3-5-timedatectl" class="headerlink" title="3.5 timedatectl"></a>3.5 timedatectl</h3><p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看当前时区设置</span></div><div class="line">$ timedatectl</div><div class="line"></div><div class="line"><span class="comment"># 显示所有可用的时区</span></div><div class="line">$ timedatectl list-timezones                                                                                   </div><div class="line"></div><div class="line"><span class="comment"># 设置当前时区</span></div><div class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone America/New_York</div><div class="line">$ sudo timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</div><div class="line">$ sudo timedatectl <span class="built_in">set</span>-time HH:MM:SS</div></pre></td></tr></table></figure>
<h3 id="3-6-loginctl"><a href="#3-6-loginctl" class="headerlink" title="3.6 loginctl"></a>3.6 loginctl</h3><p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出当前session</span></div><div class="line">$ loginctl list-sessions</div><div class="line"></div><div class="line"><span class="comment"># 列出当前登录用户</span></div><div class="line">$ loginctl list-users</div><div class="line"></div><div class="line"><span class="comment"># 列出显示指定用户的信息</span></div><div class="line">$ loginctl show-user root</div></pre></td></tr></table></figure>
<h2 id="四、Unit"><a href="#四、Unit" class="headerlink" title="四、Unit"></a>四、Unit</h2><h3 id="4-1-含义"><a href="#4-1-含义" class="headerlink" title="4.1 含义"></a>4.1 含义</h3><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<p>Unit 一共分成12种。</p>
<blockquote>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
</blockquote>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出正在运行的 Unit</span></div><div class="line">$ systemctl list-units</div><div class="line"></div><div class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></div><div class="line">$ systemctl list-units --all</div><div class="line"></div><div class="line"><span class="comment"># 列出所有没有运行的 Unit</span></div><div class="line">$ systemctl list-units --all --state=inactive</div><div class="line"></div><div class="line"><span class="comment"># 列出所有加载失败的 Unit</span></div><div class="line">$ systemctl list-units --failed</div><div class="line"></div><div class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></div><div class="line">$ systemctl list-units --type=service</div></pre></td></tr></table></figure>
<h3 id="4-2-Unit-的状态"><a href="#4-2-Unit-的状态" class="headerlink" title="4.2 Unit 的状态"></a>4.2 Unit 的状态</h3><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示系统状态</span></div><div class="line">$ systemctl status</div><div class="line"></div><div class="line"><span class="comment"># 显示单个 Unit 的状态</span></div><div class="line">$ sysystemctl status httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示远程主机的某个 Unit 的状态</span></div><div class="line">$ systemctl -H root@rhel7.example.com status httpd.service</div></pre></td></tr></table></figure>
<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示某个 Unit 是否正在运行</span></div><div class="line">$ systemctl is-active httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 是否处于启动失败状态</span></div><div class="line">$ systemctl is-failed httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 服务是否建立了启动链接</span></div><div class="line">$ systemctl is-enabled httpd.service</div></pre></td></tr></table></figure>
<h3 id="4-3-Unit-管理"><a href="#4-3-Unit-管理" class="headerlink" title="4.3 Unit 管理"></a>4.3 Unit 管理</h3><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 立即启动一个服务</span></div><div class="line">$ sudo systemctl start httpd.service</div><div class="line"><span class="comment"># 立即停止一个服务</span></div><div class="line">$ sudo systemctl stop httpd.service</div><div class="line"><span class="comment"># 重启一个服务</span></div><div class="line">$ sudo systemctl restart httpd.service</div><div class="line"><span class="comment"># 杀死一个服务的所有子进程</span></div><div class="line">$ sudo systemctl <span class="built_in">kill</span> httpd.service</div><div class="line"><span class="comment"># 重新加载一个服务的配置文件</span></div><div class="line">$ sudo systemctl reload httpd.service</div><div class="line"><span class="comment"># 重载所有修改过的配置文件</span></div><div class="line">$ sudo systemctl daemon-reload</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 的所有底层参数</span></div><div class="line">$ systemctl show httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 的指定属性的值</span></div><div class="line">$ systemctl show -p CPUShares httpd.service</div></pre></td></tr></table></figure>
<h3 id="4-4-依赖关系"><a href="#4-4-依赖关系" class="headerlink" title="4.4 依赖关系"></a>4.4 依赖关系</h3><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl list-dependencies nginx.service</div></pre></td></tr></table></figure>
<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl list-dependencies --all nginx.service</div></pre></td></tr></table></figure>
<h2 id="五、Unit-的配置文件"><a href="#五、Unit-的配置文件" class="headerlink" title="五、Unit 的配置文件"></a>五、Unit 的配置文件</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在这个目录。</p>
<p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl <span class="built_in">enable</span> sshd.service</div><div class="line"><span class="comment"># 等同于</span></div><div class="line">$ sudo ln <span class="_">-s</span> <span class="string">'/usr/lib/systemd/system/sshd.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/sshd.service'</span></div></pre></td></tr></table></figure>
<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl <span class="built_in">disable</span> sshd.service</div></pre></td></tr></table></figure>
<p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p>
<h3 id="5-2-配置文件的状态"><a href="#5-2-配置文件的状态" class="headerlink" title="5.2 配置文件的状态"></a>5.2 配置文件的状态</h3><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出所有配置文件</span></div><div class="line">$ systemctl list-unit-files</div><div class="line"></div><div class="line"><span class="comment"># 列出指定类型的配置文件</span></div><div class="line">$ systemctl list-unit-files --type=service</div></pre></td></tr></table></figure>
<p>这个命令会输出一个列表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ systemctl list-unit-files</div><div class="line"></div><div class="line">UNIT FILE              STATE</div><div class="line">chronyd.service        enabled</div><div class="line">clamd@.service         static</div><div class="line">sshd.service     disabled</div></pre></td></tr></table></figure>
<p>这个列表显示每个配置文件的状态，一共有四种。</p>
<blockquote>
<ul>
<li>enabled：已建立启动链接</li>
<li>disabled：没建立启动链接</li>
<li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
</blockquote>
<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl status httpd.service</div></pre></td></tr></table></figure>
<p>一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl daemon-reload</div><div class="line">$ sudo systemctl restart httpd.service</div></pre></td></tr></table></figure>
<h3 id="5-3-配置文件的格式"><a href="#5-3-配置文件的格式" class="headerlink" title="5.3 配置文件的格式"></a>5.3 配置文件的格式</h3><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ systemctl cat atd.service</div><div class="line"></div><div class="line">[Unit]</div><div class="line">Description=ATD daemon</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">ExecStart=/usr/bin/atd</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure>
<p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[Section]</div><div class="line">Directive1=value</div><div class="line">Directive2=value</div><div class="line"></div><div class="line">. . .</div></pre></td></tr></table></figure>
<p>注意，键值对的等号两侧不能有空格。</p>
<h3 id="5-4-配置文件的区块"><a href="#5-4-配置文件的区块" class="headerlink" title="5.4 配置文件的区块"></a>5.4 配置文件的区块</h3><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Description</code>：简短描述</li>
<li><code>Documentation</code>：文档地址</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li>
<li><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li>
<li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</li>
<li><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
</blockquote>
<p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
</blockquote>
<p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Type</code>：定义启动时的进程行为。它有以下几种值。<ul>
<li><code>simple</code>：默认值，执行<code>ExecStart</code>指定的命令，启动主进程</li>
<li><code>forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>
<li><code>oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>
<li><code>dbus</code>：当前服务通过D-Bus启动</li>
<li><code>notify</code>：当前服务启动完毕，会通知<code>Systemd</code>，再继续往下执行</li>
<li><code>idle</code>：若有其他任务执行完毕，当前服务才会运行</li>
</ul>
</li>
<li><code>ExecStart</code>：启动当前服务的命令</li>
<li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li>
<li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li>
<li><code>ExecReload</code>：重启当前服务时执行的命令</li>
<li><code>ExecStop</code>：停止当前服务时执行的命令</li>
<li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li>
<li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括<code>always</code>（总是重启）、<code>on-success</code>、<code>on-failure</code>、<code>on-abnormal</code>、<code>on-abort</code>、<code>on-watchdog</code></li>
<li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li>
<li><code>Environment</code>：指定环境变量</li>
</ul>
</blockquote>
<p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="六、Target"><a href="#六、Target" class="headerlink" title="六、Target"></a>六、Target</h2><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于“状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看当前系统的所有 Target</span></div><div class="line">$ systemctl list-unit-files --type=target</div><div class="line"></div><div class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></div><div class="line">$ systemctl list-dependencies multi-user.target</div><div class="line"></div><div class="line"><span class="comment"># 查看启动时的默认 Target</span></div><div class="line">$ systemctl get-default</div><div class="line"></div><div class="line"><span class="comment"># 设置启动时的默认 Target</span></div><div class="line">$ sudo systemctl <span class="built_in">set</span>-default multi-user.target</div><div class="line"></div><div class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></div><div class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></div><div class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></div><div class="line">$ sudo systemctl isolate multi-user.target</div></pre></td></tr></table></figure>
<p>Target 与 传统 RunLevel 的对应关系如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Traditional runlevel      New target name     Symbolically linked to...</div><div class="line"></div><div class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</div><div class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</div><div class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</div><div class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</div><div class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</div><div class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</div><div class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</div></pre></td></tr></table></figure>
<p>它与<code>init</code>进程的主要差别如下。</p>
<blockquote>
<p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p>
<p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
</blockquote>
<h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a>七、日志管理</h2><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<p><code>journalctl</code>功能强大，用法非常多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></div><div class="line">$ sudo journalctl</div><div class="line"></div><div class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></div><div class="line">$ sudo journalctl -k</div><div class="line"></div><div class="line"><span class="comment"># 查看系统本次启动的日志</span></div><div class="line">$ sudo journalctl -b</div><div class="line">$ sudo journalctl -b -0</div><div class="line"></div><div class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></div><div class="line">$ sudo journalctl -b -1</div><div class="line"></div><div class="line"><span class="comment"># 查看指定时间的日志</span></div><div class="line">$ sudo journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></div><div class="line">$ sudo journalctl --since <span class="string">"20 min ago"</span></div><div class="line">$ sudo journalctl --since yesterday</div><div class="line">$ sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></div><div class="line"></div><div class="line"><span class="comment"># 显示尾部的最新10行日志</span></div><div class="line">$ sudo journalctl -n</div><div class="line"></div><div class="line"><span class="comment"># 显示尾部指定行数的日志</span></div><div class="line">$ sudo journalctl -n 20</div><div class="line"></div><div class="line"><span class="comment"># 实时滚动显示最新日志</span></div><div class="line">$ sudo journalctl <span class="_">-f</span></div><div class="line"></div><div class="line"><span class="comment"># 查看指定服务的日志</span></div><div class="line">$ sudo journalctl /usr/lib/systemd/systemd</div><div class="line"></div><div class="line"><span class="comment"># 查看指定进程的日志</span></div><div class="line">$ sudo journalctl _PID=1</div><div class="line"></div><div class="line"><span class="comment"># 查看某个路径的脚本的日志</span></div><div class="line">$ sudo journalctl /usr/bin/bash</div><div class="line"></div><div class="line"><span class="comment"># 查看指定用户的日志</span></div><div class="line">$ sudo journalctl _UID=33 --since today</div><div class="line"></div><div class="line"><span class="comment"># 查看某个 Unit 的日志</span></div><div class="line">$ sudo journalctl -u nginx.service</div><div class="line">$ sudo journalctl -u nginx.service --since today</div><div class="line"></div><div class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></div><div class="line">$ sudo journalctl -u nginx.service <span class="_">-f</span></div><div class="line"></div><div class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></div><div class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</div><div class="line"></div><div class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></div><div class="line"><span class="comment"># 0: emerg</span></div><div class="line"><span class="comment"># 1: alert</span></div><div class="line"><span class="comment"># 2: crit</span></div><div class="line"><span class="comment"># 3: err</span></div><div class="line"><span class="comment"># 4: warning</span></div><div class="line"><span class="comment"># 5: notice</span></div><div class="line"><span class="comment"># 6: info</span></div><div class="line"><span class="comment"># 7: debug</span></div><div class="line">$ sudo journalctl -p err -b</div><div class="line"></div><div class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></div><div class="line">$ sudo journalctl --no-pager</div><div class="line"></div><div class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></div><div class="line">$ sudo journalctl -b -u nginx.service -o json</div><div class="line"></div><div class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></div><div class="line">$ sudo journalctl -b -u nginx.serviceqq</div><div class="line"> -o json-pretty</div><div class="line"></div><div class="line"><span class="comment"># 显示日志占据的硬盘空间</span></div><div class="line">$ sudo journalctl --disk-usage</div><div class="line"></div><div class="line"><span class="comment"># 指定日志文件占据的最大空间</span></div><div class="line">$ sudo journalctl --vacuum-size=1G</div><div class="line"></div><div class="line"><span class="comment"># 指定日志文件保存多久</span></div><div class="line">$ sudo journalctl --vacuum-time=1years</div></pre></td></tr></table></figure>
<p>（完）<br>转载于<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a><br>如何编写 Unit 的配置文件</p>
<ul>
<li><a href="https://fedoramagazine.org/what-is-an-init-system/" target="_blank" rel="external">What is an init system?</a></li>
<li><a href="http://fedoramagazine.org/systemd-converting-sysvinit-scripts/" target="_blank" rel="external">systemd: Converting sysvinit scripts</a></li>
<li><a href="https://fedoramagazine.org/systemd-unit-dependencies-and-order/" target="_blank" rel="external">systemd: Unit dependencies and order</a></li>
<li><a href="https://fedoraproject.org/wiki/Systemd" target="_blank" rel="external">Systemd</a></li>
<li><a href="http://fedoraproject.org/wiki/Packaging%3aSystemd" target="_blank" rel="external">Packaging:Systemd</a></li>
<li><a href="http://patrakov.blogspot.jp/2011/01/writing-systemd-service-files.html" target="_blank" rel="external">Writing systemd service files</a></li>
<li><a href="http://unix.stackexchange.com/questions/47695/how-to-write-startup-script-for-systemd" target="_blank" rel="external">How to write startup script for systemd</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Systemd-入门教程：命令篇&quot;&gt;&lt;a href=&quot;#Systemd-入门教程：命令篇&quot; class=&quot;headerlink&quot; title=&quot;Systemd 入门教程：命令篇&quot;&gt;&lt;/a&gt;Systemd 入门教程：命令篇&lt;/h1&gt;&lt;p&gt;Systemd 是 Linux 系统工具，用来启动&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html&quot;&gt;守护进程&lt;/a&gt;，已成为大多数发行版的标准配置。&lt;/p&gt;
&lt;p&gt;本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://itjinkui.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://itjinkui.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://itjinkui.github.io/2017/05/11/git-how/"/>
    <id>http://itjinkui.github.io/2017/05/11/git-how/</id>
    <published>2017-05-11T09:57:29.000Z</published>
    <updated>2017-05-15T08:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Git 闲话</p>
<blockquote>
<p>1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。<br>2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。<br>“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“<br>只干了两件事啊，毫不夸张的说：惊天地泣鬼神。<br>第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。<br>再接下来，Git 就是我们的主题了，记录以备忘。</p>
</blockquote>
<a id="more"></a>
<h2 id="Git安装与配置"><a href="#Git安装与配置" class="headerlink" title="Git安装与配置"></a>Git安装与配置</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Mac 上brew安装算是最便捷的了</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~ brew install git </div><div class="line">~ brew --version</div><div class="line">Homebrew 1.1.13</div><div class="line">Homebrew/homebrew-core (git revision ea163; last commit 2017-04-20)</div><div class="line">~ git --version</div><div class="line">git version 2.11.0</div></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>可以通过 git config –list –global 命令来查看：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~ git config --list --global</div><div class="line">user.email=1250114609@qq.com</div><div class="line">user.name=千古不见一人闲</div><div class="line">color.ui=auto</div><div class="line">alias.st=status</div><div class="line">alias.lg=<span class="built_in">log</span> --color --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</div></pre></td></tr></table></figure>
<p>可以看到有两个alias出现，这里使用了别名。</p>
<p>配置别名</p>
<p>这个功能在shell中是很常用的。我们可以做一些别名来取代比较复杂的指令。<br>比如上面就是使用了以下两个配置</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~ git config --global alias.st status</div><div class="line"></div><div class="line">~ git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></div></pre></td></tr></table></figure>
<h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>当本地git仓库与git远程仓库通信的时候，需要进行SSH身份认证。<br>打开根目录下的.ssh目录：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~/.ssh la</div><div class="line">.              ..             config         github_rsa     github_rsa.pub id_rsa         id_rsa.pub     known_hosts</div></pre></td></tr></table></figure>
<p>如果没有id_rsa和id_rsa.pub这两个文件，就通过如下的命令生成：</p>
<p>ssh-keygen -t rsa -C “youremail@example.com”<br>id_rsa和id_rsa.pub这两个文件，就是SSH Key的秘钥对，id_rsa是私钥，id_rsa.pub是公钥，用在github上表明身份。<br>在GitHub上的SSH keys中添加刚刚生成的key。(id_rsa.pub)</p>
<h4 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h4><p>创建一个目录，并cd到目录下，通过调用git init来将现有目录初始化为git仓库，或者直接在git init后面跟上目录名，同样也可以创建一个新的仓库。</p>
<p>git clone 直接clone一个远程仓库也是可以的。</p>
<h4 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace git_springboot</div><div class="line">~/Documents/workspace/git_springboot(master ✔) la</div><div class="line">.    ..   .git</div><div class="line">~/Documents/workspace/git_springboot(master ✔) touch README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) vim README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git add README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git commit -m <span class="string">"add README.md"</span></div><div class="line">[master be9081a] add README.md</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line"> create mode 100644 README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✔)</div></pre></td></tr></table></figure>
<h4 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h4><p>修改README.md文件，git st查看修改</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>Git 比较不同版本文件差异的常用命令格式：</p>
<blockquote>
<p>git diff  查看尚未暂存的文件更新了哪些部分      </p>
<p>git diff filename 查看尚未暂存的某个文件更新了哪些</p>
<p>git diff –cached 查看已经暂存起来的文件和上次提交的版本之间的差异</p>
<p>git diff –cached filename 查看已经暂存起来的某个文件和上次提交的版本之间的差异</p>
</blockquote>
<p>使用git diff README.md 命令看一下修改的具体内容</p>
<blockquote>
<p>diff –git a/README.md b/README.md<br>index e8281cd..f1729fb 100644<br>— a/README.md<br>+++ b/README.md<br>@@ -1 +1 @@<br>-this’s ok.<br>+this’s ok,modify.</p>
</blockquote>
<p>add和commit之后，我们都使用status来查看下状态，可以发现，在commit之后，git提示我们，工作区是干净的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git add README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git commit -m <span class="string">"modify README.md"</span></div><div class="line">[master a77107b] modify README.md</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div><div class="line">~/Documents/workspace/git_springboot(master ✔) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure>
<h4 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h4><p>使用git lg 命令来查看<br>也可以使用gitk命令来查看图形化的log记录</p>
<h4 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h4><p>Git通常是工作在三个区域上：</p>
<p>工作区<br>暂存区<br>历史区<br>其中工作区就是我们平时工作、修改代码的区域；而历史区，用来保存各个版本；而暂存区，则是Git的核心所在。<br><a href="https://git-scm.com/" target="_blank" rel="external">Git官网</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解Git</a></p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>回退版本是必不可少的操作啊</p>
<p>我们来考虑以下常见的几种情况：</p>
<ol>
<li>文件已经修改，但是还没有git add</li>
<li>文件已经add到暂存区，又作了修改</li>
<li>文件的修改已经add到了暂存区</li>
</ol>
<p>分别执行以下操作：</p>
<p>➜git checkout – README.md<br>修改被删除，完全还原到上次commit的状态，也就是服务器版本(1.)<br>最后的修改被删除，还原到上次add的状态，也就是修改前的暂存区状态(2.)<br>➜git reset HEAD README.md(3.)</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">~/Documents/workspace/git_springboot(master ✗) git reset HEAD README.md</div><div class="line">Unstaged changes after reset:</div><div class="line">M       README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>通过git reset HEAD README.md，我们就把暂存区的文件清除了。这样，在本地就是add前的状态，通过checkout操作，就可以进行修改回退了。<br>在Git中，用HEAD表示当前版本，上一个版本就是<code>HEAD^</code>，<br>上上一个版本就是<code>HEAD^^</code>。（git reset –hard HEAD）<br>要回退到哪个版本，也可以写commit id。</p>
<h4 id="前进版本"><a href="#前进版本" class="headerlink" title="前进版本"></a>前进版本</h4><p>如果我们回退到了旧的版本，但是却后悔了想回到后面某个新的版本,git reflog 查看操作历史。找到 commit id。<br>版本号没必要写全，前7位就可以了，Git会自动去找。</p>
<h4 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h4><p>这里的暂存不是前面说的暂存区，而是只一次备份与恢复操作。<br>git stash<br>指令来将当前修改暂存，这样就可以切换到其他分支或者就在当前干净的分支上checkout了。<br>比如你checkout了一个issue分支，修改了bug，使用git merge合并到了master分支，删除issue分支，切换到dev分支，想继续之前的新功能开发。<br>这时候，就需要恢复现场了：</p>
<p>git stash list<br>指令来查看当前暂存的内容记录。<br>然后，通过git stash apply或者git stash pop来进行恢复，它们的区别是，前者不会删除记录（当然你可以使用git stash drop来删除），而后者会。</p>
<h4 id="远程仓库-amp-同步协作"><a href="#远程仓库-amp-同步协作" class="headerlink" title="远程仓库&amp;同步协作"></a>远程仓库&amp;同步协作</h4><p>现在你在本地建立了git仓库，想与远程git仓库同步。</p>
<p>我们先在github上创建一个repo（仓库），<br>创建之后，github给我们提示：<br><img src="git.png" alt="git_createrepository"><br>可以看出，执行以下指令就和远程仓库建立关联了，自然也就可以多人同步协作开发了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:itjinkui/git_springboot.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>git 入门操作算是完成了。企业可以通过GitLab搭建自己的版本管理系统。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Git 闲话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。&lt;br&gt;2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。&lt;br&gt;“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“&lt;br&gt;只干了两件事啊，毫不夸张的说：惊天地泣鬼神。&lt;br&gt;第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。&lt;br&gt;再接下来，Git 就是我们的主题了，记录以备忘。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="git" scheme="http://itjinkui.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://itjinkui.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://itjinkui.github.io/2017/03/28/hello-world/"/>
    <id>http://itjinkui.github.io/2017/03/28/hello-world/</id>
    <published>2017-03-28T10:29:41.000Z</published>
    <updated>2017-05-11T08:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
