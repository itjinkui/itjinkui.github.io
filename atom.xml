<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zeroto的博客</title>
  <subtitle>追求卓越，成功自然而来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//zeroto.tech/"/>
  <updated>2019-03-26T01:52:30.000Z</updated>
  <id>//zeroto.tech/</id>
  
  <author>
    <name>千古不见一人闲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IntelliJ IDEA 从SVN检出Maven项目到Tomcat部署</title>
    <link href="//zeroto.tech/2019/02/28/IDEA%E8%B5%B7%E6%AD%A5/"/>
    <id>//zeroto.tech/2019/02/28/IDEA起步/</id>
    <published>2019-02-28T06:10:48.000Z</published>
    <updated>2019-03-26T01:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><ul>
<li>下载IDEA（不要下载社区版），并激活</li>
<li>Maven环境配置</li>
<li>检出项目</li>
<li>同一窗口查看多个项目（模块），就像eclipse一样</li>
<li>Tomcat 配置</li>
<li>启动项目</li>
</ul>
<a id="more"></a>
<h2 id="截图分步骤展示"><a href="#截图分步骤展示" class="headerlink" title="截图分步骤展示"></a>截图分步骤展示</h2><h3 id="激活IDEA"><a href="#激活IDEA" class="headerlink" title="激活IDEA"></a>激活IDEA</h3><p><a href="http://idea.lanyus.com/" target="_blank" rel="external">IntelliJ IDEA 注册码 </a></p>
<h3 id="Maven环境配置"><a href="#Maven环境配置" class="headerlink" title="Maven环境配置"></a>Maven环境配置</h3><p>idea 自带maven，只需把settings.xml放在合适的路径下即可。</p>
<h3 id="SVN检出项目"><a href="#SVN检出项目" class="headerlink" title="SVN检出项目"></a>SVN检出项目</h3><p><img src="media/15513350795895.jpg" alt=""></p>
<p>如果SVN版本控制不是svn协议，而是https协议的话，可以选中截图画框选项：</p>
<p><img src="media/15513352497401.jpg" alt=""></p>
<h3 id="同一窗口查看多个项目（模块）"><a href="#同一窗口查看多个项目（模块）" class="headerlink" title="同一窗口查看多个项目（模块）"></a>同一窗口查看多个项目（模块）</h3><p>idea打开 File -&gt; Project Structure</p>
<p><img src="media/15513354923642.jpg" alt=""></p>
<h3 id="Tomcat-配置"><a href="#Tomcat-配置" class="headerlink" title="Tomcat 配置"></a>Tomcat 配置</h3><p>1、安装插件：<br><img src="media/15513357317241.jpg" alt=""></p>
<p>2、配置</p>
<p><img src="media/15513357863105.jpg" alt=""></p>
<p><img src="media/15513358498640.jpg" alt=""></p>
<p><img src="media/15513359067539.jpg" alt=""></p>
<p><img src="media/15513359970045.jpg" alt=""></p>
<h2 id="Tomcat-端口号与项目中bootstrap-yml里面的port配置一致即可-启动。"><a href="#Tomcat-端口号与项目中bootstrap-yml里面的port配置一致即可-启动。" class="headerlink" title="Tomcat 端口号与项目中bootstrap.yml里面的port配置一致即可 启动。"></a>Tomcat 端口号与项目中bootstrap.yml里面的port配置一致即可 启动。</h2><p><img src="/Users/jinkui/Library/Application Support/typora-user-images/image-20190311183809279.png" alt="image-20190311183809279"></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>Use ⇧⌘⏎ to complete a current statement such as if, do-while, try-catch, return (or a method call) into a syntactically correct construct (e.g. add curly braces).</li>
<li>⌘ + F  在当前文件进行文本查找</li>
<li>⌘ + R 在当前文件进行文本替换</li>
<li>⌘ + Z 撤销</li>
<li>⌘ + Y 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面;（自定义）</li>
<li>⌘ + X 剪切光标所在行 或 剪切选择内容</li>
<li>⌘ + C 复制光标所在行 或 复制选择内容</li>
<li>⌘ + D 删除光标所在行或删除选中的行（自定义）</li>
<li>⌘ + E 显示最近打开的文件记录列表</li>
<li>⌘ + O 类大纲（自定义）</li>
<li>⌘ + L 在当前文件跳转到指定行处</li>
<li>⌘ + G <a href="https://www.jetbrains.com/help/rider/Finding_and_Replacing_Text_in_File.html#search_through_current_file" target="_blank" rel="external">查找下一个/移至下一个出现</a></li>
<li>⌘ + J 插入自定义动态代码模板</li>
<li>⌘ + P 根据输入的 <strong>类名</strong> 查找类文件 （自定义）</li>
<li>⌘ + shift + O 根据输入的 <strong>文件名</strong> 查找文件 </li>
<li><strong>⇧ + F6</strong> It is possible to rename CSS selectors directly from HTML. Position the caret at the selector to be renamed and press ⇧F6 (Refactor | Rename).</li>
<li>⌘ + shift + U 大小写转换</li>
<li>⌘ + shift + ↩  自动结束代码，行末自动添加分号</li>
<li>alt + P 显示方法的参数信息（自定义）</li>
<li>⌘ + N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li>
<li><strong>⌘ + shift+V</strong>  从最近的缓冲区粘贴</li>
<li>Use ⌘↑ keyboard shortcut to show the navigation bar, and arrow keys to locate the necessary files or folders.</li>
<li><strong>⌘ + shift+上/下箭头</strong>  向上或向下移动</li>
<li>⌘ + alt + L  可以再src 下直接Optimize imports</li>
<li>⌃ + alt + O 自动导包</li>
</ol>
<p><a href="">四、Compile and Run（编译和运行）</a></p>
<p><strong>⌘F9</strong>  编译Project</p>
<p><strong>⌘⇧F9</strong>  编译选择的文件、包或模块</p>
<p><strong>⌃⌥R</strong>  弹出 Run 的可选择菜单</p>
<p><strong>⌃⌥D</strong>  弹出 Debug 的可选择菜单</p>
<p><strong>⌃R</strong>  运行</p>
<p><strong>⌃D</strong>  调试</p>
<p><strong>⌃⇧R, ⌃⇧D</strong>  从编辑器运行上下文环境配置</p>
<p><a href="">五、Debugging（调试）</a></p>
<p><strong>F8</strong>  进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</p>
<p><strong>F7</strong>  进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</p>
<p><strong>⇧F7</strong>  智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</p>
<p><strong>⇧F8</strong>  跳出</p>
<p><strong>⌥F9</strong>  运行到光标处，如果光标前有其他断点会进入到该断点</p>
<p><strong>⌥F8</strong>  计算表达式（可以更改变量值使其生效）</p>
<p><strong>⌘⌥R</strong>  恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</p>
<p><strong>⌘F8</strong>  切换断点（若光标当前行有断点则取消断点，没有则加上断点）</p>
<p><strong>⌘⇧F8</strong>  查看断点信息</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;下载IDEA（不要下载社区版），并激活&lt;/li&gt;
&lt;li&gt;Maven环境配置&lt;/li&gt;
&lt;li&gt;检出项目&lt;/li&gt;
&lt;li&gt;同一窗口查看多个项目（模块），就像eclipse一样&lt;/li&gt;
&lt;li&gt;Tomcat 配置&lt;/li&gt;
&lt;li&gt;启动项目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="IntelliJ IDEA 部署Maven项目" scheme="//zeroto.tech/tags/IntelliJ-IDEA-%E9%83%A8%E7%BD%B2Maven%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 安装配置分布式文件系统FastDFS</title>
    <link href="//zeroto.tech/2019/01/04/CentOS%207%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFastDFS/"/>
    <id>//zeroto.tech/2019/01/04/CentOS 7 安装配置分布式文件系统FastDFS/</id>
    <published>2019-01-04T06:12:50.000Z</published>
    <updated>2019-01-04T06:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>感谢淘宝资深架构师余庆大神开源了如此优秀的轻量级分布式文件系统，记录一下FastDFS V5.05在CentOS7中的安装与配置。</p>
<p>首先简单了解一下基础概念，FastDFS是一个开源的轻量级分布式文件系统，由跟踪服务器（tracker server）、存储服务器（storage server）和客户端（client）三个部分组成，主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。</p>
<a id="more"></a>
<p><strong>下载包</strong></p>
<blockquote>
<p>libfastcommon-1.0.7.tar.gz<br>FastDFS_v5.05.tar.gz<br>nginx-1.8.0.tar.gz</p>
</blockquote>
<p>FastDFS的两个核心概念分别是：</p>
<p><strong>Tracker（跟踪器）</strong></p>
<p>Tracker主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。</p>
<p>Tracker负责管理所有的Storage和group，每个storage在启动后会连接Tracker，告知自己所属的group等信息。并保持周期性的心跳，tracker根据storage的心跳信息，建立group==&gt;[storage server list]的映射表，Tracker需要管理的元信息很少，会全部存储在内存中。</p>
<p>另外tracker上的元信息都是由storage汇报的信息生成的，本身不需要持久化任何数据，这样使得tracker非常容易扩展，直接增加tracker机器即可扩展为tracker cluster来服务，cluster里每个tracker之间是完全对等的，所有的tracker都接受stroage的心跳信息，生成元数据信息来提供读写服务。</p>
<p><strong>Storage（存储节点）</strong></p>
<p>Storage采用了分卷[Volume]（或分组[group]）的组织方式，存储系统由一个或多个组组成，组与组之间的文件是相互独立的，所有组的文件容量累加就是整个存储系统中的文件容量。</p>
<p>一个卷[Volume]（组[group]）可以由一台或多台存储服务器组成，一个组中的存储服务器中的文件都是相同的，组中的多台存储服务器起到了冗余备份和负载均衡的作用，数据互为备份，存储空间以group内容量最小的storage为准，所以建议group内的多个storage尽量配置相同，以免造成存储空间的浪费。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;感谢淘宝资深架构师余庆大神开源了如此优秀的轻量级分布式文件系统，记录一下FastDFS V5.05在CentOS7中的安装与配置。&lt;/p&gt;
&lt;p&gt;首先简单了解一下基础概念，FastDFS是一个开源的轻量级分布式文件系统，由跟踪服务器（tracker server）、存储服务器（storage server）和客户端（client）三个部分组成，主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CentOS下搭建FastDFS V5.05" scheme="//zeroto.tech/tags/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BAFastDFS-V5-05/"/>
    
      <category term="FastDFS 整合 Nginx" scheme="//zeroto.tech/tags/FastDFS-%E6%95%B4%E5%90%88-Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 分布式任务</title>
    <link href="//zeroto.tech/2018/11/28/Quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>//zeroto.tech/2018/11/28/Quartz定时任务相关表介绍/</id>
    <published>2018-11-28T06:14:14.000Z</published>
    <updated>2019-02-28T06:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-qrtz-job-details：存储每一个已配置的-jobDetail-的详细信息"><a href="#1-qrtz-job-details：存储每一个已配置的-jobDetail-的详细信息" class="headerlink" title="1. qrtz_job_details：存储每一个已配置的 jobDetail 的详细信息"></a>1. qrtz_job_details：存储每一个已配置的 jobDetail 的详细信息</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>job_name</td>
<td>集群中job的名字,该名字用户自己可以随意定制,无强行要求</td>
</tr>
<tr>
<td>job_group</td>
<td>集群中job的所属组的名字,该名字用户自己随意定制,无强行要求 </td>
</tr>
<tr>
<td>description</td>
<td>相关介绍</td>
</tr>
<tr>
<td>job_class_name</td>
<td>集群中个notejob实现类的完全包名,quartz就是根据这个路径到classpath找到该job类</td>
</tr>
<tr>
<td>is_durable</td>
<td>是否持久化,把该属性设置为1，quartz会把job持久化到数据库中</td>
</tr>
<tr>
<td>is_nonconcurrent</td>
<td>是否并发</td>
</tr>
<tr>
<td>is_update_data</td>
<td>是否更新数据</td>
</tr>
<tr>
<td>requests_recovery</td>
<td>是否接受恢复执行，默认为false，设置了RequestsRecovery为true，则该job会被重新执行</td>
</tr>
<tr>
<td>job_data</td>
<td>一个blob字段，存放持久化job对象</td>
</tr>
</tbody>
</table>
<h5 id="2-qrtz-triggers：-保存触发器的基本信息"><a href="#2-qrtz-triggers：-保存触发器的基本信息" class="headerlink" title="2. qrtz_triggers： 保存触发器的基本信息"></a>2. qrtz_triggers： 保存触发器的基本信息</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>trigger_name</td>
<td>触发器的名字,该名字用户自己可以随意定制,无强行要求</td>
</tr>
<tr>
<td>trigger_group</td>
<td>触发器所属组的名字,该名字用户自己随意定制,无强行要求</td>
</tr>
<tr>
<td>job_name</td>
<td>qrtz_job_details表job_name的外键</td>
</tr>
<tr>
<td>job_group</td>
<td>qrtz_job_details表job_group的外键</td>
</tr>
<tr>
<td>description</td>
<td>相关介绍</td>
</tr>
<tr>
<td>next_fire_time</td>
<td>上一次触发时间（毫秒）</td>
</tr>
<tr>
<td>prev_fire_time</td>
<td>下一次触发时间，默认为-1，意味不会自动触发</td>
</tr>
<tr>
<td>priority</td>
<td>优先级</td>
</tr>
<tr>
<td>trigger_state</td>
<td>当前触发器状态，设置为ACQUIRED,如果设置为WAITING,则job不会触发</td>
</tr>
<tr>
<td>trigger_type</td>
<td>触发器的类型，使用cron表达式</td>
</tr>
<tr>
<td>start_time</td>
<td>开始时间</td>
</tr>
<tr>
<td>end_time</td>
<td>结束时间</td>
</tr>
<tr>
<td>calendar_name</td>
<td>日程表名称，表qrtz_calendars的calendar_name字段外键</td>
</tr>
<tr>
<td>misfire_instr</td>
<td>措施或者是补偿执行的策略</td>
</tr>
<tr>
<td>job_data</td>
<td>一个blob字段，存放持久化job对象</td>
</tr>
</tbody>
</table>
<h5 id="3-qrtz-cron-triggers：存储触发器的cron表达式表。"><a href="#3-qrtz-cron-triggers：存储触发器的cron表达式表。" class="headerlink" title="3. qrtz_cron_triggers：存储触发器的cron表达式表。"></a>3. qrtz_cron_triggers：存储触发器的cron表达式表。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>trigger_name</td>
<td>qrtz_triggers表trigger_name的外键</td>
</tr>
<tr>
<td>trigger_group</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
<tr>
<td>cron_expression</td>
<td>cron表达式</td>
</tr>
<tr>
<td>time_zone_id</td>
<td>时区</td>
</tr>
</tbody>
</table>
<h5 id="4-qrtz-scheduler-state：存储集群中note实例信息，quartz会定时读取该表的信息判断集群中每个实例的当前状态。"><a href="#4-qrtz-scheduler-state：存储集群中note实例信息，quartz会定时读取该表的信息判断集群中每个实例的当前状态。" class="headerlink" title="4. qrtz_scheduler_state：存储集群中note实例信息，quartz会定时读取该表的信息判断集群中每个实例的当前状态。"></a>4. qrtz_scheduler_state：存储集群中note实例信息，quartz会定时读取该表的信息判断集群中每个实例的当前状态。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>instance_name</td>
<td>之前配置文件中org.quartz.scheduler.instanceId配置的名字，就会写入该字段</td>
<td>，如果设置为AUTO,quartz会根据物理机名和当前时间产生一个名字</td>
</tr>
<tr>
<td>last_checkin_time</td>
<td>上次检查时间</td>
</tr>
<tr>
<td>checkin_interval</td>
<td>检查间隔时间</td>
</tr>
</tbody>
</table>
<h5 id="5-qrtz-blob-triggers：Trigger-作为-Blob-类型存储-用于-Quartz-用户用-JDBC-创建他们自己定制的-Trigger-类型，JobStore-并不知道如何存储实例的时候"><a href="#5-qrtz-blob-triggers：Trigger-作为-Blob-类型存储-用于-Quartz-用户用-JDBC-创建他们自己定制的-Trigger-类型，JobStore-并不知道如何存储实例的时候" class="headerlink" title="5. qrtz_blob_triggers：Trigger 作为 Blob 类型存储(用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，JobStore 并不知道如何存储实例的时候)"></a>5. qrtz_blob_triggers：Trigger 作为 Blob 类型存储(用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，JobStore 并不知道如何存储实例的时候)</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>trigger_name</td>
<td>qrtz_triggers表trigger_name的外键</td>
</tr>
<tr>
<td>trigger_group</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
<tr>
<td>blob_data</td>
<td>一个blob字段，存放持久化Trigger对象</td>
</tr>
</tbody>
</table>
<h5 id="6-qrtz-calendars：以-Blob-类型存储存放日历信息，-quartz可配置一个日历来指定一个时间范围。"><a href="#6-qrtz-calendars：以-Blob-类型存储存放日历信息，-quartz可配置一个日历来指定一个时间范围。" class="headerlink" title="6. qrtz_calendars：以 Blob 类型存储存放日历信息， quartz可配置一个日历来指定一个时间范围。"></a>6. qrtz_calendars：以 Blob 类型存储存放日历信息， quartz可配置一个日历来指定一个时间范围。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>calendar_name</td>
<td>日历名称</td>
</tr>
<tr>
<td>calendar</td>
<td>一个blob字段，存放持久化calendar对象</td>
</tr>
</tbody>
</table>
<h5 id="7-qrtz-fired-triggers：存储与已触发的-Trigger-相关的状态信息，以及相联-Job-的执行信息。"><a href="#7-qrtz-fired-triggers：存储与已触发的-Trigger-相关的状态信息，以及相联-Job-的执行信息。" class="headerlink" title="7. qrtz_fired_triggers：存储与已触发的 Trigger 相关的状态信息，以及相联 Job 的执行信息。"></a>7. qrtz_fired_triggers：存储与已触发的 Trigger 相关的状态信息，以及相联 Job 的执行信息。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>entry_id</td>
<td>调度器实例id</td>
</tr>
<tr>
<td>trigger_name</td>
<td>qrtz_triggers表trigger_name的外键</td>
</tr>
<tr>
<td>trigger_group</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
<tr>
<td>instance_name</td>
<td>调度器实例名</td>
</tr>
<tr>
<td>fired_time</td>
<td>触发的时间</td>
</tr>
<tr>
<td>sched_time</td>
<td>定时器制定的时间</td>
</tr>
<tr>
<td>priority</td>
<td>优先级</td>
</tr>
<tr>
<td>state</td>
<td>状态</td>
</tr>
<tr>
<td>job_name</td>
<td>集群中job的名字,该名字用户自己可以随意定制,无强行要求</td>
</tr>
<tr>
<td>job_group</td>
<td>集群中job的所属组的名字,该名字用户自己随意定制,无强行要求 </td>
</tr>
<tr>
<td>is_nonconcurrent</td>
<td>是否并发</td>
</tr>
<tr>
<td>requests_recovery</td>
<td>是否接受恢复执行，默认为false，设置了RequestsRecovery为true，则会被重新执行</td>
</tr>
</tbody>
</table>
<h5 id="8-qrtz-locks：存储程序的悲观锁的信息-假如使用了悲观锁-。"><a href="#8-qrtz-locks：存储程序的悲观锁的信息-假如使用了悲观锁-。" class="headerlink" title="8. qrtz_locks：存储程序的悲观锁的信息(假如使用了悲观锁)。"></a>8. qrtz_locks：存储程序的悲观锁的信息(假如使用了悲观锁)。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>lock_name</td>
<td>悲观锁名称</td>
</tr>
</tbody>
</table>
<h5 id="9-qrtz-paused-trigger-grps：存储已暂停的-Trigger-组的信息。"><a href="#9-qrtz-paused-trigger-grps：存储已暂停的-Trigger-组的信息。" class="headerlink" title="9. qrtz_paused_trigger_grps：存储已暂停的 Trigger 组的信息。"></a>9. qrtz_paused_trigger_grps：存储已暂停的 Trigger 组的信息。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>trigger_group</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
</tbody>
</table>
<h5 id="10-qrtz-paused-trigger-grps：存储已暂停的-Trigger-组的信息。"><a href="#10-qrtz-paused-trigger-grps：存储已暂停的-Trigger-组的信息。" class="headerlink" title="10. qrtz_paused_trigger_grps：存储已暂停的 Trigger 组的信息。"></a>10. qrtz_paused_trigger_grps：存储已暂停的 Trigger 组的信息。</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sched_name</td>
<td>调度名称</td>
</tr>
<tr>
<td>trigger_group</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
</tbody>
</table>
<h5 id="11-qrtz-simple-triggers：存储简单的-Trigger，包括重复次数，间隔，以及已触发的次数。"><a href="#11-qrtz-simple-triggers：存储简单的-Trigger，包括重复次数，间隔，以及已触发的次数。" class="headerlink" title="11. qrtz_simple_triggers：存储简单的 Trigger，包括重复次数，间隔，以及已触发的次数。"></a>11. qrtz_simple_triggers：存储简单的 Trigger，包括重复次数，间隔，以及已触发的次数。</h5><table>
<thead>
<tr>
<th>sched_name</th>
<th>调度名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>trigger_name</td>
<td>qrtz<em>triggers表trigger</em> name的外键</td>
</tr>
<tr>
<td>trigger_group</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
<tr>
<td>repeat_count</td>
<td>重复的次数统计</td>
</tr>
<tr>
<td>repeat_interval</td>
<td>重复的间隔时间</td>
</tr>
<tr>
<td>times_triggered</td>
<td>已经触发的次数</td>
</tr>
</tbody>
</table>
<h5 id="12-qrtz-simprop-triggers：存储CalendarIntervalTrigger和DailyTimeIntervalTrigger"><a href="#12-qrtz-simprop-triggers：存储CalendarIntervalTrigger和DailyTimeIntervalTrigger" class="headerlink" title="12. qrtz_simprop_triggers：存储CalendarIntervalTrigger和DailyTimeIntervalTrigger"></a>12. qrtz_simprop_triggers：存储CalendarIntervalTrigger和DailyTimeIntervalTrigger</h5><table>
<thead>
<tr>
<th>表字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCHED_NAME</td>
<td>调度名称</td>
</tr>
<tr>
<td>TRIGGER_NAME</td>
<td>qrtz<em>triggers表trigger</em> name的外键</td>
</tr>
<tr>
<td>TRIGGER_GROUP</td>
<td>qrtz_triggers表trigger_group的外键</td>
</tr>
<tr>
<td>STR_PROP_1</td>
<td>String类型的trigger的第一个参数</td>
</tr>
<tr>
<td>STR_PROP_2</td>
<td>String类型的trigger的第二个参数</td>
</tr>
<tr>
<td>STR_PROP_3</td>
<td>String类型的trigger的第三个参数</td>
</tr>
<tr>
<td>INT_PROP_1</td>
<td>int类型的trigger的第一个参数</td>
</tr>
<tr>
<td>INT_PROP_2</td>
<td>int类型的trigger的第二个参数</td>
</tr>
<tr>
<td>LONG_PROP_1</td>
<td>long类型的trigger的第一个参数</td>
</tr>
<tr>
<td>LONG_PROP_2</td>
<td>long类型的trigger的第二个参数</td>
</tr>
<tr>
<td>DEC_PROP_1</td>
<td>decimal类型的trigger的第一个参数</td>
</tr>
<tr>
<td>DEC_PROP_2</td>
<td>decimal类型的trigger的第二个参数</td>
</tr>
<tr>
<td>BOOL_PROP_1</td>
<td>Boolean类型的trigger的第一个参数</td>
</tr>
<tr>
<td>BOOL_PROP_2</td>
<td>Boolean类型的trigger的第二个参数</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-qrtz-job-details：存储每一个已配置的-jobDetail-的详细信息&quot;&gt;&lt;a href=&quot;#1-qrtz-job-details：存储每一个已配置的-jobDetail-的详细信息&quot; class=&quot;headerlink&quot; title=&quot;1. q
    
    </summary>
    
    
      <category term="Quartz 分布式任务" scheme="//zeroto.tech/tags/Quartz-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Quartz Best Practices</title>
    <link href="//zeroto.tech/2018/06/20/Quartz%20Best%20Practices/"/>
    <id>//zeroto.tech/2018/06/20/Quartz Best Practices/</id>
    <published>2018-06-20T08:28:15.000Z</published>
    <updated>2018-08-02T07:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul>
<li>Production System Tips</li>
<li>JobDataMap Tips</li>
<li>Trigger Tips</li>
<li>JDBC JobStore</li>
<li>Daylight Savings Time</li>
<li>Jobs</li>
<li>Listeners (TriggerListener, JobListener, SchedulerListener</li>
<li>Exposing Scheduler Functionality Through Applications</li>
</ul>
<a id="more"></a>
<h2 id="生产环境中的建议"><a href="#生产环境中的建议" class="headerlink" title="生产环境中的建议"></a>生产环境中的建议</h2><p><strong>跳过检查更新</strong><br>通过配置 “org.quartz.scheduler.skipUpdateCheck: true” 属性，你能够取消检查更新。</p>
<h2 id="JobDataMap-建议"><a href="#JobDataMap-建议" class="headerlink" title="JobDataMap 建议"></a>JobDataMap 建议</h2><p><strong>Only Store Primitive Data Types (including Strings) In the JobDataMap，避免序列化问题</strong></p>
<p><strong>Use the Merged JobDataMap</strong><br>在任务执行的时候，JobExecutionContext中的JobDataMap作为一个convenience。它是通过在JobDetail中的JobDataMap和Trigger中的JobDataMap合并而来，后者中的值会覆盖前面一个中同名变量的值。</p>
<p>当你有一个任务在scheduler中，而且这个任务又会被多个Triggers重复使用，那么你最好把值存在Trigger的JobDataMap中，这样对于每次独立的任务触发时，你就可以为Job提供不同的数据输入啦。</p>
<p>根据以上所述，我们提出了如下的最佳实践：在调用Job.execute(…)方法时，一般来说应该从JobExecutionContext中的JobDataMap中解析变量的值，而不是直接从JobDetail的JobDataMap中解析。</p>
<h2 id="Trigger-建议"><a href="#Trigger-建议" class="headerlink" title="Trigger 建议"></a>Trigger 建议</h2><p><strong>Use TriggerUtils</strong></p>
<ul>
<li>提供了一个简单的方法来创建triggers（schedules）</li>
<li>有很多不同的方法通过schedules来创建triggers以满足特定的描述，这个要比直接实例化特定类型的triggers（SimpleTrigger，CronTrigger等）然后调用不同的setter方法来配置它们方便许多</li>
<li>提供了一个简单的方法来创建日期（比如start/end日期）</li>
<li>提供了分析triggers的助手（e.g. calculating future fire times）</li>
</ul>
<h2 id="JDBC-JobStore"><a href="#JDBC-JobStore" class="headerlink" title="JDBC JobStore"></a>JDBC JobStore</h2><p><strong>永远都不要直接往Quartz的表中写数据</strong><br>Writing scheduling data directly to the database (via SQL) rather than using scheduling API:<br><strong>永远不要在同一个Database将一个Non-Clustered Scheduler 指向另一个相同名字的Scheduler Name</strong><br>If you point more than one scheduler instance at the same set of database tables, and one or more of those instances is not configured for clustering, any of the following may occur:</p>
<ul>
<li>会造成数据腐化（被删除的数据，混乱的数据）</li>
<li>会造成任务在到达执行点的时候像没有执行就消失了</li>
<li>会造成当触发时间到来时，而任务还未执行</li>
<li>可能会造成死锁</li>
</ul>
<p><strong>Ensure Adequate Datasource Connection Size</strong><br>建议将你的数据源连接数配置为配置为线程池中工作线程数加3。如果你的应用还要经常调用scheduler的API，那么你还需要增加额外的connections。If you are using JobStoreCMT, the “non managed” datasource should have a max connection size of at least four.</p>
<h2 id="Daylight-Savings-Time"><a href="#Daylight-Savings-Time" class="headerlink" title="Daylight Savings Time"></a>Daylight Savings Time</h2><p><strong>Avoid Scheduling Jobs Near the Transition Hours of Daylight Savings Time</strong><br>注意：本地的时钟向前或者向后转移时和总的时间的细节可以在如下链接中找到：<br><a href="https://en.wikipedia.org/wiki/Daylight_saving_time_by_country" target="_blank" rel="external">https://en.wikipedia.org/wiki/Daylight_saving_time_by_country</a>.</p>
<p>SimpleTriggers不受夏令时的影响，这是因为它们总是在毫秒时刻被精确地触发，并且在进过了精确的毫秒数之后会再次被触发。</p>
<p>由于CronTriggers会在给定的时/分/秒被触发，当夏令时转移时到来的时候，它们会受到这些怪事的影响。</p>
<p>举一个可能发生的例子，在夏令时的美国时区/位置进行调度的时候，如果使用CronTrigger并且调度的触发时间是在1:00 AM和2:00 AM之间时会发生下列的问题：</p>
<ul>
<li>1:05 AM may occur twice! - duplicate firings on CronTrigger possible</li>
<li>2:05 AM may never occur! - missed firings on CronTrigger possible</li>
</ul>
<p>Again, specifics of time and amount of adjustment varies by locale.</p>
<p>其他的触发器类型是根据日历的移动而不是根据确切的时间量来进行的，例如CalenderIntervalTrigger，将会同样地受影响，但不是错过触发或者触发两次，而是将它的触发时间偏移一个小时。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p><strong>等待条件来到</strong><br>长时间运行的任务会阻止其他任务的运行（如果在线程池中所有的线程都繁忙）。</p>
<p>如果你认为需要调用 Thread.sleep() 这个方法来停止工作线程执行任务，这是一个典型的信号，任务不会完成其余的任务，因它必须等待某些条件的到来（比如某些数据可读）。</p>
<p>一个更好的方法是释放线程 (exit the job) 并且允许其他任务在这个线程执行。任务可以重新调度自己，或者在它退出之前其他任务。</p>
<p><strong>抛出异常</strong><br>一个任务的执行方法应该包含在try-catch块中，以此处理可能发生的异常。</p>
<p>如果一个任务抛出一个异常，Quartz一般会马上再执行它（可能会抛出相同的异常）。最好是任务捕获所有它可能遇到的异常并处理它们，然后重新调度自己或其他的任务。</p>
<p><strong>可恢复性和幂等性</strong><br>In-progress Jobs marked “recoverable” are automatically re-executed after a scheduler fails. This means some of the job’s “work” will be executed twice.</p>
<p>This means the job should be coded in such a way that its work is idempotent.</p>
<h2 id="监听器（TriggerListener-JobListener-SchedulerListener）"><a href="#监听器（TriggerListener-JobListener-SchedulerListener）" class="headerlink" title="监听器（TriggerListener, JobListener, SchedulerListener）"></a>监听器（TriggerListener, JobListener, SchedulerListener）</h2><p><strong>Keep Code In Listeners Concise And Efficient</strong><br>Keep Code In Listeners Concise And Efficient<br>Performing large amounts of work is discouraged, as the thread that would be executing the job (or completing the trigger and moving on to firing another job, etc.) will be tied up within the listener.</p>
<p><strong>处理异常</strong><br>每个监听器的方法都应该在try-catch块中处理所有可能的异常。</p>
<p>如果一个监听器抛出了一个异常，可能会造成其他的监听器无法被通知到或阻止其他任务的执行等。</p>
<h2 id="通过应用来暴露调度器的功能"><a href="#通过应用来暴露调度器的功能" class="headerlink" title="通过应用来暴露调度器的功能"></a>通过应用来暴露调度器的功能</h2><p><strong>Be Careful of Security!</strong><br>有的用户通过应用程序接口来暴露Quartz的调度功能。这会非常有用，虽它可能会造成极度的危险。</p>
<p>确保你没有错误地允许用户定义他们想要的任何参数和任何类型的任务。例如，Quartz会带有一个预定的任务org.quartz.jobs.NativeJob，这个任务将会在它们定义的任意的本地系统上执行命令。恶意的用户可能会使用这个来控制或者摧毁你的系统。</p>
<p>同样的像 SendEmailJob 之类的任务，并且事实上任何其他的任务都可以被当作恶意用途。</p>
<p>如果允许用户定义任意他们想要的任务将会是你的系统遭受各种可能的危害，等同于 OWASP 和 MITRE 定义的命令注入攻击等。</p>
<h1 id="参考在此："><a href="#参考在此：" class="headerlink" title="参考在此："></a>参考在此：</h1><p><a href="http://www.quartz-scheduler.org/documentation/best-practices.html" target="_blank" rel="external">Quartz Best Practices(http://www.quartz-scheduler.org/documentation/best-practices.html)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最佳实践&quot;&gt;&lt;a href=&quot;#最佳实践&quot; class=&quot;headerlink&quot; title=&quot;最佳实践&quot;&gt;&lt;/a&gt;最佳实践&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Production System Tips&lt;/li&gt;
&lt;li&gt;JobDataMap Tips&lt;/li&gt;
&lt;li&gt;Trigger Tips&lt;/li&gt;
&lt;li&gt;JDBC JobStore&lt;/li&gt;
&lt;li&gt;Daylight Savings Time&lt;/li&gt;
&lt;li&gt;Jobs&lt;/li&gt;
&lt;li&gt;Listeners (TriggerListener, JobListener, SchedulerListener&lt;/li&gt;
&lt;li&gt;Exposing Scheduler Functionality Through Applications&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Quartz" scheme="//zeroto.tech/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>网线接口转换器 苹果Mac集线器HUB接硬盘</title>
    <link href="//zeroto.tech/2018/06/05/Mac%20%E7%BD%91%E7%BA%BF%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>//zeroto.tech/2018/06/05/Mac 网线接口转换器的正确使用方法/</id>
    <published>2018-06-05T09:38:55.000Z</published>
    <updated>2018-06-05T09:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac-连接网线"><a href="#Mac-连接网线" class="headerlink" title="Mac 连接网线"></a>Mac 连接网线</h1><p>以我在京东上购买的 毕亚兹(biaze) USB分线器3.0 千兆有线网卡 USB转RJ45网线接口转换器 苹果Mac集线器HUB接硬盘 ZH17-金属银 为例：</p>
<pre><code class="sh">~ csrutil status
System Integrity Protection status: enabled (Custom Configuration).

Configuration:
    Apple Internal: disabled
    Kext Signing: enabled
    Filesystem Protections: enabled
    Debugging Restrictions: disabled
    DTrace Restrictions: enabled
    NVRAM Protections: enabled
    BaseSystem Verification: enabled

This is an unsupported configuration, likely to break in the future and leave your machine in an unknown state.
~
</code></pre>
<p>首先，SIP status 必须是 disabled 状态才行，可以通过以下步骤设置：<br>1、重启电脑<br>2、按住command+r进入恢复模式<br>3、点击顶部菜单栏实用工具中的终端，（可以输入csrutil status检查状态）<br>4、然后输入csrutil disable</p>
<p>其次，<a href="http://www.realtek.com/downloads/downloadsView.aspx?Langid=3&amp;PNid=56&amp;PFid=56&amp;Level=5&amp;Conn=4&amp;DownTypeID=3&amp;GetDown=false#7" target="_blank" rel="external">下载驱动</a>,选择 MAC OS 10.6 to 10.13 版本，下载安装。</p>
<p>最后，重启电脑。此时，关闭Wi-Fi 网络，试试网络吧。公司网络应该是用网线连接上了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac-连接网线&quot;&gt;&lt;a href=&quot;#Mac-连接网线&quot; class=&quot;headerlink&quot; title=&quot;Mac 连接网线&quot;&gt;&lt;/a&gt;Mac 连接网线&lt;/h1&gt;&lt;p&gt;以我在京东上购买的 毕亚兹(biaze) USB分线器3.0 千兆有线网卡 USB转RJ45
    
    </summary>
    
    
      <category term="Mac 网线接口转换器" scheme="//zeroto.tech/tags/Mac-%E7%BD%91%E7%BA%BF%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>亿级流量网站架构核心技术</title>
    <link href="//zeroto.tech/2018/05/14/%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>//zeroto.tech/2018/05/14/高可用与高并发/</id>
    <published>2018-05-14T08:01:27.000Z</published>
    <updated>2018-05-14T08:20:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跟开涛学搭建高可用高并发系统"><a href="#跟开涛学搭建高可用高并发系统" class="headerlink" title="跟开涛学搭建高可用高并发系统"></a>跟开涛学搭建高可用高并发系统</h1><p>本书将介绍缓存、异步并发、连接池、线程池、如何扩容、消息队列、分布式任务等高并发原则来提升系统吞吐量。</p>
<p>通过负载均衡和反向代理实现分流，通过限流 保护服务免受雪崩之灾，<br>通过降级实现部分可用、有损服务，通过隔离实现故障隔离，<br>通过设置合理的超时与重试机制避免请求堆积造成雪崩，通过回滚机制快速修复错误版本；<br>使得系统高可用。</p>
<a id="more"></a>
<p><img src="/assets/blogImg/高可用.png" alt="高可用"></p>
<p><img src="/assets/blogImg/高并发.png" alt="高并发"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;跟开涛学搭建高可用高并发系统&quot;&gt;&lt;a href=&quot;#跟开涛学搭建高可用高并发系统&quot; class=&quot;headerlink&quot; title=&quot;跟开涛学搭建高可用高并发系统&quot;&gt;&lt;/a&gt;跟开涛学搭建高可用高并发系统&lt;/h1&gt;&lt;p&gt;本书将介绍缓存、异步并发、连接池、线程池、如何扩容、消息队列、分布式任务等高并发原则来提升系统吞吐量。&lt;/p&gt;
&lt;p&gt;通过负载均衡和反向代理实现分流，通过限流 保护服务免受雪崩之灾，&lt;br&gt;通过降级实现部分可用、有损服务，通过隔离实现故障隔离，&lt;br&gt;通过设置合理的超时与重试机制避免请求堆积造成雪崩，通过回滚机制快速修复错误版本；&lt;br&gt;使得系统高可用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高可用" scheme="//zeroto.tech/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="高并发" scheme="//zeroto.tech/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>那些年我看过的书</title>
    <link href="//zeroto.tech/2018/03/14/recommend-books/"/>
    <id>//zeroto.tech/2018/03/14/recommend-books/</id>
    <published>2018-03-14T05:42:13.000Z</published>
    <updated>2018-06-22T01:12:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>2012年底正式参加工作，先后经历了三家单位（软通、必联（北京）电子商务、北京四合天地科技），有短有长（补充：2018-06入职互金行业了）。有的得到了经验，有的在那里得到了成长。不付青春吧。期间也认识了不少志同道合的好同事，有些也成为了好朋友。技术道路上还需披荆斩棘，更进一步。回首往事，才能更好的展望未来。</p>
<a id="more"></a>
<p><img src="/assets/blogImg/In-the-Grass.jpg" alt="In-the-Grass"></p>
<h2 id="技术书籍推荐（90-都是购买的书籍，偏爱）"><a href="#技术书籍推荐（90-都是购买的书籍，偏爱）" class="headerlink" title="技术书籍推荐（90%都是购买的书籍，偏爱）"></a>技术书籍推荐（90%都是购买的书籍，偏爱）</h2><p>有些是在京东上购买的书籍，有些是在异步社区上购买的，还有些就是<a href="http://tengj.top/" target="_blank" rel="external">嘟嘟独立博客</a>电子书互助计划得到的。<br>1、 《Java 核心技术》卷一 、卷二 两本书，算是入门比较好的书籍了<br>2、 <a href="https://legacy.gitbook.com/book/quanke/think-in-java/details" target="_blank" rel="external">Thinking in Java (Java 编程思想)</a>GitBook 可下载阅读。第13章没有编辑，Java的GUI现在应用少，正合我意。<br>3、 《Java 并发编程实战》<br>4、 《实战Java高并发程序设计》<br>5、 <a href="https://legacy.gitbook.com/@zhengyq" target="_blank" rel="external">Effective Java 中文版 第2版</a>GitBook 可下载阅读。算是 Java 的进阶书籍了，面试好多问题也是从这出来的<br>6、 《图解数据结构-使用Java》<br>7、 《Spring揭秘》<br>8、 《设计模式之禅（第2版）》<br>9、 《Redis实战》异步社区，购买的正版电子图书。超级清晰。在此推广一波<br>10、《MyBatis从入门到精通__刘增辉(著)》<br>11、《Android群英传：神兵利器》<br>12、《图解HTTP》对互联网基盘-HTTP协议进行了全面系统的介绍<br>13、《图解TCP/IP(第5版)》<br>14、《Spring Boot实战 ,丁雪丰 (译者) 》<br>15、《阿里巴巴Java开发手册（终极版）》</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>1、《数据结构与算法分析-Java语言描述 第3版》木有坚持读下来<br>2、《算法 第4版》木有坚持读下来<br>3、《程序员的数学1》<br>4、《程序员的数学2：概率统计》<br>5、《程序员的数学3：线性代数》</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>1、《大型网站技术架构：核心原理与案例分析》<br>2、《淘宝技术这十年》<br>3、《亿级流量网站架构核心技术(跟开涛学搭建高可用高并发系统)》<br>4、《深入分布式缓存：从原理到实践》<br>5、《Spring Cloud微服务实战》<br>6、《架构探险：轻量级微服务架构（上）》黄勇。由此加入了勇哥建立的微信群，大佬云集<br>7、《分布式服务框架原理与实践》<br>8、《Netty权威指南第二版》</p>
<h2 id="优秀博客推荐"><a href="#优秀博客推荐" class="headerlink" title="优秀博客推荐"></a>优秀博客推荐</h2><p>1、<a href="https://www.geekonomics10000.com/" target="_blank" rel="external">万维钢 用理工科思维理解世界</a><br>2、<a href="http://mindhacks.cn/" target="_blank" rel="external">刘未鹏</a><br>3、<a href="https://coolshell.cn/" target="_blank" rel="external">酷壳-陈皓</a><br>4、<a href="http://jinnianshilongnian.iteye.com/" target="_blank" rel="external">开涛的博客</a><br>5、<a href="http://cmsblogs.com/" target="_blank" rel="external">chenssy</a> Java并发编程实战</p>
<h2 id="人文书籍推荐"><a href="#人文书籍推荐" class="headerlink" title="人文书籍推荐"></a>人文书籍推荐</h2><p>1、《暗时间》 刘未鹏 | <a href="http://mindhacks.cn/" target="_blank" rel="external">Mind Hacks思维改变生活</a><br>2、《数学之美 （第二版）》吴军博士的，“数学之美”系列文章原刊载于谷歌黑板报<br>3、《浪潮之巅》同样也是吴军博士的<br>4、《三国机密》、《三国配角演义》马伯庸老爷子，有“文字鬼才”之誉<br>5、《北京折叠》<br>6、《人类简史》<br>7、《万万没想到：用理工科思维理解世界》万维钢<br>8、《黑客与画家》<br>9、《如何变得有意思：阮一峰博客文集》<br>10、《MacTalk 跨越边界》<br>11、《禅与摩托车维修艺术》</p>
<h2 id="商业、经济、财经"><a href="#商业、经济、财经" class="headerlink" title="商业、经济、财经"></a>商业、经济、财经</h2><p>1、《联盟：互联网时代的人才变革》参加了樊登读书会，因而知道的这本书<br>2、《重新定义公司：谷歌是如何运营的》<br>3、《罗辑思维 有种·有料·有趣》<br>4、《魔鬼经济学》也是罗辑思维视频节目了解到的，共四册；只读了前两册。<br>5、《从0到1开启商业与未来的秘密》<br>6、《怪诞行为学：可预测的非理性》<br>7、《怪诞行为学2：非理性的积极力量》<br>8、《三体：黑暗森林》<br>9、《我在碧桂园的1000天》电子版内部使用。以财务之眼看杨国强和他的地产王国。在碧桂园人称“三斌”之一吴建斌 著；</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Git ： 廖雪峰的 Git 教程<br>IDEA：<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="external">IntelliJ IDEA 简体中文专题教程</a><br>Maven：《Maven实战》</p>
<h2 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h2><p>1、《程序员修炼之道-从小工到专家》<br>2、《代码整洁之道》<br>3、《重构：改善既有代码的设计》<br>4、《软技能：代码之外的生存指南》 程序员除了写代码，还得懂点其他的软技能</p>
<h2 id="生活、其他"><a href="#生活、其他" class="headerlink" title="生活、其他"></a>生活、其他</h2><p>1、《悟空传》今何在。有这样一群人，他们宁肯死，也不肯输。<br>2、《煮酒探西游》吴闲云<br>3、《我不是潘金莲》刘震云的几乎都买来读过；12年、13年那两年很喜欢读他的书，一句顶一万句，温故一九四二、一地鸡毛、温故一九四二。<br>4、《人民的名义》影视剧开播前就已经读完了，电视剧还是追了。<br>5、《你我皆凡人》：从金庸武侠里读出来的现实江湖（六神磊磊处女作）。有微信大号“六神磊磊读金庸”，置顶公众号，粉丝支持所以买了这本书。<br>6、《为什么你总是害怕来不及》<br>7、《从你的全世界路过》张嘉佳<br>8、《儒林外史》、三言两拍；<br>9、《万历十五年》</p>
<h2 id="计划要看的电子书"><a href="#计划要看的电子书" class="headerlink" title="计划要看的电子书"></a>计划要看的电子书</h2><p>1、《编程之法：面试和算法心得_迷你书》<br>2、《架构即未来 现代企业可扩展的Web架构流程和组织原书第2版》<br>3、《一线架构师实践指南》<br>4、《O2O实战+他们是如何利用互联网的》<br>5、《实战Elasticsearch、Logstash、Kibana++分布式大数据搜索与日志挖掘及可视化解决方案》<br>6、《数据库查询优化器的艺术：原理解析与SQL性能优化》</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>个人认为，作为程序员不要吝啬对自己的投资，只有自己强大了才能更好的赚钱。每年都要买几本书投资一下，未来的回报会超出你的想象的，博主先准备把2017年买的书先看完先。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;2012年底正式参加工作，先后经历了三家单位（软通、必联（北京）电子商务、北京四合天地科技），有短有长（补充：2018-06入职互金行业了）。有的得到了经验，有的在那里得到了成长。不付青春吧。期间也认识了不少志同道合的好同事，有些也成为了好朋友。技术道路上还需披荆斩棘，更进一步。回首往事，才能更好的展望未来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="//zeroto.tech/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud构建微服务架构</title>
    <link href="//zeroto.tech/2018/03/07/Spring%20Boot%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>//zeroto.tech/2018/03/07/Spring Boot构建微服务/</id>
    <published>2018-03-07T06:45:37.000Z</published>
    <updated>2018-08-02T07:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接触Spring-Boot"><a href="#接触Spring-Boot" class="headerlink" title="接触Spring Boot"></a>接触Spring Boot</h1><p>2016年 Spring Boot 还没有被广泛使用，到了现在经过2年的发展，很多互联网公司已经将 Spring Boot 搬上了生产，而使用 Spring Boot 的开源项目在 Github/码云 上面已有不少，很有必要开启一波学习潮了。</p>
<p>听到了一句挺中肯的话，“离开场景和业务的修炼都是伪命题”。所以呢，有必要总结一下Spring Boot 相关的开源项目，选取一个感兴趣的，然后深入学习提交pr，真正的提高自己的技术能力。</p>
<a id="more"></a>
<h2 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h2><ul>
<li><a href="https://gitee.com/vmaps" target="_blank" rel="external">springcloud-app/dubbo-app</a></li>
<li><a href="http://springcloud.cn/view/337" target="_blank" rel="external">海信商业云平台的微服务落地实践</a>马映辉 群分享</li>
<li><a href="https://mp.weixin.qq.com/s/R4uUH0y-ZwoelLNnM4zYow" target="_blank" rel="external">如何把复杂单体应用快速迁移到微服务</a></li>
<li><a href="http://tengj.top/2017/04/24/springboot0/" target="_blank" rel="external">Spring Boot干货系列总纲</a></li>
<li><a href="https://www.bysocket.com/?page_id=1639" target="_blank" rel="external">Spring Boot 那些事</a></li>
<li><a href="http://blog.didispace.com/Spring-Boot基础教程/" target="_blank" rel="external">Spring Boot基础教程</a></li>
<li>[江南一点雨（Spring Cloud教程合集）]作者参考了程序猿DD（翟永超）一书《Spring Cloud微服务实战》，可用来作为辩证学习的素材。</li>
<li>[江南一点雨] <a href="https://github.com/lenve" target="_blank" rel="external">https://github.com/lenve</a></li>
<li><a href="http://xujin.org/" target="_blank" rel="external">沉思录</a> Spring Cloud中国社区创始人，业余主要研究Spring Cloud。我们微信群猪的博客，强力推荐。</li>
</ul>
<h2 id="有思想的博客站点"><a href="#有思想的博客站点" class="headerlink" title="有思想的博客站点"></a>有思想的博客站点</h2><ul>
<li><a href="https://my.oschina.net/huangyong" target="_blank" rel="external">黄勇</a> 群主，强力推荐。</li>
<li><a href="http://www.ityouknow.com/" target="_blank" rel="external">纯洁的微笑</a> 微笑大佬，我们【原创技术博客作者交流群】群主。</li>
<li><a href="http://blog.didispace.com/" target="_blank" rel="external">程序猿DD</a></li>
<li><a href="http://tengj.top/" target="_blank" rel="external">嘟嘟独立博客</a></li>
<li><a href="https://www.bysocket.com/" target="_blank" rel="external">泥瓦匠BYSocket</a></li>
<li><a href="https://blog.52itstyle.com/" target="_blank" rel="external">小柒2012</a></li>
<li><a href="http://www.itmuch.com/" target="_blank" rel="external">周立</a></li>
<li><a href="https://juejin.im/user/56fe494539b0570054f2e032" target="_blank" rel="external">Aresn</a> iView 主力开发者</li>
<li><a href="https://juejin.im/post/591aa14f570c35006961acac" target="_blank" rel="external">花裤衩（手摸手，带你用vue撸后台）</a></li>
<li><a href="http://www.itdiffer.com/" target="_blank" rel="external">老齐</a></li>
<li><a href="http://goileo.top/#blog" target="_blank" rel="external">Goileo Lee</a></li>
<li><a href="http://binux.cn/" target="_blank" rel="external">许彬</a></li>
<li><a href="http://stormzhang.com/" target="_blank" rel="external">stormzhang</a></li>
<li><a href="http://shiyanjun.cn/" target="_blank" rel="external">简单之美</a></li>
<li><a href="https://gitee.com/sunlightcs" target="_blank" rel="external">独孤求胜</a></li>
<li><a href="http://blog.mayongfa.cn/" target="_blank" rel="external">马勇发</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a></li>
<li><a href="https://jianshiapp.com/circles/1209" target="_blank" rel="external">见识（web前端）</a></li>
<li><a href="https://monkeysayhi.github.io/" target="_blank" rel="external">猴子007</a></li>
<li><a href="http://litten.me/" target="_blank" rel="external">Litten</a></li>
<li><a href="http://imweb.io/" target="_blank" rel="external">IMWeb前端博客</a></li>
<li><a href="https://github.com/Blankj/awesome-java-leetcode" target="_blank" rel="external">Blankj</a> 有个非常知名的 awesome-java-leetcode</li>
<li><a href="https://blankj.com/" target="_blank" rel="external">https://blankj.com/</a></li>
<li><a href="http://guolin.tech" target="_blank" rel="external">郭霖</a></li>
<li><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="external">张鸿洋</a></li>
<li><a href="http://www.wanandroid.com/" target="_blank" rel="external">http://www.wanandroid.com/</a> 张鸿洋运营</li>
<li><a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external">eclipse_xu</a> 《Android群英传：神兵利器》,买了读过。有意思的人儿</li>
<li><a href="http://lawlite.me/" target="_blank" rel="external">Lawlite</a></li>
<li><a href="http://www.54tianzhisheng.cn/" target="_blank" rel="external">zhisheng</a></li>
<li><a href="http://jumpbyte.cn/" target="_blank" rel="external">JumpByte</a></li>
<li><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="external">结构之法 算法之道</a></li>
<li><a href="https://coolshell.cn/" target="_blank" rel="external">酷壳-陈皓</a></li>
<li><a href="http://calvin1978.blogcn.com/" target="_blank" rel="external">江南白衣 </a> 老司机</li>
<li><a href="http://www.iocoder.cn/?vip" target="_blank" rel="external">芋道源码的博客</a> 文斌兄的地盘，另外也有知识星球，可以加入我们。</li>
<li><a href="http://lovestblog.cn/" target="_blank" rel="external">你假笨@JVM</a></li>
<li><a href="https://blog.iwannarun.cn/" target="_blank" rel="external">I WANNA RUN</a></li>
<li><a href="http://moxfive.xyz/" target="_blank" rel="external">MOxFIVE</a> Yelee主题开发者，很美观。</li>
<li><a href="http://www.youmeek.com/" target="_blank" rel="external">YouMeek</a></li>
</ul>
<h3 id="终极搜寻"><a href="#终极搜寻" class="headerlink" title="终极搜寻"></a>终极搜寻</h3><ul>
<li><a href="http://springcloud.cn/" target="_blank" rel="external">Spring Cloud中国社区</a></li>
<li><a href="http://www.spring4all.com/" target="_blank" rel="external">http://www.spring4all.com/</a></li>
<li><a href="http://springboot.fun/" target="_blank" rel="external">Spring Boot 中文索引</a></li>
<li><a href="http://www.ityouknow.com/springboot/2018/03/05/spring-boot-open-source.html" target="_blank" rel="external">Spring Boot 开源软件都有哪些？</a>  </li>
<li><a href="http://www.gitnavi.com/" target="_blank" rel="external">http://www.gitnavi.com/</a></li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>朋友圈里看到了一句话，觉得特别好：不善于总结的人，就是在吃老本，吃惯性，吃你的智商和知识。<br>所以呢建立博客，有的没的写一些技术、生活相关的东西，但愿不辜负青春，便想努力留下印记。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接触Spring-Boot&quot;&gt;&lt;a href=&quot;#接触Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;接触Spring Boot&quot;&gt;&lt;/a&gt;接触Spring Boot&lt;/h1&gt;&lt;p&gt;2016年 Spring Boot 还没有被广泛使用，到了现在经过2年的发展，很多互联网公司已经将 Spring Boot 搬上了生产，而使用 Spring Boot 的开源项目在 Github/码云 上面已有不少，很有必要开启一波学习潮了。&lt;/p&gt;
&lt;p&gt;听到了一句挺中肯的话，“离开场景和业务的修炼都是伪命题”。所以呢，有必要总结一下Spring Boot 相关的开源项目，选取一个感兴趣的，然后深入学习提交pr，真正的提高自己的技术能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="//zeroto.tech/tags/Spring-Boot/"/>
    
      <category term="Spring Cloud" scheme="//zeroto.tech/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Mac之神兵利器</title>
    <link href="//zeroto.tech/2018/03/05/Mac%E4%B9%8B%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    <id>//zeroto.tech/2018/03/05/Mac之神兵利器/</id>
    <published>2018-03-05T03:18:28.000Z</published>
    <updated>2018-03-12T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接触Mac"><a href="#接触Mac" class="headerlink" title="接触Mac"></a>接触Mac</h1><p>我是2016年底买的Mac，原因是在那时候通读了《MacTalk 跨越边界》、《MacTalk 人生元编程》这两本书，顿觉打开了一扇大门。随即宣告了我的联想Y570正式退役。<br>现如今Mac上的开发利器、效率工具也装了不少，也该是从资料库整理一下的时机了。</p>
<a id="more"></a>
<h2 id="搜集Mac"><a href="#搜集Mac" class="headerlink" title="搜集Mac"></a>搜集Mac</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/v8TqIVyuNW7zjyAFUYUMaA" target="_blank" rel="external">Mac使用 Alfred 提高你的工作效率</a></li>
<li><a href="http://macshuo.com/?p=625" target="_blank" rel="external">神兵利器——Alfred</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712591&amp;idx=1&amp;sn=96347db5cefd051aa94cc57a7b130519&amp;scene=38#wechat_redirect" target="_blank" rel="external">推荐几款我最喜爱的 Mac 软件（非技术）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712374&amp;idx=1&amp;sn=c85519d3e4730603811120c453cac7c6&amp;scene=38#wechat_redirect" target="_blank" rel="external">从 Mac OS 到 macOS，一个新的轮回</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=203870218&amp;idx=1&amp;sn=6865ca1a61508815934812eb8f4701df&amp;scene=38#wechat_redirect" target="_blank" rel="external">Mac 与 Windows 的虚妄之争</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=100342903&amp;idx=1&amp;sn=73f7fa339be9dc7dd5771aacca92f555&amp;scene=38#wechat_redirect" target="_blank" rel="external">程序员最常用的十个 Mac 工具（上）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=100345605&amp;idx=1&amp;sn=79712e26aece94936ed3273757c07e9e&amp;scene=38#wechat_redirect" target="_blank" rel="external">程序员最常用的十个 Mac 工具（中）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=100351098&amp;idx=1&amp;sn=6c67d2d78d331e90d4c9adbf2d9350cf&amp;scene=38#wechat_redirect" target="_blank" rel="external">程序员最常用的十个 Mac 工具（下）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=200805470&amp;idx=1&amp;sn=8e1aeac4238592291ba8135f95144613&amp;scene=38#wechat_redirect" target="_blank" rel="external">我在大学里学到的几件事</a></li>
<li><a href="https://www.waitsun.com/omnifocus-2-10.html" target="_blank" rel="external">OmniFocus 2 Pro for Mac 2.10 序号版 - 最优秀的GTD效率工具</a></li>
<li><a href="https://www.waitsun.com/parallels-desktop-13-2-0-43213.html" target="_blank" rel="external">Parallels Desktop 13 for Mac 13.2.0.43213 破解版 - Mac上最优秀的虚拟机</a></li>
<li><a href="http://www.ntfsformac.cn/" target="_blank" rel="external">Paragon NTFS for Mac</a>付费购买</li>
<li><a href="https://cleanmymac.com/" target="_blank" rel="external">CleanMyMac 3</a>付费购买</li>
<li><a href="https://contexts.co/" target="_blank" rel="external">Contexts 3</a>花钱购买的</li>
</ul>
<h2 id="有思想的读物"><a href="#有思想的读物" class="headerlink" title="有思想的读物"></a>有思想的读物</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/bbbsbxHoryLtTfEwulzUJg" target="_blank" rel="external">普通程序员能实现财务自由吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/AJSbHg1o7iYXy21TB1k48w" target="_blank" rel="external">罗永浩-酷玩实验室</a></li>
</ul>
<h3 id="终极搜寻"><a href="#终极搜寻" class="headerlink" title="终极搜寻"></a>终极搜寻</h3><ul>
<li><a href="https://www.waitsun.com/" target="_blank" rel="external">爱情守望者</a></li>
<li><a href="http://www.ifanr.com/" target="_blank" rel="external">爱范儿</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接触Mac&quot;&gt;&lt;a href=&quot;#接触Mac&quot; class=&quot;headerlink&quot; title=&quot;接触Mac&quot;&gt;&lt;/a&gt;接触Mac&lt;/h1&gt;&lt;p&gt;我是2016年底买的Mac，原因是在那时候通读了《MacTalk 跨越边界》、《MacTalk 人生元编程》这两本书，顿觉打开了一扇大门。随即宣告了我的联想Y570正式退役。&lt;br&gt;现如今Mac上的开发利器、效率工具也装了不少，也该是从资料库整理一下的时机了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="//zeroto.tech/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>区块链与比特币破冰</title>
    <link href="//zeroto.tech/2018/01/23/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%E7%A0%B4%E5%86%B0/"/>
    <id>//zeroto.tech/2018/01/23/区块链与比特币破冰/</id>
    <published>2018-01-23T02:57:30.000Z</published>
    <updated>2018-03-12T03:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大咖说"><a href="#大咖说" class="headerlink" title="大咖说"></a>大咖说</h1><p>池大大在<a href="https://goo.gl/a9KaZQ" target="_blank" rel="external">2018 年技术趋势预测</a>中写道：</p>
<blockquote>
<p>区块链是可以改变世界的发明。区块链源起比特币，但并不局限在币圈。区块链技术是储存、验证和数据保护等问题的实际解决办法。区块链可被视为分散的、极度安全的数据库。更专业一点来说，区块链是分布式的点对点的基于密码学的共享账本，可以在金融服务、保险、医疗、政府等领域内被广泛应用。2018年应该是区块链技术起飞并日趋成熟的一年。</p>
</blockquote>
<a id="more"></a>
<p>2018 年技术趋势预测 由于是在池建强 MacTalk 公众号上发布的文章，网址链接较长，这里用了<a href="https://goo.gl" target="_blank" rel="external">https://goo.gl</a> 做了short URL。<br>如果不能翻墙的话，还请前往微信阅读。</p>
<h2 id="疑惑不解"><a href="#疑惑不解" class="headerlink" title="疑惑不解"></a>疑惑不解</h2><p>面对比特币的疯涨诱惑，很多人按捺不住躁动：“虽然我买不起比特币，那还可以入手其它币吗？”</p>
<p>自从有人，就有投机的存在。但是人类历史上第一次有记载的大规模的投机事件是17世纪荷兰的郁金香泡沫。区块链存在泡沫吗？</p>
<p>还有 keso 描述的 <a href="https://mp.weixin.qq.com/s/seJEc29qyvfeodmLsfHDLQ" target="_blank" rel="external">区块链焦虑与错失恐惧症</a>。</p>
<p>好多问题都需要我们自己来判断、决定，前提是我们需要学习、多了解一些，不管从大势上面还是技术层面上！尽力避免成为吃瓜群众，“山寨币”的韭菜。</p>
<h2 id="了个究竟"><a href="#了个究竟" class="headerlink" title="了个究竟"></a>了个究竟</h2><p>一个浪头打过来，最好的办法是迎上去了解个究竟，而不是漠视，或者干脆当事情没有发生。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODIyMjAwMA==&amp;mid=2247484648&amp;idx=1&amp;sn=410c8c4769787916da418c7a6e64297a&amp;scene=21#wechat_redirect" target="_blank" rel="external">区块链有多火？</a> </li>
<li><a href="https://mp.weixin.qq.com/s/seJEc29qyvfeodmLsfHDLQ" target="_blank" rel="external">区块链焦虑与错失恐惧症</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ck_ObFrlMmk3A_Sww9Hc7A" target="_blank" rel="external">再不懂区块链，你就OUT了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/mv8EAny18zOI2gNlOHEIbQ" target="_blank" rel="external">比特币是如何被一群“囚犯”创造出来的</a></li>
<li><a href="https://mp.weixin.qq.com/s/v8HMMiWQuo36f0u_Id-79A" target="_blank" rel="external">九分钟了解区块链</a></li>
<li><a href="https://mp.weixin.qq.com/s/ucK4FIWiYlo8cgegW33TXQ" target="_blank" rel="external">迅雷出局：想靠“山寨币”致富的人，是时候醒来搬砖了</a></li>
<li><a href="https://mp.weixin.qq.com/s/_3QLtKxVLOwvzjlSprGKVQ" target="_blank" rel="external">不要试图挑战人性</a></li>
<li><a href="https://mp.weixin.qq.com/s/TvvRJPvAu_rSqmtYnkKAxQ" target="_blank" rel="external">一个足以颠覆微信、超越阿里的超级风口！40万亿大产业即将爆发！</a></li>
<li><a href="https://mp.weixin.qq.com/s/hDje9GjkZSRrG0IQFJf0kQ" target="_blank" rel="external">中国比特币矿机垄断全球：最被忽视的制造业样本</a></li>
<li><a href="https://mp.weixin.qq.com/s/qV9FaPdViRGkECTvPVkByA" target="_blank" rel="external">比特币和区块链(0)：骗局还是改变命运的科技</a></li>
<li><a href="https://mp.weixin.qq.com/s/2CIh42Kd_vuYQpjYtb0pdw" target="_blank" rel="external">比特币和区块链(1)：真钱，电子货币以及区块链</a></li>
<li><a href="https://mp.weixin.qq.com/s/fKlp5G5dBIX5YE56kgvDYw" target="_blank" rel="external">比特币和区块链(2)：比特币中区块链的实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/UOFvMNm0PaocIVKfHPheYA" target="_blank" rel="external">比特币和区块链(3)：比特币的共识机制</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI5OTM3MjMyNA==&amp;mid=2247484741&amp;idx=1&amp;sn=359815c5810b765573787eef7554098c&amp;chksm=ec96df0edbe15618953a1965750c1a2f005ccb22e7fe8d131eea5864ff7395a8166b90152f52&amp;scene=38#wechat_redirect" target="_blank" rel="external">比特币和区块链(4)：比特币成功的不可复制性</a></li>
</ul>
<p><strong>2018-01-25</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/N-W254NYs5M3x6XqomChAA" target="_blank" rel="external">我做比特币矿工这一年。</a></li>
</ul>
<p><strong>2018-02-02</strong></p>
<ul>
<li><a href="https://yq.aliyun.com/roundtable/64570?spm=a2c4e.11157919.spm-bestcontent.8.618eebf09PefFs" target="_blank" rel="external">互联网大佬谈区块链，看法爱憎分明</a></li>
<li><a href="https://mp.weixin.qq.com/s/8AtpRrFTljr1F46DUJ0m6w" target="_blank" rel="external">“币圈”暴富指南：致不愿醒来的韭菜们</a></li>
</ul>
<p><strong>2018-02-24</strong></p>
<ul>
<li><a href="http://www.huoxing24.com/#/newsdetail/2018022215253260956/4?tags=区块链,三点钟" target="_blank" rel="external">春节假期“三点钟”社群大佬激辩区块链2万字干货全记录，看这一篇足够了！</a></li>
</ul>
<p><strong>2018-03-02</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/-NYfLg-TR5MLboDaMvGoTg" target="_blank" rel="external">区块链性能提升：链上设计之道</a></li>
<li><a href="https://mp.weixin.qq.com/s/2fQif5HQHHZlN68alIfyBg" target="_blank" rel="external">韭菜席地而坐</a></li>
<li><a href="https://mp.weixin.qq.com/s/6Rj6BQLeGhC6iodszAthYQ" target="_blank" rel="external">2018年区块链落地的现状、阻碍与机遇 |捕手志</a></li>
<li><a href="https://mp.weixin.qq.com/s/SU3q2uMuuTWae7CDRGOkDA" target="_blank" rel="external">专访陈伟星：解密加密数字经济为何是未来 |捕手志</a></li>
<li><a href="https://mp.weixin.qq.com/s/qOQCMh4C2BmZsVExikl9FA" target="_blank" rel="external">周鸿祎：写区块链最好的一篇文章</a></li>
<li><a href="https://www.iyiou.com/p/66758?share_from=cb1f36a_M5U7ZZtZVA5x-tJy8Z4f1hU_qv5CjYKJtJiECv137ev_8zXmIQDW0ednSXt2RSfYQBZSBq9cRCrerJXqWF1ASxEMy-01iCIUUMrttysHA&amp;from=timeline" target="_blank" rel="external">黄渊普：关于区块链，那些骗子都知道自己是骗子</a></li>
</ul>
<p><strong>2018-03-06</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Y_DxSPyMnJWDQD6S0S1NYw" target="_blank" rel="external">ICO裹挟区块链强势重来</a></li>
<li><a href="https://mp.weixin.qq.com/s/7F2-eLqIdSiNIHHJDzkwcg" target="_blank" rel="external">深入研究的套路之黑客与区块链</a></li>
<li><a href="https://mp.weixin.qq.com/s/TbtpnHiZS8v1R_Udpun0xA" target="_blank" rel="external">5天钓到40枚以太币</a></li>
<li><a href="https://mp.weixin.qq.com/s/d_4gUc3Ay_He4fintNXw6Q" target="_blank" rel="external">杂谈区块链生态里的前端黑</a></li>
<li><a href="https://mp.weixin.qq.com/s/XK78b-qoPu5cu7rCPKXdEA" target="_blank" rel="external">区块链的十个吐槽</a></li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>2016年在接受《财经》杂志专访时，张一鸣说过的那段特别具有张一鸣色彩的话：</p>
<blockquote>
<p>历史上精英们一直在试图让大众拥有很高的精神追求，但社会整体从来没有达到过这个目标。以前的媒体精英意识不到这一点，他们认为自己特别希望导向的才是特别重要的。但多数人的强烈主张，从历史上看，多数都没有产生多大价值。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;大咖说&quot;&gt;&lt;a href=&quot;#大咖说&quot; class=&quot;headerlink&quot; title=&quot;大咖说&quot;&gt;&lt;/a&gt;大咖说&lt;/h1&gt;&lt;p&gt;池大大在&lt;a href=&quot;https://goo.gl/a9KaZQ&quot;&gt;2018 年技术趋势预测&lt;/a&gt;中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块链是可以改变世界的发明。区块链源起比特币，但并不局限在币圈。区块链技术是储存、验证和数据保护等问题的实际解决办法。区块链可被视为分散的、极度安全的数据库。更专业一点来说，区块链是分布式的点对点的基于密码学的共享账本，可以在金融服务、保险、医疗、政府等领域内被广泛应用。2018年应该是区块链技术起飞并日趋成熟的一年。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="//zeroto.tech/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="//zeroto.tech/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建个人网站</title>
    <link href="//zeroto.tech/2018/01/05/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <id>//zeroto.tech/2018/01/05/如何搭建个人网站/</id>
    <published>2018-01-05T06:57:16.000Z</published>
    <updated>2018-06-06T06:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>有了个人网站，可能就又多了一些学(zhuang)习(bi)的动力吧！<br>所以，拥有自己的网站，算是迈出了第一步！</p>
<p>好可惜最近才看到玉刚大神的文章，意识觉醒的晚了<a href="http://blog.csdn.net/singwhatiwanna/article/details/19174597" target="_blank" rel="external">树立个人品牌：让名企hr们主动来找你</a></p>
<a id="more"></a>
<h2 id="如何拥有自己的专属域名"><a href="#如何拥有自己的专属域名" class="headerlink" title="如何拥有自己的专属域名"></a>如何拥有自己的专属域名</h2><p>goileolee <a href="http://goileo.top/如何免费且快速的搭建个人网站" target="_blank" rel="external">http://goileo.top/如何免费且快速的搭建个人网站</a></p>
<h2 id="为-Github-Pages-绑定的自定义域名启用-HTTPS-协议"><a href="#为-Github-Pages-绑定的自定义域名启用-HTTPS-协议" class="headerlink" title="为 Github Pages 绑定的自定义域名启用 HTTPS 协议"></a>为 Github Pages 绑定的自定义域名启用 HTTPS 协议</h2><p><a href="https://zhouhao.me/2017/07/21/using-https-with-custom-domain-name-on-github-pages/" target="_blank" rel="external">https://zhouhao.me/2017/07/21/using-https-with-custom-domain-name-on-github-pages/</a></p>
<h2 id="hexo-yilia主题添加文章访问量统计"><a href="#hexo-yilia主题添加文章访问量统计" class="headerlink" title="hexo yilia主题添加文章访问量统计"></a>hexo yilia主题添加文章访问量统计</h2><p><a href="https://www.lookk.cn/2017/12/09/hexo-yilia主题添加文章访问量统计/" target="_blank" rel="external">https://www.lookk.cn/2017/12/09/hexo-yilia主题添加文章访问量统计/</a></p>
<h1 id="原因在结尾"><a href="#原因在结尾" class="headerlink" title="原因在结尾"></a>原因在结尾</h1><p><strong>在浏览器和访问的网站之间提供更安全的通讯</strong><br><strong>HTTPS 比 HTTP 的速度更快</strong><br><strong>能提高搜索引擎的优化排名</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;p&gt;有了个人网站，可能就又多了一些学(zhuang)习(bi)的动力吧！&lt;br&gt;所以，拥有自己的网站，算是迈出了第一步！&lt;/p&gt;
&lt;p&gt;好可惜最近才看到玉刚大神的文章，意识觉醒的晚了&lt;a href=&quot;http://blog.csdn.net/singwhatiwanna/article/details/19174597&quot;&gt;树立个人品牌：让名企hr们主动来找你&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="阿里云域名注册" scheme="//zeroto.tech/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C/"/>
    
      <category term="CloudFlare" scheme="//zeroto.tech/tags/CloudFlare/"/>
    
      <category term="HTTPS" scheme="//zeroto.tech/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>初探Visual Studio Code编写Vue</title>
    <link href="//zeroto.tech/2017/12/28/Visual%20Studio%20Code/"/>
    <id>//zeroto.tech/2017/12/28/Visual Studio Code/</id>
    <published>2017-12-28T08:12:15.000Z</published>
    <updated>2018-03-12T03:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用介绍"><a href="#应用介绍" class="headerlink" title="应用介绍"></a>应用介绍</h1><p><a href="https://code.visualstudio.com/" target="_blank" rel="external">https://code.visualstudio.com/</a><br>界面简洁大方，^_^</p>
<a id="more"></a>
<h1 id="Vue插件安装"><a href="#Vue插件安装" class="headerlink" title="Vue插件安装"></a>Vue插件安装</h1><p>在 VSCode Marketplace <a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="external">https://marketplace.visualstudio.com/vscode</a> 搜素Vue 出现关于语法高亮的插件有 Vue 2 Snippets，vue-beautify，vue-color，Vetur等等。花花绿绿的，往下翻看，目前使用率最高的就是Vetur了。<br>安装插件：⌘P 然后输入 ext install vetur 然后回车点安装即可。<br>但是如果你使用惯了Vim/Sublime/Atom等，VSCode允许安装自己的键盘快捷方式。<br><img src="VSCode-Sublime.png" alt="VSCode-Sublime"><br>我个人选择了Sublime，设置后并激活，这时按下<code>command+shift+p</code><br><img src="VSCode-Ext.png" alt="VSCode-Ext"><br>输入 Vetur<br><img src="VSCode-Vetur.png" alt="VSCode-Vetur"></p>
<h2 id="VS-Code-ESLint-extension"><a href="#VS-Code-ESLint-extension" class="headerlink" title="VS Code ESLint extension"></a>VS Code ESLint extension</h2><h3 id="安装插件和Vetur类似。"><a href="#安装插件和Vetur类似。" class="headerlink" title="安装插件和Vetur类似。"></a>安装插件和Vetur类似。</h3><p>ESLint 不是安装后就可以用的，还需要一些环境和配置：<br>eg：首先在自己的工作空间建立一个文件夹xmall-front，zsh中运行 <code>npm init</code><br>然后依次执行命令，快速体验下：</p>
<pre><code class="bash">
~/VSCodeProjects/xmall-front npm install --save-dev eslint eslint-plugin-html
npm notice created a lockfile as package-lock.json. You should commit this file.
npm WARN xmall-front@1.0.0 No repository field.

+ eslint-plugin-html@4.0.1
+ eslint@4.14.0
added 146 packages in 14.54s
~/VSCodeProjects/xmall-front ./node_modules/.bin/eslint --init
? How would you like to configure ESLint? Answer questions about your style
? Are you using ECMAScript 6 features? Yes
? Are you using ES6 modules? Yes
? Where will your code run? Browser
? Do you use CommonJS? Yes
? Do you use JSX? Yes
? Do you use React? No
? What style of indentation do you use? Tabs
? What quotes do you use for strings? Single
? What line endings do you use? Unix
? Do you require semicolons? No
? What format do you want your config file to be in? JavaScript
Successfully created .eslintrc.js file in /Users/jinkui/VSCodeProjects/xmall-front
~/VSCodeProjects/xmall-front la
.                 ..                .eslintrc.js      node_modules      package-lock.json package.json
</code></pre>
<h3 id="在-vscode-中配置下-ESLint："><a href="#在-vscode-中配置下-ESLint：" class="headerlink" title="在 vscode 中配置下 ESLint："></a>在 vscode 中配置下 ESLint：</h3><p>eslint.validate - an array of language identifiers specify the files to be validated. Something like “eslint.validate”: [ “javascript”, “javascriptreact”, “html” ]. If the setting is missing, it defaults to [“javascript”, “javascriptreact”].<br>查看扩展：ESLint 的Settings Options，发现确实默认不支持vue文件啊。<br>所以说虽然安装了eslint-plugin-html还是需要配置一下的：On a Mac, click Code &gt; Preferences &gt; Settings</p>
<pre><code class="json">
// An array of language ids which should be validated by ESLint
    &quot;eslint.validate&quot;: [
        &quot;javascript&quot;,
        &quot;javascriptreact&quot;,
        {
            &quot;language&quot;: &quot;html&quot;,
            &quot;autoFix&quot;: true
        },
        &quot;vue&quot;
    ]
</code></pre>
<h2 id="安装插件-提高效率"><a href="#安装插件-提高效率" class="headerlink" title="安装插件-提高效率"></a>安装插件-提高效率</h2><p>所有插件都类似于Sublime使用Package Control安装，按下快捷键<code>⌘⇧P</code>，在命令提示框搜索插件即可。</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager" target="_blank" rel="external">Project Manager</a> 在多个项目之前快速切换的工具</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippets" target="_blank" rel="external">HTML Snippets</a> Full HTML tags including HTML5 Snippets</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ecmel.vscode-html-css" target="_blank" rel="external">HTML CSS Support</a> 让 html 标签上写class 智能提示当前项目所支持的样式</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.jquerysnippets" target="_blank" rel="external">jQuery Code Snippets</a> Over 130 jQuery Code Snippets</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify" target="_blank" rel="external">Beautify</a> Beautify code in place for VS Code</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader" target="_blank" rel="external">vscode-fileheader</a> insert header comment,and automatically update the time.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="external">Bracket Pair Colorizer</a> 让括号拥有独立的颜色，易于区分。可以配合任意主题使用</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="external">Auto Close Tag</a> Automatically add HTML/XML close tag, same as Visual Studio IDE or Sublime Text does</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="external">Auto Rename Tag</a> Auto rename paired HTML/XML tag</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks" target="_blank" rel="external">Bookmarks</a> 添加行书签</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=SirTori.indenticator" target="_blank" rel="external">Indenticator</a> 缩进高亮</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode" target="_blank" rel="external">Quokka.js</a> 不需要手动运行，行内显示变量结果</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets" target="_blank" rel="external">JavaScript (ES6) code snippets</a> ES6语法代码段</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=sysoev.language-stylus" target="_blank" rel="external">language-stylus</a> Stylus语法高亮和提示</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=marclipovsky.string-manipulation" target="_blank" rel="external">String Manipulation</a> 字符串转换处理（驼峰、大写开头、下划线等等）</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=oysun.vuehelper" target="_blank" rel="external">VueHelper</a> Vue2代码段（包括Vue2 api、vue-router2、vuex2）</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=abierbaum.vscode-file-peek" target="_blank" rel="external">File Peek</a> The extension supports all the normal capabilities of symbol definition tracking, but does it for file names</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank" rel="external">Path Intellisense</a> Visual Studio Code plugin that autocompletes filenames</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=minhthai.vscode-todo-parser" target="_blank" rel="external">TODO Parser</a> Parse TODOs in your working files</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory" target="_blank" rel="external">Git History (git log)</a> View git log, file or line History</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank" rel="external">Git Lens</a> 显示文件最近的commit和作者，显示当前行commit信息</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=huizhou.githd" target="_blank" rel="external">Git History Diff</a> View git history. View commit details. View diff of committed files. Multi-root workspaces supported.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore" target="_blank" rel="external">gitignore</a> .gitignore文件语法</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=fknop.vscode-npm" target="_blank" rel="external">npm</a> npm commands for VSCode</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense" target="_blank" rel="external">npm Intellisense</a> 导入模块时，提示已安装模块名称</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=IBM.output-colorizer" target="_blank" rel="external">Output Colorizer</a> 彩色输出信息</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint" target="_blank" rel="external">markdownlint</a> Markdown linting and style checking for Visual Studio Code</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons" target="_blank" rel="external">vscode-icons</a> Icons for Visual Studio Code(大大的好啊)</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>见官网。<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf" target="_blank" rel="external">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf</a></p>
<h3 id="修改默认快捷键"><a href="#修改默认快捷键" class="headerlink" title="修改默认快捷键"></a>修改默认快捷键</h3><p>打开默认键盘快捷方式设置：</p>
<p>修改 keybindings.json：</p>
<pre><code class="json">
// 将键绑定放入此文件中以覆盖默认值
[
  // &#39;删除一行&#39;
  {
    &quot;key&quot;: &quot;cmd+d&quot;,
    &quot;command&quot;: &quot;editor.action.deleteLines&quot;,
    &quot;when&quot;: &quot;editorTextFocus &amp;&amp; !editorReadonly&quot;
  },
  // 与&#39;删除一行&#39;的快捷键互换
  {
    &quot;key&quot;: &quot;shift+cmd+k&quot;,
    &quot;command&quot;: &quot;editor.action.addSelectionToNextFindMatch&quot;,
    &quot;when&quot;: &quot;editorFocus&quot;
  },
  // 大小写转换快捷键，需安装 TextTransform 插件
  {
    &quot;key&quot;: &quot;cmd+shift+y&quot;,
    &quot;command&quot;: &quot;editor.action.transformToUppercase&quot;,
    &quot;when&quot;: &quot;editorTextFocus&quot;
  },
  {
    &quot;key&quot;: &quot;cmd+shift+x&quot;,
    &quot;command&quot;: &quot;editor.action.transformtolowercase&quot;,
    &quot;when&quot;: &quot;editorTextFocus&quot;
  }
]
</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>开启一波Vue学习潮，干后端的也不能落伍啊</p>
<p>参考在此：<br><a href="https://cloud.tencent.com/community/article/983896" target="_blank" rel="external">使用Visual Studio Code编写Vue的札记</a><br><a href="http://www.silianpan.club/2017/05/18/tool1/" target="_blank" rel="external">vs code &amp; Atom 对比使用心得</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;应用介绍&quot;&gt;&lt;a href=&quot;#应用介绍&quot; class=&quot;headerlink&quot; title=&quot;应用介绍&quot;&gt;&lt;/a&gt;应用介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;br&gt;界面简洁大方，^_^&lt;/p&gt;
    
    </summary>
    
    
      <category term="Visual Studio Code" scheme="//zeroto.tech/tags/Visual-Studio-Code/"/>
    
      <category term="Vue" scheme="//zeroto.tech/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Mac下之Sublime Text的好用之处</title>
    <link href="//zeroto.tech/2017/12/27/Sublime%20Text/"/>
    <id>//zeroto.tech/2017/12/27/Sublime Text/</id>
    <published>2017-12-27T06:01:44.000Z</published>
    <updated>2018-03-12T03:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用介绍"><a href="#应用介绍" class="headerlink" title="应用介绍"></a>应用介绍</h1><p>Sublime Text 拥有漂亮的用户界面和非凡的功能，而根据其官网介绍，Sublime Text的特点如下：拥有高效、没有干扰的界面，在编辑方面的多选、宏、代码片段等功能，以及很有特色的Minimap。<br>用户广受喜爱的众多功能之一GOTO ANYTHING<br>仅仅敲击几次键盘就能即刻jump to symbols, lines or words.<strong>Shortcuts:</strong>  <code>⌘ + P</code></p>
<a id="more"></a>
<p>要支持一把的官网购买啊<a href="http://www.sublimetext.com/" target="_blank" rel="external">http://www.sublimetext.com/</a>啊不花钱看这里：<a href="http://xclient.info/s/sublime-text.html?_=854c5c4c70359873adbd147e3e8c9cf3" target="_blank" rel="external">Sublime Text 3 Build 3156</a></p>
<h1 id="主题插件安装"><a href="#主题插件安装" class="headerlink" title="主题插件安装"></a>主题插件安装</h1><p><a href="http://buymeasoda.github.io/soda-theme/" target="_blank" rel="external">soda-theme</a>该插件主要能够使sublime 兼容mac的retina屏幕<br>我采用Git安装最新版本，可以通过菜单 Preferences -&gt; Browse Packages….，定位到你的Sublime Text Packages文件夹，然后在这个文件夹下面 git clone就OK了。</p>
<pre><code class="git">git clone https://github.com/buymeasoda/soda-theme/ &quot;Theme - Soda&quot;
</code></pre>
<p><strong> Configure Sublime Text 3 </strong></p>
<ul>
<li>打开配置文件： Sublime Text -&gt; Preferences -&gt; Settings - User</li>
<li>添加主题：”theme”: “Soda Light 3.sublime-theme”</li>
</ul>
<p>我自己的主题和字体配置：<br><img src="Sublime Text-color_scheme.png" alt="Sublime Text-color_scheme"></p>
<h1 id="插件与配置"><a href="#插件与配置" class="headerlink" title="插件与配置"></a>插件与配置</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>所有插件都可以使用Package Control安装，按下快捷键<code>⌘⇧P</code>，在命令提示框搜索插件即可。<br><a href="https://github.com/zhiqiang21/blog/issues/10" target="_blank" rel="external">前端开发 sublime text 常用插件和配置</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>⌘</td>
<td>command</td>
</tr>
<tr>
<td>⌃</td>
<td>control</td>
</tr>
<tr>
<td>⌥</td>
<td>option</td>
</tr>
<tr>
<td>⇧</td>
<td>shift</td>
</tr>
<tr>
<td>↩</td>
<td>enter</td>
</tr>
<tr>
<td> ⌫</td>
<td>delete</td>
</tr>
</tbody>
</table>
<p><strong>Shortcuts:</strong>  <code>⌘ + P</code> 即刻jump to symbols, lines or words.</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@</code></td>
<td>jump to symbols</td>
</tr>
<tr>
<td><code>#</code></td>
<td>查找文件内的单词</td>
</tr>
<tr>
<td><code>:</code></td>
<td>跳到行号处</td>
</tr>
</tbody>
</table>
<p>Preferences -&gt; Key Bindings,在-User文件里自定义快捷键（会覆盖相应的-Default配置）</p>
<h3 id="打开-关闭-前往"><a href="#打开-关闭-前往" class="headerlink" title="打开/关闭/前往"></a>打开/关闭/前往</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>⌘⇧N</td>
<td>打开一个新的sublime窗口</td>
</tr>
<tr>
<td>⌘N</td>
<td>新建文件</td>
</tr>
<tr>
<td>⌘⇧W</td>
<td>关闭sublime，关闭所有文件</td>
</tr>
<tr>
<td>⌘W</td>
<td>关闭当前文件</td>
</tr>
<tr>
<td>⌘P</td>
<td>GOTO ANYTHING</td>
</tr>
<tr>
<td>⌘⇧T</td>
<td>重新打开最近关闭的文件</td>
</tr>
<tr>
<td>⌘T</td>
<td>前往文件</td>
</tr>
<tr>
<td>⌘R</td>
<td>前往method</td>
</tr>
<tr>
<td>⌘⇧P</td>
<td>命令提示</td>
</tr>
<tr>
<td>⌃`</td>
<td>打开控制台</td>
</tr>
</tbody>
</table>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>⌘KK</td>
<td>从光标处删除至行尾</td>
</tr>
<tr>
<td>⌘⌫</td>
<td>从光标处删除至行首</td>
</tr>
<tr>
<td>⌘KV</td>
<td>paste_from_history</td>
</tr>
<tr>
<td>⌘L</td>
<td>Select line - Repeat to select next lines</td>
</tr>
<tr>
<td>⌘D</td>
<td>删除行(⌃⇧K)</td>
</tr>
<tr>
<td>⌘E</td>
<td>选择词（重复按下时多重选择相同的词进行多重编辑）(⌘D)</td>
</tr>
<tr>
<td>⌘J</td>
<td>选择行（重复按下将下一行加入选择）</td>
</tr>
<tr>
<td>⌘JL</td>
<td>Join line below to the end of the current line（⌘J）</td>
</tr>
<tr>
<td>⌃ + ⇧ + M</td>
<td>Select all contents of the current parentheses</td>
</tr>
<tr>
<td>⌃ + M</td>
<td>Jump to closing parentheses Repeat to jump to opening parentheses</td>
</tr>
<tr>
<td>⌘⇧↩</td>
<td>在当前行前插入新行</td>
</tr>
<tr>
<td>⌘↩</td>
<td>在当前行后插入新行</td>
</tr>
<tr>
<td>⌘+shift+y</td>
<td>改为大写（⌘KU）</td>
</tr>
<tr>
<td>⌘+shift+x</td>
<td>改为小写（⌘KL）</td>
</tr>
<tr>
<td>⌘C</td>
<td>复制</td>
</tr>
<tr>
<td>⌘X</td>
<td>剪切</td>
</tr>
<tr>
<td>⌘V</td>
<td>粘贴</td>
</tr>
<tr>
<td>⌘Z</td>
<td>撤销</td>
</tr>
<tr>
<td>⌘+shift+z</td>
<td>恢复撤销</td>
</tr>
<tr>
<td>⌘y</td>
<td>重做</td>
</tr>
<tr>
<td>⌘u</td>
<td>soft_undo</td>
</tr>
<tr>
<td>⌘⇧u</td>
<td>soft_redo</td>
</tr>
<tr>
<td>⌘/</td>
<td>注释</td>
</tr>
<tr>
<td>⌘]</td>
<td>向右缩进</td>
</tr>
<tr>
<td>⌘[</td>
<td>向左缩进</td>
</tr>
<tr>
<td>⌃ + ⇧ + ↑</td>
<td>一个或多行向上移动</td>
</tr>
<tr>
<td>⌃ + ⇧ + ↓</td>
<td>一个或多行向下移动</td>
</tr>
</tbody>
</table>
<h3 id="打开-关闭-前往-1"><a href="#打开-关闭-前往-1" class="headerlink" title="打开/关闭/前往"></a>打开/关闭/前往</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>⌘f</td>
<td>查找</td>
</tr>
<tr>
<td>⌘⌥f</td>
<td>查找并替换</td>
</tr>
<tr>
<td>⌘⌥g</td>
<td>查找下一个符合当前所选的内容</td>
</tr>
<tr>
<td>⌘⌃g</td>
<td>查找所有符合当前选择的内容进行多重编辑</td>
</tr>
<tr>
<td>⌘⇧F</td>
<td>在所有打开的文件中进行查找</td>
</tr>
<tr>
<td>⌘ + I</td>
<td>Incremental Find</td>
</tr>
</tbody>
</table>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Preferences -&gt; Key Bindings,在-User文件里自定义快捷键：</p>
<pre><code class="json">
[
    { &quot;keys&quot;: [&quot;super+shift+y&quot;], &quot;command&quot;: &quot;upper_case&quot; },
    { &quot;keys&quot;: [&quot;super+shift+x&quot;], &quot;command&quot;: &quot;lower_case&quot; },
    { &quot;keys&quot;: [&quot;super+j&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: {&quot;to&quot;: &quot;line&quot;} },
    { &quot;keys&quot;: [&quot;super+j+l&quot;], &quot;command&quot;: &quot;join_lines&quot; },
    { &quot;keys&quot;: [&quot;super+e+s+f+s&quot;], &quot;command&quot;: &quot;slurp_find_string&quot; },
    { &quot;keys&quot;: [&quot;super+e&quot;], &quot;command&quot;: &quot;find_under_expand&quot; },
    { &quot;keys&quot;: [&quot;super+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: {&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;} }
]
</code></pre>
<p>参考在此：<a href="http://docs.sublimetext.info/en/latest/reference/keyboard_shortcuts_osx.html" target="_blank" rel="external">Keyboard Shortcuts - OSX</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;应用介绍&quot;&gt;&lt;a href=&quot;#应用介绍&quot; class=&quot;headerlink&quot; title=&quot;应用介绍&quot;&gt;&lt;/a&gt;应用介绍&lt;/h1&gt;&lt;p&gt;Sublime Text 拥有漂亮的用户界面和非凡的功能，而根据其官网介绍，Sublime Text的特点如下：拥有高效、没有干扰的界面，在编辑方面的多选、宏、代码片段等功能，以及很有特色的Minimap。&lt;br&gt;用户广受喜爱的众多功能之一GOTO ANYTHING&lt;br&gt;仅仅敲击几次键盘就能即刻jump to symbols, lines or words.&lt;strong&gt;Shortcuts:&lt;/strong&gt;  &lt;code&gt;⌘ + P&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Sublime Text" scheme="//zeroto.tech/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title>一张通往计算机世界的地图</title>
    <link href="//zeroto.tech/2017/12/19/%E4%B8%80%E5%BC%A0%E9%80%9A%E5%BE%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C%E7%9A%84%E5%9C%B0%E5%9B%BE/"/>
    <id>//zeroto.tech/2017/12/19/一张通往计算机世界的地图/</id>
    <published>2017-12-19T05:25:09.000Z</published>
    <updated>2018-03-12T03:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一张通往计算机世界的地图"><a href="#一张通往计算机世界的地图" class="headerlink" title="一张通往计算机世界的地图"></a>一张通往计算机世界的地图</h1><h2 id="引述"><a href="#引述" class="headerlink" title="引述"></a>引述</h2><p>我们通过计算机来拓展我们自己的大脑。最开始计算机被用来解决和算数有关的问题，但其自身的价值很快地延伸到了各个领域。 像是运行互联网络，处理实时图像，制造人工智能，以及模拟整个宇宙等等。 而其神奇的地方就在于这一切强大功能的背后，竟然仅是 0 和 1 的来回变化。</p>
<a id="more"></a>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>作者：Surmon <a href="https://surmon.me/article/75" target="_blank" rel="external">https://surmon.me/article/75</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一张通往计算机世界的地图&quot;&gt;&lt;a href=&quot;#一张通往计算机世界的地图&quot; class=&quot;headerlink&quot; title=&quot;一张通往计算机世界的地图&quot;&gt;&lt;/a&gt;一张通往计算机世界的地图&lt;/h1&gt;&lt;h2 id=&quot;引述&quot;&gt;&lt;a href=&quot;#引述&quot; class=&quot;headerlink&quot; title=&quot;引述&quot;&gt;&lt;/a&gt;引述&lt;/h2&gt;&lt;p&gt;我们通过计算机来拓展我们自己的大脑。最开始计算机被用来解决和算数有关的问题，但其自身的价值很快地延伸到了各个领域。 像是运行互联网络，处理实时图像，制造人工智能，以及模拟整个宇宙等等。 而其神奇的地方就在于这一切强大功能的背后，竟然仅是 0 和 1 的来回变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="//zeroto.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="网络" scheme="//zeroto.tech/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="//zeroto.tech/tags/Linux/"/>
    
      <category term="软件工程" scheme="//zeroto.tech/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis技术交流</title>
    <link href="//zeroto.tech/2017/12/12/redis%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    <id>//zeroto.tech/2017/12/12/redis技术交流/</id>
    <published>2017-12-12T08:56:14.000Z</published>
    <updated>2018-03-12T03:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis原理与实战，不定期更新"><a href="#Redis原理与实战，不定期更新" class="headerlink" title="Redis原理与实战，不定期更新"></a>Redis原理与实战，不定期更新</h2><p>Redis是业界普遍应用的缓存组件，研究一个组件框架，就要探究它的设计哲学。<br><a href="https://redis.io/" target="_blank" rel="external">https://redis.io/</a></p>
<a id="more"></a>
<p>系列文章有些是从Redis源码，有些是从数据结构、内存优化、持久化、Redis集群实现原理探讨开来。<br>总之，很是流行，有必要多方位了解一下啦。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/3TU9qxHJyxHJgVDaYXoluA" target="_blank" rel="external">张铁蕾</a> </li>
<li><a href="https://goo.gl/uBKGr1" target="_blank" rel="external">Redis压缩列表原理与应用分析</a></li>
<li><a href="https://goo.gl/vTe1b5" target="_blank" rel="external">深入浅出Redis Cluster原理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTEyOTQ5OQ==&amp;mid=402004912&amp;idx=1&amp;sn=7517696a86f54262e60e1b5636d6cbe0&amp;scene=1&amp;srcid=0521HB3pYYfb5rwuUr19GmB5#rd" target="_blank" rel="external">Redis 集群的合纵与连横</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547160&amp;idx=1&amp;sn=befd195e2aa788775aaf1cc3b6f6fab3&amp;scene=1&amp;srcid=051242VSB3OeDvn9GbmJ2QY0#rd" target="_blank" rel="external">360开源的类Redis存储系统:Pika</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712266&amp;idx=1&amp;sn=54d909d240eb701ae48467dc798ddc7f&amp;scene=1&amp;srcid=0506xZXTUptwNdQOqmeVNjjK#rd" target="_blank" rel="external">动态追踪技术（中） - Dtrace、SystemTap、火焰图</a></li>
<li><a href="https://github.com/QConChina/QConShanghai2016" target="_blank" rel="external">QCon上海2016的幻灯片合集</a></li>
<li><a href="http://ppt.geekbang.org/qconbj2016?amp;amp;isappinstalled=0&amp;amp;amp;isappinstalled=0&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="external">QCon北京2016幻灯片下载合集</a></li>
<li><a href="http://ppt.geekbang.org/qconsh2017" target="_blank" rel="external">QCon 上海 2017 PPT 合集</a></li>
<li><a href="https://m.aliyun.com/yunqi/articles/58703?from=singlemessage&amp;isappinstalled=1" target="_blank" rel="external">Redis源码学习(云栖社区)</a></li>
<li><a href="http://www.cnblogs.com/wxisme/p/5742456.html" target="_blank" rel="external">基于Redis的BloomFilter算法去重</a></li>
<li><a href="http://bg2bkk.github.io/post/redis过期清除机制及应用方法" target="_blank" rel="external">redis过期清除机制及应用方法</a></li>
<li><a href="http://blog.jobbole.com/107084/" target="_blank" rel="external">由浅入深介绍 Redis LRU 策略的具体实现</a></li>
<li><a href="http://gongfuxiang.com/post-98.html" target="_blank" rel="external">Nginx+Lua+Redis搭建高并发服务</a></li>
<li><a href="https://neway6655.github.io/redis/2016/10/10/redis-hmget-deep-study.html" target="_blank" rel="external">Redis的hmget操作复杂度问题</a></li>
<li><a href="https://goo.gl/H4afYW" target="_blank" rel="external">Redis中BitMap的妙用</a></li>
<li><a href="https://cachecloud.github.io/2017/02/16/Redis内存优化/" target="_blank" rel="external">Redis的内存优化</a></li>
<li><a href="https://goo.gl/g89ZXh" target="_blank" rel="external">理解Redis的RESP协议</a></li>
<li><a href="https://goo.gl/cNCTGW" target="_blank" rel="external">深入学习 Redis：Redis API 的原子性分析</a></li>
<li><a href="https://goo.gl/9fLJ7d" target="_blank" rel="external">Redis 实现接口访问频率限制</a></li>
<li><a href="https://goo.gl/5qFP6L" target="_blank" rel="external">Redis 源码学习之事件驱动</a></li>
<li><a href="https://goo.gl/ztG8TC" target="_blank" rel="external">Redis 通信协议 —— 了解 Redis 客户端实现原理</a></li>
<li><a href="https://goo.gl/4mTRVX" target="_blank" rel="external">有赞延迟队列设计</a></li>
<li><a href="https://yq.aliyun.com/articles/62899?spm=5176.154649.801568.9.UvJFm2" target="_blank" rel="external">Redis内存分析方法</a></li>
<li><a href="https://goo.gl/i5WhU8" target="_blank" rel="external">redis分布式内存锁：余量扣除示例(上)</a></li>
<li><a href="https://goo.gl/iZTeCB" target="_blank" rel="external">redis分布式内存锁：余量扣除示例(下)</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/1.-%E6%A6%82%E8%BF%B0" target="_blank" rel="external">redisson</a></li>
<li><a href="https://www.zybuluo.com/sambodhi/note/642230" target="_blank" rel="external">GitHub将持久数据从Redis迁出</a></li>
<li><a href="https://goo.gl/z1TKdu" target="_blank" rel="external">Redis架构之防雪崩设计：网站不宕机背后的兵法</a></li>
<li><a href="https://goo.gl/m3Bn6V" target="_blank" rel="external">千亿级高性能 KV 存储生态圈</a></li>
<li><a href="https://yq.aliyun.com/articles/68350" target="_blank" rel="external">Redis内核基于时间点的备份恢复和基于AOF日志的增量同步机制设计</a></li>
<li><a href="https://pingcap.com/blog-cn/ga-liuqi/" target="_blank" rel="external">TiDB技术内幕</a></li>
<li><a href="http://beautyboss.farbox.com/post/redis/redisyuan-ma-xue-xi-zhi-shi-jian-qu-dong" target="_blank" rel="external">Redis源码学习之事件驱动</a></li>
<li><a href="https://goo.gl/eRgcAj" target="_blank" rel="external">揭秘 Reddit 愚人节项目的技术实现过程</a></li>
<li><a href="https://goo.gl/7ZXVjP" target="_blank" rel="external">Redis 通信协议 —— 了解 Redis 客户端实现原理</a></li>
<li><a href="http://blog.csdn.net/mr_smile2014/article/details/73849573" target="_blank" rel="external">redis哨兵模式使用lua脚本实现分布式锁</a></li>
<li><a href="https://goo.gl/dkyPck" target="_blank" rel="external">CRUG | Redisson性能压测权威发布</a></li>
<li><a href="https://goo.gl/2bcHHi" target="_blank" rel="external">听滴滴大神给你讲Redis Cluster迁移遇到的坑</a></li>
<li><a href="http://wangxin123.com/2017/05/27/" target="_blank" rel="external">Redis开启AOF导致的删库事件</a></li>
<li><a href="https://goo.gl/5jmgPZ" target="_blank" rel="external">唯品会海量实时OLAP分析技术升级之路</a></li>
<li><a href="https://m.aliyun.com/yunqi/articles/236384" target="_blank" rel="external">Jedis常见异常汇总</a></li>
<li><a href="http://www.jianshu.com/u/6df88dea0d41" target="_blank" rel="external">redis cluster 集群畅谈</a></li>
<li><a href="https://logz.io/blog/redis-performance-monitoring-elk-stack/" target="_blank" rel="external">Redis Performance Monitoring with the ELK Stack</a></li>
<li><a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="external">Redis 和 I/O 多路复用</a></li>
<li><a href="https://goo.gl/nYK3gx" target="_blank" rel="external">使用 Redis 解决“树”形数据的复杂查询</a></li>
<li><a href="https://www.blazemeter.com/blog/jmeters-redis-data-set-an-introduction" target="_blank" rel="external">JMeter’s Redis Data Set - An Introduction</a></li>
<li><a href="https://goo.gl/vEyUUs" target="_blank" rel="external">Redis 如何分布式，来看京东金融的设计与实践</a></li>
<li><a href="https://goo.gl/VapkrK" target="_blank" rel="external">Redis 新数据结构 - Streams</a></li>
<li><a href="https://tech.youzan.com/redisji-qun-shi-xian-yuan-li-tan-tao/?sf=wx_sm" target="_blank" rel="external">Redis集群实现原理探讨</a></li>
<li><a href="http://weakyon.com/2017/10/11/sentinel-does-not-trigger-failover-when-master-reboot-resulting-in-data-loss.html" target="_blank" rel="external">当主重启时sentinel没有切换导致数据丢失</a></li>
<li><a href="https://goo.gl/8hxsuc" target="_blank" rel="external">大规模codis集群的治理与实践</a></li>
<li><a href="http://www.jianshu.com/p/b5a96142fdd9" target="_blank" rel="external">springboot中redis的使用和分布式session共享问题</a></li>
<li><a href="http://www.baeldung.com/redis-redisson" target="_blank" rel="external">A Guide to Redis with Redisson</a></li>
<li><a href="https://goo.gl/wzk7LU" target="_blank" rel="external">直击Redis持久化磁盘IO痛点，让存储不再有负担！</a></li>
<li><a href="http://www.10tiao.com/html/496/201708/2652402631/1.html" target="_blank" rel="external">Redis Cluster 迁移案例</a></li>
<li><a href="https://yemengying.com/2017/06/04/reddit-view-counting/" target="_blank" rel="external">【译】Reddit如何统计每个帖子的浏览量</a></li>
<li><a href="http://liu-xin.me/2015/11/17/在Redis中进行分页排序查询/" target="_blank" rel="external">在Redis中进行分页排序查询</a></li>
<li><a href="http://dbaplus.cn/news-21-1142-1.html" target="_blank" rel="external">一个小改进，解决Redis数据在线加载大痛点</a></li>
<li><a href="https://quericy.me/blog/861/" target="_blank" rel="external">社区好友动态Feed流的Redis实现</a></li>
<li><a href="http://yogoup.sinaapp.com/" target="_blank" rel="external">Redis 应用案例 - 在问题中不断成长</a></li>
<li><a href="https://goo.gl/xHZMB9" target="_blank" rel="external">国内外三个领域巨头告诉你Redis怎么用</a></li>
<li><a href="https://goo.gl/x4bj6C" target="_blank" rel="external">Redis作为LRU Cache的实现</a></li>
<li><a href="https://zzyongx.github.io/blogs/index.html" target="_blank" rel="external">如何使用redis存储海量小数据</a></li>
<li><a href="https://goo.gl/KZnCcd" target="_blank" rel="external">Redis性能问题排查解决手册</a></li>
<li><a href="https://www.tuicool.com/articles/jyINfin" target="_blank" rel="external">如何在Redis中实现事务</a></li>
<li><a href="https://goo.gl/cFfebR" target="_blank" rel="external">ansible-playbook配置redis的sentinel高可用集群</a></li>
<li><a href="http://bg2bkk.github.io/post/redis过期清除机制及应用方法/" target="_blank" rel="external">redis过期清除机制及应用方法</a></li>
<li><a href="https://ruby-china.org/topics/30720" target="_blank" rel="external">记一次 Redis 实战，实现答题系统</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTM1MjExMg==&amp;mid=2247483816&amp;idx=1&amp;sn=136d3da5f2a7cf546440fa8279cbaa47&amp;scene=1&amp;srcid=0823pmID5jdOnO0qQSz1g1ez#rd" target="_blank" rel="external">大规模排行榜系统实践及挑战</a></li>
<li><a href="https://goo.gl/5q7TKn" target="_blank" rel="external">京东抢购服务高并发实践</a></li>
<li><a href="https://goo.gl/yfpNuC" target="_blank" rel="external">教你看懂redis配置系列</a></li>
<li><a href="https://leibnizhu.gitlab.io/2016/09/11/Netty+Redis开发高并发应用的一些思考(二" target="_blank" rel="external">Netty+Redis开发高并发应用的一些思考(二)</a>/)</li>
<li><a href="http://sanyuesha.com/2016/08/20/distributed-lock-with-redis/" target="_blank" rel="external">如何用 redis 造一把分布式锁</a></li>
<li><a href="https://www.qcloud.com/community/article/222" target="_blank" rel="external">Redis 设计思路学习与总结</a></li>
<li><a href="https://mp.weixin.qq.com/s/7ituCSDrLCTo07ZgR66Oqw" target="_blank" rel="external">如何改变Redis用不好的误区</a></li>
<li><a href="http://www.jianshu.com/p/b68647b753e4?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin" target="_blank" rel="external">基于 Redis 的序列号服务的设计</a></li>
<li><a href="https://professorlea.github.io/2016/08/22/Redis-practice（一）基础篇/" target="_blank" rel="external">Redis practice（一）基础篇</a></li>
<li><a href="https://professorlea.github.io/2016/08/22/Redis-practise（二）使用Docker部署Redis高可用，分布式集群/#more" target="_blank" rel="external">Redis practise（二）使用Docker部署Redis高可用，分布式集群</a></li>
</ul>
<p><strong>2017-12-29更新</strong></p>
<ul>
<li><a href="http://www.darcy.org.cn/2016/07/23/Redis中的used-memory与maxmemory解惑/" target="_blank" rel="external">Redis中的used_memory与maxmemory解惑</a></li>
<li><a href="http://xiaorui.cc/2017/10/22/golang基于redis-lua封装的优先级去重队列/" target="_blank" rel="external">golang基于redis lua封装的优先级去重队列</a></li>
<li><a href="http://www.freebuf.com/sectool/156904.html" target="_blank" rel="external">搭建Redis&amp;Minerd安全应急演练环境</a></li>
<li><a href="https://redislabs.com/blog/geobike-building-location-aware-application-with-redis/" target="_blank" rel="external">GeoBike: Building Location Aware Application with Redis</a></li>
<li><a href="https://mp.weixin.qq.com/s/zv_tcdGiuOgUafNmM1UPmw" target="_blank" rel="external">利用Redis实现Bloom-Filter</a></li>
<li><a href="http://www.cnblogs.com/svan/p/7366397.html" target="_blank" rel="external">神奇的Redis延迟</a></li>
<li><a href="https://mp.weixin.qq.com/s/GZeOs6K0XfQLopMWticYdw" target="_blank" rel="external">Spring Boot + Redis 缓存方案深度解读</a></li>
<li><a href="https://mp.weixin.qq.com/s/2FEbkas_m1WnYUqjVpMkWw" target="_blank" rel="external">同程凤凰缓存系统基于Redis的设计与实践</a></li>
</ul>
<p><strong>2018-01-24更新</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/02NDtPI_CyDLDxAnf_OLdg" target="_blank" rel="external">不管你的Redis集群规模有多大，都是时候思考下如何提升资源利用率了</a></li>
<li><a href="https://www.codeproject.com/Articles/1223882/Setting-Up-a-Redis-Test-Environment-using-Docker-C" target="_blank" rel="external">Setting Up a Redis Test Environment using Docker Compose</a></li>
</ul>
<p><strong>2018-02-24</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/5d98222e36c0" target="_blank" rel="external">Redis 队列</a></li>
<li><a href="https://mp.weixin.qq.com/s/e5FF2a5WJyuYrlVAWEqhNQ" target="_blank" rel="external">Jmeter Redis插件开发 – 读写数据</a></li>
<li><a href="https://juejin.im/post/5a6873fcf265da3e3245a985" target="_blank" rel="external">线上redis迁移思路</a></li>
<li><a href="https://my.oschina.net/giegie/blog/1525931" target="_blank" rel="external">基于Redis实现分布式应用限流</a></li>
</ul>
<p><strong>2018-03-05</strong></p>
<ul>
<li><a href="https://ningyu1.github.io/site/post/05-cache-design/?from=groupmessage" target="_blank" rel="external">Cache设计和使用上的套路</a></li>
<li><a href="https://blog.52itstyle.com/archives/2308/" target="_blank" rel="external">Shiro安全框架基于Redis的分布式集群方案</a></li>
<li><a href="https://mp.weixin.qq.com/s/reaVnCtF982Jqo45IKgjeg" target="_blank" rel="external">运用 Redis 构建分布式爬虫，抓妹子图</a></li>
<li><a href="http://view.zsxq.com/view/5a9cb2a42540ed22f43a2014" target="_blank" rel="external">Redisson PRO</a></li>
<li><a href="https://mp.weixin.qq.com/s/hfbTRWaGSZfed4I2Op0O-w" target="_blank" rel="external">Redis探索之路</a></li>
<li><a href="https://opensource.com/article/18/2/building-bikesharing-application-open-source-tools" target="_blank" rel="external">Build a bikesharing app with Redis and Python</a></li>
<li><a href="https://mp.weixin.qq.com/s/uKGdK-1jP0q6xiJyczGwFw" target="_blank" rel="external">不停机分库分表迁移</a></li>
<li><a href="http://blog.csdn.net/dc_726/article/details/47355989" target="_blank" rel="external">豌豆夹Redis解决方案Codis源码剖析：Dashboard</a></li>
<li><a href="https://huoding.com/2012/02/29/146" target="_blank" rel="external">Redis消息通知系统的实现</a></li>
<li><a href="https://dzone.com/articles/swarmweek-part-2-rescheduling-redis-with-swarm" target="_blank" rel="external">Docker Swarm Part II: Rescheduling Redis</a></li>
<li><a href="http://blog.mayongfa.cn/287.html" target="_blank" rel="external">Redis 集群搭建详细指南</a></li>
</ul>
<p>参考在此：<br><a href="http://moelove.info/redis-articles/" target="_blank" rel="external">Redis技术交流群</a><br>Redis技术交流群2：微信群</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis原理与实战，不定期更新&quot;&gt;&lt;a href=&quot;#Redis原理与实战，不定期更新&quot; class=&quot;headerlink&quot; title=&quot;Redis原理与实战，不定期更新&quot;&gt;&lt;/a&gt;Redis原理与实战，不定期更新&lt;/h2&gt;&lt;p&gt;Redis是业界普遍应用的缓存组件，研究一个组件框架，就要探究它的设计哲学。&lt;br&gt;&lt;a href=&quot;https://redis.io/&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="//zeroto.tech/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="//zeroto.tech/2017/11/22/config/"/>
    <id>//zeroto.tech/2017/11/22/config/</id>
    <published>2017-11-22T09:32:19.000Z</published>
    <updated>2017-11-22T09:32:19.000Z</updated>
    
    <content type="html"><![CDATA[{"name":"Java 程序员眼中的 Linux","introduction":"笔者从 Java 开发角度，全方位讲解各种环境搭建及常用工具详解，是一部适合程序员的百科全书。"}]]></content>
    
    <summary type="html">
    
      {&quot;name&quot;:&quot;Java 程序员眼中的 Linux&quot;,&quot;introduction&quot;:&quot;笔者从 Java 开发角度，全方位讲解各种环境搭建及常用工具详解，是一部适合程序员的百科全书。&quot;}
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机-学习</title>
    <link href="//zeroto.tech/2017/11/17/jvm-tool/"/>
    <id>//zeroto.tech/2017/11/17/jvm-tool/</id>
    <published>2017-11-17T06:52:55.000Z</published>
    <updated>2018-03-12T03:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm调优工具"><a href="#jvm调优工具" class="headerlink" title="jvm调优工具"></a>jvm调优工具</h1><h2 id="jdk的命令行工具"><a href="#jdk的命令行工具" class="headerlink" title="jdk的命令行工具"></a>jdk的命令行工具</h2><ol>
<li>jps：虚拟机进程状况工具（jps -l）</li>
<li>jstat：虚拟机统计信息监视工具（jstat -gcutil VMID，stat -gccapacity VMID）  （Local Virtual Machine Identifier,LVMID）  </li>
<li>jinfo：Java配置信息工具<ul>
<li>jinfo -flag +PrintGCDetails VMID</li>
<li>jinfo -flag +PrintGC VMID</li>
<li>jinfo -flag +PrintGCTimeStamps VMID<br>以上就可以在一个正在运行的JVM中动态开启GC日志功能。</li>
</ul>
</li>
<li>jmap：Java内存映像工具<ul>
<li>jmap -heap VMID 显示Java堆详细信息，例如使用哪种回收器、参数配置、分代状况等。</li>
</ul>
</li>
<li>jhat：虚拟机堆转储快照分析工具</li>
<li>jstack：Java堆栈跟踪工具<ul>
<li>jstack -l VMID</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="jdk的可视化工具"><a href="#jdk的可视化工具" class="headerlink" title="jdk的可视化工具"></a>jdk的可视化工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。<br><img src="Java监视和管理控制台-启动.png" alt="Java监视和管理控制台-启动"><br><img src="Java监视和管理控制台.png" alt="内存"></p>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>VisualVM（All-in-One Java Troubleshooting Tool）强大的运行监视和故障处理程序，也能够进行性能分析，CPU、内存，在Profiler页签中能看到。<br>1.插件安装<br><img src="VisualVM插件1.png" alt="VisualVM插件1"><br><img src="VisualVM插件2.png" alt="VisualVM插件2"><br><img src="VisualVM插件3.png" alt="VisualVM插件3"></p>
<p>2.主界面<br><img src="VisualVM概述.png" alt="VisualVM概述"><br><img src="VisualVM监视.png" alt="VisualVM监视"></p>
<p>因为VisualVM的插件太多，重点展示下Visual GC：<br><img src="VisualVM-Visual GC.png" alt="VisualVM-Visual GC"></p>
<h2 id="第三方调优工具"><a href="#第三方调优工具" class="headerlink" title="第三方调优工具"></a>第三方调优工具</h2><blockquote>
<ul>
<li>MAT(Memory Analyzer Tool)</li>
<li><a href="http://gceasy.io" target="_blank" rel="external">GC Easy</a></li>
</ul>
</blockquote>
<p>MAT以eclipse插件形式安装,利用visualvm或者是 jmap命令生产堆文件，导入eclipse mat中生成分析报告：</p>
<p><img src="Memory Analyzer.png" alt="Memory Analyzer Tool"><br><img src="Memory Analyzer-Overview.png" alt="Memory Analyzer-Overview"><br><img src="Top Consumers.png" alt="Top Consumers"></p>
<p>参考在此：<br>深入理解Java虚拟机 第2版<br><a href="http://www.ityouknow.com/java/2017/02/22/jvm-tool.html" target="_blank" rel="external">jvm调优-工具篇</a> 作者：纯洁的微笑</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;jvm调优工具&quot;&gt;&lt;a href=&quot;#jvm调优工具&quot; class=&quot;headerlink&quot; title=&quot;jvm调优工具&quot;&gt;&lt;/a&gt;jvm调优工具&lt;/h1&gt;&lt;h2 id=&quot;jdk的命令行工具&quot;&gt;&lt;a href=&quot;#jdk的命令行工具&quot; class=&quot;headerlink&quot; title=&quot;jdk的命令行工具&quot;&gt;&lt;/a&gt;jdk的命令行工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;jps：虚拟机进程状况工具（jps -l）&lt;/li&gt;
&lt;li&gt;jstat：虚拟机统计信息监视工具（jstat -gcutil VMID，stat -gccapacity VMID）  （Local Virtual Machine Identifier,LVMID）  &lt;/li&gt;
&lt;li&gt;jinfo：Java配置信息工具&lt;ul&gt;
&lt;li&gt;jinfo -flag +PrintGCDetails VMID&lt;/li&gt;
&lt;li&gt;jinfo -flag +PrintGC VMID&lt;/li&gt;
&lt;li&gt;jinfo -flag +PrintGCTimeStamps VMID&lt;br&gt;以上就可以在一个正在运行的JVM中动态开启GC日志功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jmap：Java内存映像工具&lt;ul&gt;
&lt;li&gt;jmap -heap VMID 显示Java堆详细信息，例如使用哪种回收器、参数配置、分代状况等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jhat：虚拟机堆转储快照分析工具&lt;/li&gt;
&lt;li&gt;jstack：Java堆栈跟踪工具&lt;ul&gt;
&lt;li&gt;jstack -l VMID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="//zeroto.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型之happens-before</title>
    <link href="//zeroto.tech/2017/11/03/happens-before/"/>
    <id>//zeroto.tech/2017/11/03/happens-before/</id>
    <published>2017-11-03T05:28:14.000Z</published>
    <updated>2018-03-12T03:42:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型之happens-before"><a href="#Java内存模型之happens-before" class="headerlink" title="Java内存模型之happens-before"></a>Java内存模型之happens-before</h1><p>从JDK 5 开始，JMM就使用happens-before(先行发生原则)的概念来阐述多线程之间的内存可见性。</p>
<p><strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</strong></p>
<p>happens-before原则定义如下：</p>
<a id="more"></a>
<p><strong>1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong><br><strong>2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</strong></p>
<p>下面是Java内存模型下一些“天然的“先行发生关系，可以再编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，虚拟机可以对它们随意地进行重排序。</p>
<p>（摘自《深入理解Java虚拟机第12章》）：</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>锁定规则（Monitor Lock Rule）：一个unlock操作先行发生与后面同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</li>
<li>线程启动规则（Thread Start Rule）：Thread 对象的start()方法先行发生与此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生与对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断原则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中段发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生与它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生与操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则：</p>
<ol>
<li>将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作</li>
<li>将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作</li>
<li>在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作</li>
<li>释放Semaphore许可的操作Happens-Before获得许可操作</li>
<li>Future表示的任务的所有操作Happens-Before Future#get()操作</li>
<li>向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作</li>
</ol>
<p>参考在此：<br>    深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）周志明 著</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型之happens-before&quot;&gt;&lt;a href=&quot;#Java内存模型之happens-before&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型之happens-before&quot;&gt;&lt;/a&gt;Java内存模型之happens-before&lt;/h1&gt;&lt;p&gt;从JDK 5 开始，JMM就使用happens-before(先行发生原则)的概念来阐述多线程之间的内存可见性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;happens-before原则定义如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="//zeroto.tech/tags/Java/"/>
    
      <category term="Java内存模型" scheme="//zeroto.tech/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型看并发（一）</title>
    <link href="//zeroto.tech/2017/11/01/JVM-1/"/>
    <id>//zeroto.tech/2017/11/01/JVM-1/</id>
    <published>2017-11-01T06:49:18.000Z</published>
    <updated>2018-06-06T07:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？</p>
<a id="more"></a>
<p>对象和类的数据存储在3个不同的内存区域：堆（heap space）、方法区（method area）、本地区（native area）。</p>
<p>堆内存存放对象以及数组的数据，方法区存放类的信息（包括类名、方法、字段）、静态变量、编译器编译后的代码，本地区包含线程栈、本地方法栈等存放线程</p>
<p><img src="/assets/blogImg/JUtH_20121024_RuntimeDataAreas_1_MemoryModel-1.png" alt="RuntimeDataAreas_1_MemoryModel-1"></p>
<p>方法区有时被称为持久代（PermGen）。</p>
<p><img src="/assets/blogImg/JUtH_20121024_RuntimeDataAreas_2_MemoryModel-1.png" alt="RuntimeDataAreas_2_MemoryModel-1"></p>
<p>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。</p>
<p>方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。</p>
<h2 id="你真的会写单例吗"><a href="#你真的会写单例吗" class="headerlink" title="你真的会写单例吗"></a>你真的会写单例吗</h2><pre><code class="java">/**   
 * 漫画：什么是单例模式？见：https://mp.weixin.qq.com/s/pAYYcvh4IRvLs5WYgiPe3A
 * https://blankj.com/2016/04/21/really-use-singleton/
 * @ClassName: Singleton.java
 * @Description: 单例模式实现方式&lt;br&gt;
 * 1、双重锁检测&lt;br&gt;
 * 2、静态内部类&lt;br&gt;
 * 3、饿汉式
 *
 * @author: zhangjk
 * @date: 2018年3月7日 下午2:05:53 
 */
public class Singleton {

    //一、双检查锁（DCL，即 double-checked locking）
    //描述：这种方式称为双重检查锁(Double-Check Locking)，需要注意的是，如果使用双重检查锁定来实现懒汉式单例类
//    private Singleton() {}
//    private volatile static Singleton instance = null; //单例对象;volatile 修饰符阻止了变量访问前后的指令重排序，保证了指令执行顺序。
//    public static Singleton getInstance() {
//        if (instance == null) {
//            synchronized (Singleton.class) {
//                if(instance == null) {
//                    instance = new Singleton();
//                }
//            }
//        }
//        return instance;
//    }


    // 二、用静态内部类实现单例模式：
    // 1.从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。
    // 2.INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。
    //描述：饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制繁琐，而且性能受影响。
//    private static class LazyHolder {
//        private static final Singleton INSTANCE = new Singleton();
//    }
//    
//    private Singleton() {}
//    public static Singleton getInstance() {
//        return LazyHolder.INSTANCE;
//    }

    //三、饿汉式
    //优点：没有加锁，执行效率会提高。
    //缺点：类加载时就初始化，浪费内存。
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getIntance() {
        return instance;
    }

}
</code></pre>
<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p>CountDownLatch和CyclicBarrier是jdk concurrent包下非常有用的两个并发工具类，它们提供了一种控制并发流程的手段。</p>
<p>CountDownLatch 允许一个或多个线程等待其他线程完成操作。<br>CyclicBarrier 让一组线程到达一个同步点后再一起继续运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。</p>
<h3 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h3><p>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。</p>
<p>一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。<br>每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。拿到信号量的线程可以进入代码，否则就等待。通过acquire()和release()获取和释放访问许可。</p>
<pre><code class="java">/**
 * 控制并发线程数
 */
public class SemaphoreDemo {

    /**
     *执行任务类，获取信号量
     */
    class SemaphoreRunnable implements Runnable{
        private Semaphore semaphore;
        private int user;

        public SemaphoreRunnable(Semaphore semaphore, int user) {
            this.semaphore = semaphore;
            this.user = user;
        }

        @Override
        public void run() {
            try {
                //获取信号量许可
                semaphore.acquire();
                System.out.println(&quot;用户【&quot; + user + &quot;】进入窗口，准备买票...&quot;);
                Thread.sleep((long)(Math.random()*10000));
                System.out.println(&quot;用户【&quot; + user + &quot;】买票完成，即将离开...&quot;);
                Thread.sleep((long)(Math.random()*10000));
                System.out.println(&quot;用户【&quot; + user + &quot;】离开售票窗口...&quot;);
                //释放信号量许可
                semaphore.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    private void execute(){
        //定义窗口个数
        final Semaphore semaphore = new Semaphore(3);
        //线程池
        ExecutorService threadPool = Executors.newCachedThreadPool();

        for (int i = 0; i &lt; 10; i++) {
            threadPool.execute(new SemaphoreRunnable(semaphore,i + 1));
        }
        threadPool.shutdown();
    }

    public static void main(String[] args) {
        SemaphoreDemo semaphoreDemo = new SemaphoreDemo();
        semaphoreDemo.execute();
    }

}
</code></pre>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>源码注释：<br>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.<br>（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p>
<blockquote>
<ul>
<li>CountDownLatch声明： </li>
<li>CountDownLatch的构造函数接受int型参数作为它的计数器，如果想等待N个点完成，就传入N；</li>
<li>调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞主线程直到N减少到0。</li>
</ul>
</blockquote>
<p>网上有个经典例子，在此抄录一下帮助理解记忆。</p>
<pre><code class="java">/**
 * F1赛车每次进站后，车队技师都需要在尽可能短的时间内对赛车做三个工作：加注燃油、更换轮胎、更换刹车片。
 * 当然，这三项工作都是同时进行的。只有当这三项工作完成，赛车才能驶出维修站。
 */
public class CountdownlatchDemo {

    static class Mechanician implements Runnable{
        String work;
        CountDownLatch cDownLatch ;
        public Mechanician(String work,CountDownLatch cDownLatch) {
            this.work = work;
            this.cDownLatch = cDownLatch;
        }
        @Override
        public void run() {
            try {
                int random=new Random().nextInt(7);
                TimeUnit.SECONDS.sleep(random);
                System.out.println(Thread.currentThread().getName()+&quot;--- &quot;+work+&quot; 完成，此组耗时：&quot;+random+&quot;秒&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally{
                /*当前技师的任务完成,cDownLatch计算器减1
                 *通常countDown放在finally里中使用*/
                cDownLatch.countDown();
            }
        }
    }


    public static void main(String[] args) {
        CountDownLatch cDownLatch=new CountDownLatch(3);//初始计数器值为3，对应3个维修组
         /*1、赛车进站*/
        System.out.println(&quot;F1赛车进站，时间：&quot;+Calendar.getInstance().get(Calendar.SECOND));

        List&lt;Mechanician&gt; mechanician_team=new ArrayList&lt;Mechanician&gt;();
        mechanician_team.add(new Mechanician(&quot;加注燃油&quot;, cDownLatch));
        mechanician_team.add(new Mechanician(&quot;更换轮胎&quot;, cDownLatch));
        mechanician_team.add(new Mechanician(&quot;更换刹车片&quot;, cDownLatch));
        for(Mechanician mechanician : mechanician_team){
            new Thread(mechanician).start();
        }
        /*3、等待技师完成三项工作。实际就是等待cDownLatch计数器变成0*/
        try {
            cDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /*4、完成维护，出发*/
        System.out.println(&quot;F1赛车维修完毕，出发！时间：&quot;+Calendar.getInstance().get(Calendar.SECOND));

    }

}
</code></pre>
<p>Countdownlatch 是一个倒计数器锁。调用CountDownLatch对象的await()方法使线程处于等待状态，调用countDown()方法的线程会将计数器减1，当计数到达0时，所有等待线程（可多个，但通常的应用场景中只有一个等待者）开始继续执行。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>源码注释：<br>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.（多个线程互相等待，直到到达同一个同步点，再继续一起执行）</p>
<blockquote>
<ul>
<li>CyclicBarrier(int parties) 默认构造方法，参数表示拦截的线程数量。</li>
<li>CyclicBarrier(int parties, Runnable barrierAction)<br>由于线程之前的调度是由CPU决定的，所以默认的构造方法无法设置线程执行优先级，CyclicBarrier提供一个更高级的构造函数(int parties, Runnable barrierAction)，用于在线程到达同步点时，优先执行线程barrierAction，这样可以更加方便的处理一些复杂的业务场景。</li>
<li>创建CyclicBarrier后，每个线程调用await方法告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。</li>
</ul>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在Java语言内部，java.lang.Runtime对象就是一个使用单例模式的例子。在每一个Java应用程序里面，都有唯一的一个Runtime对象，应用程序可以与其运行环境发生相互作用。</p>
<p>参考在此：<br>深入理解Java虚拟机 第2版（第2章 Java 内存区域与内存溢出异常）<br><a href="http://ifeve.com/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="external">JAVA的内存模型及结构</a><br><a href="https://blankj.com/2016/04/21/really-use-singleton/" target="_blank" rel="external">你真的会写单例吗</a><br><a href="http://cmsblogs.com/?p=2253" target="_blank" rel="external">J.U.C之并发工具类：CountDownLatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;p&gt;所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="J.U.C" scheme="//zeroto.tech/tags/J-U-C/"/>
    
      <category term="单例" scheme="//zeroto.tech/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>poi实现Excel文件导入、导出</title>
    <link href="//zeroto.tech/2017/10/23/Excel-poi-how/"/>
    <id>//zeroto.tech/2017/10/23/Excel-poi-how/</id>
    <published>2017-10-23T02:33:07.000Z</published>
    <updated>2018-03-12T06:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="poi-是什么呢"><a href="#poi-是什么呢" class="headerlink" title="poi 是什么呢"></a>poi 是什么呢</h1><p>Apache POI 简介是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对Microsoft Office（Excel、WORD、PowerPoint、Visio等）格式档案读和写的功能。POI为“Poor Obfuscation Implementation”的首字母缩写，意为“可怜的模糊实现”。</p>
<a id="more"></a>
<h1 id="与我而言"><a href="#与我而言" class="headerlink" title="与我而言"></a>与我而言</h1><p>使用于某项技术，来完成特定业务是最重要的。看下图最终要实现的功能：<br>考查、考试，在对应的中期（期中）考核形式、期末考试形式 相应位置处画 √<br>必修课补考形式 唯一必填。<br>难点在于 期中考试形式、期末考试形式、必修课补考形式（考试形式字典）是动态可增减的。</p>
<p><img src="excel-poi.png" alt="考务：考试形式登记"></p>
<h2 id="归纳总结Excel工具类"><a href="#归纳总结Excel工具类" class="headerlink" title="归纳总结Excel工具类"></a>归纳总结Excel工具类</h2><pre><code class="java">
public static Map&lt;String,String&gt;  getExcelHeaderString(String filePath) {
//        You&#39;d use HSSF if you needed to read or write an Excel file using Java (XLS). 
//        You&#39;d use XSSF if you need to read or write an OOXML Excel file using Java (XLSX).         
        boolean isE2007 = false;    //判断是否是excel2007格式

        if(filePath.endsWith(&quot;xlsx&quot;)) isE2007 = true;
        //得到表头字段
        Map&lt;String, String&gt; excelHeaderMap = new LinkedHashMap&lt;String, String&gt;();
        InputStream input = null;
        Workbook wb = null;
        try {
            //建立输入流
            input = new FileInputStream(filePath);
            //根据文件格式(2003或者2007)来初始化
            if(isE2007) wb = new XSSFWorkbook(input);
            else wb = new HSSFWorkbook(input);

            Sheet sheet = wb.getSheetAt(0);     //获得第一个表单
            Row row = sheet.getRow(0);
            int columnNum = row.getLastCellNum();

            for (short i = 0; i &lt; columnNum; i++) {
                Cell cell = row.getCell(i);
                String HeaderString = cell.getRichStringCellValue().getString().trim();
                excelHeaderMap.put(HeaderString,HeaderString);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            try {
                if(null != wb){
                    input.close();
                    wb.close();
                }
            } catch (IOException e) {
            }
        }
        return excelHeaderMap;
    }


    public static List&lt;Map&lt;String,Object&gt;&gt; getBeanList(String filePath) throws IOException{
        return getBeanList(filePath, null);
    }
    /**
     * 解析excel 数据，每一行存为一个map， key为每列首行对应的文字
     */
    public static List&lt;Map&lt;String,Object&gt;&gt; getBeanList(String filePath, Map&lt;String, String&gt; matchingResultMap) throws IOException{
        List&lt;Map&lt;String,Object&gt;&gt; beanList = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();

        boolean isE2007 = false;    //判断是否是excel2007格式

        if(filePath.endsWith(&quot;xlsx&quot;)) isE2007 = true;
        InputStream input = null;
        Workbook wb = null;
        try {
            //建立输入流
            input = new FileInputStream(filePath);
            //根据文件格式(2003或者2007)来初始化
            if(isE2007) wb = new XSSFWorkbook(input);
            else wb = new HSSFWorkbook(input);

            Sheet sheet = wb.getSheetAt(0);
            Map&lt;Short, String&gt; excelHeaderMap = new HashMap&lt;Short, String&gt;();
            int firstRowNum = sheet.getFirstRowNum();
            Row row = sheet.getRow(firstRowNum);
            int columnNum = row.getLastCellNum();
            for (short i = 0; i &lt; columnNum; i++) {
                Cell cell = row.getCell(i);
                String HeaderString = cell.getRichStringCellValue().getString().trim();
                excelHeaderMap.put(i,HeaderString);
            }
            int rowNum = sheet.getPhysicalNumberOfRows();// 获取第0个sheet的行的数量(1...n)

            for (int i = firstRowNum+1; i &lt; rowNum; i++) {
                Row xRow = sheet.getRow(i);
                Map&lt;String,Object&gt; beanMap = new LinkedHashMap&lt;String, Object&gt;();
                for(short j=0; j &lt; columnNum; j++ ){
                    String headerKey = null;
                    if ( matchingResultMap == null
                            || matchingResultMap.get(excelHeaderMap.get(j)) == null){
                        headerKey = excelHeaderMap.get(j);
                    } else {
                        matchingResultMap.get(excelHeaderMap.get(j));
                    }
                    String headerValue = null;
                    if(null != xRow.getCell(j)){
                        headerValue = getCellContent(xRow.getCell(j)).trim();
                        if (beanMap.get(headerKey) == null){
                            beanMap.put(headerKey, headerValue);
                        }
                    }else{
                        beanMap.put(headerKey, &quot;&quot;);
                    }
                }
                if(beanMap.containsKey(null)){
                    beanMap.remove(null);
                }
                beanMap.put(&quot;row_num&quot;, i + 1);//excel中的行号
                beanList.add(beanMap);
            }
        }catch(IOException e){

        }finally{
            input.close();
            wb.close();
        }
        return beanList;
    }

    /**
     * 根据 二维数组（数据）在指定路径下生成文件
     * 
     * @param fileFullPathName 绝对文件路径（包含文件名）
     * @param fieldNames 表头字段数组
     * @param data 二维数组（数据）Object[行][列]
     * @return boolean (标识是否成功生成文件)
     * @author zhangjinkui
     */
    public static boolean writeFile(String fileFullPathName,String[] fieldNames,Object[][] data) {

        boolean flag = false;
        HSSFWorkbook wb = new HSSFWorkbook();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            // 创建字体
            Font font = wb.createFont();
            // 创建列样式
            CellStyle cellStyle = wb.createCellStyle();

            Sheet sheet = wb.createSheet();
            Row row = sheet.createRow(0);
            int colLength = fieldNames.length;
            for (int i = 0; i &lt; colLength; i++) {
                row.setHeightInPoints(25);
                sheet.setColumnWidth(i, 256*16);
                ExcelUtils.createCell(row, i, fieldNames[i],createHeadCell(wb));
            }
            int line = 0;
            for (line = 0; line &lt; data.length; line++) {
                Row rowtemp = sheet.createRow(line +1);
                for (int col = 0; col &lt; colLength; col++) {
                    createCell2(rowtemp, col,data[line][col],createCellStyle(font,cellStyle));
                }
            }
            wb.write(baos);
            File file = new File(fileFullPathName);
            FileUtils.writeByteArrayToFile(file, baos.toByteArray());    
            flag = true;
        } catch (Exception e) {
            flag = false;
        } finally {
                try {
                    baos.close();
                    wb.close();
                } catch (IOException e) {
                    e.printStackTrace();
                } 
        }
        return flag;
    }

    /**
     * 得到字节流之后，可直接写入客户端，也可写入到指定文件
     * 
     * @param sheetName sheet页名称
     * @param fieldNames 表头字段数组
     * @param data 二维数组（数据）Object[行][列]
     * @return  返回字节数组
     * @throws IOException 
     * @author zhangjinkui
     */
    public static byte[] writeExcel(String sheetName,String[] fieldNames,Object[][] data) throws IOException{
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        HSSFWorkbook wb = new HSSFWorkbook();
        try {
            // 创建字体
            Font font = wb.createFont();
            // 创建列样式
            CellStyle cellStyle = wb.createCellStyle();
            Sheet sheet = null;
            if(StringUtils.isBlank(sheetName)){
                sheet = wb.createSheet(&quot;&quot;);
            }else{
                sheet =  wb.createSheet(sheetName);
            }
            Row row = sheet.createRow(0);
            int colLength = fieldNames.length;
            for (int i = 0; i &lt; colLength; i++) {
                row.setHeightInPoints(25);
                sheet.setColumnWidth(i, 256*16);
                ExcelUtils.createCell(row, i, fieldNames[i], createHeadCell(wb));
            }
            int line = 0;
            for (line = 0; line &lt; data.length; line++) {
                Row rowtemp = sheet.createRow(line +1);
                for (int col = 0; col &lt; colLength; col++) {
                    createCell2(rowtemp, col,data[line][col],createCellStyle(font,cellStyle));
                }
            }
            wb.write(baos);
        } catch (Exception e) {
        } finally {
                try {
                    baos.close();
                    wb.close();
                } catch (IOException e) {
                    e.printStackTrace();
                } 
        }
        return baos.toByteArray();
    }

    /**
     * 合并单元格 行
     * @param sheet    
     * @param columnNum 从第几列开始（0-based）
     * @param rowStart          从第几行开始（0-based）
     * @param rowspan          跨多少行
     */
    public static void mergedRegionRow(Sheet sheet, int columnNum, int rowStart, int rowspan){
         sheet.addMergedRegion(new CellRangeAddress(
                 rowStart, //first row (0-based)
                 rowStart + rowspan-1, //last row  (0-based)
                 columnNum, //first column (0-based)
                 columnNum  //last column  (0-based)
         ));
    }

    /**
     * 合并单元格 列
     * @param sheet
     * @param rowNum 第几行 （0-based）
     * @param colStart    从第几列开始（0-based）
     * @param colspan    跨多少列
     */
    public static void mergedRegionColumn(Sheet sheet, int rowNum, int colStart, int colspan){
         sheet.addMergedRegion(new CellRangeAddress(
                 rowNum, //first row (0-based)
                 rowNum, //last row  (0-based)
                 colStart, //first column (0-based)
                 colStart + colspan - 1 //last column  (0-based)
         ));
    }

    /**
     * 设置生成Cell单元格 
     * @param row
     * @param column
     * @param cellValue
     * @param cellStyle
     */
    public static void createCell(Row row, Integer column, String cellValue, CellStyle cellStyle) {
        Cell cell = row.createCell(column);
        if(StringUtils.isEmpty(cellValue)) cellValue = &quot;&quot;;
        cell.setCellValue(cellValue);
        // 统一将单元格格式设置成字符串类型
        cell.setCellType(Cell.CELL_TYPE_STRING);
        cell.setCellStyle(cellStyle);
    }

    public static void createCell2(Row row, Integer column, Object cellValue, CellStyle cellStyle) {
        Cell cell = row.createCell(column);
        if(StringUtils.isEmpty(String.valueOf(cellValue))) cellValue = &quot;&quot;;

        try {
            if (isNumeric(String.valueOf(cellValue))){
                double num = Double.valueOf(String.valueOf(cellValue));
                cell.setCellValue(num);
                cell.setCellType(Cell.CELL_TYPE_NUMERIC);
            } else {
                cell.setCellValue(String.valueOf(cellValue));
                cell.setCellType(Cell.CELL_TYPE_STRING);
            }
        }catch(Exception e){
            cell.setCellValue(String.valueOf(cellValue));
            cell.setCellType(Cell.CELL_TYPE_STRING);
        }

        cell.setCellStyle(cellStyle);
    }

     private static boolean isNumeric(String value){
             if (StringUtils.isBlank(value) ){
                 return false;
             }
             //http://blog.jobbole.com/96052/ 
             //非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 
//            String reg = &quot;^\\d+(\\.\\d+)?$&quot;;
            String reg = &quot;^(0|([1-9]\\d{0,6}))(\\.\\d+)?$&quot;;//避免长数字出现科学计数法
            return Pattern.compile(reg).matcher(value).find();
        }

    /**
     * 设置生成Cell单元格 
     * @param row
     * @param column
     * @param cellValue
     */
    public static void createCell(Row row, Integer column, String cellValue) {
        Cell cell = row.createCell(column);
        if(StringUtils.isEmpty(cellValue)) cellValue = &quot;&quot;;
        cell.setCellValue(cellValue);
        // 统一将单元格格式设置成字符串类型
        cell.setCellType(Cell.CELL_TYPE_STRING);
    }

    /**
     * 设置生成Cell单元格 
     * @param row
     * @param column
     * @param cellValue
     */
    public static void createCell(Row row, Integer column, Object cellValue) {
        Cell cell = row.createCell(column);
        if(StringUtils.isEmpty(String.valueOf(cellValue))) cellValue = &quot;&quot;;
        cell.setCellValue(String.valueOf(cellValue));
        // 统一将单元格格式设置成字符串类型
        cell.setCellType(Cell.CELL_TYPE_STRING);
    }

    /**
     * 获得excel列的值，以字符串格式返回
     * 避免过大数字 以出现科学计数法形式出现
     * @param cell
     * @return
     */
    public static String getCellContent(Cell cell){
        switch (cell.getCellType()) {
        case Cell.CELL_TYPE_STRING:
            return String.valueOf(cell.getRichStringCellValue().toString().trim());
        case Cell.CELL_TYPE_NUMERIC:
            if (DateUtil.isCellDateFormatted(cell)) {
                return String.valueOf(cell.getDateCellValue());
            } else {
                DecimalFormat df = new DecimalFormat(&quot;0&quot;);
                return  df.format(cell.getNumericCellValue());
            }
        case Cell.CELL_TYPE_BOOLEAN:
            return String.valueOf(cell.getBooleanCellValue());
        case Cell.CELL_TYPE_FORMULA:
            String strCell = null;
            try {  
                   strCell = String.valueOf(cell.getStringCellValue().trim());  
            } catch (IllegalStateException e) {  
                   strCell = String.valueOf(cell.getNumericCellValue());  
            }  
            return strCell;
        default:
            return String.valueOf(cell.getRichStringCellValue().getString().trim());
        }
    }

    /**
     * 正文 默认字体样式，setWrapText=true（自动换行）
     * @return
     */
    public static CellStyle createCellStyle(Font font,CellStyle cellStyle) {

        // 设置字体颜色 (黑色)
        font.setColor(HSSFColor.BLACK.index);
        // 设置字体
        font.setFontName(&quot;宋体&quot;);
        // 设置粗体
        font.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);
        // 设置字体大小
        font.setFontHeightInPoints((short)12);
        cellStyle.setWrapText(true);
        // 设置字体
        cellStyle.setFont(font);
        // 设置对齐
        cellStyle.setAlignment(CellStyle.ALIGN_CENTER);
        // 垂直居中
        cellStyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        cellStyle.setLocked(false);
        return cellStyle;
    }

    /**
     * 正文 默认字体样式，setWrapText=false（不允许自动换行）
     * @return
     */
    public static CellStyle createCellStyleWrapTextFalse(Font font,CellStyle cellStyle) {

        // 设置字体颜色 (黑色)
        font.setColor(HSSFColor.BLACK.index);
        // 设置字体
        font.setFontName(&quot;宋体&quot;);
        // 设置粗体
        font.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);
        // 设置字体大小
        font.setFontHeightInPoints((short)12);
        cellStyle.setWrapText(false);
        // 设置字体
        cellStyle.setFont(font);
        // 设置对齐
        cellStyle.setAlignment(CellStyle.ALIGN_CENTER);
        // 垂直居中
        cellStyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        cellStyle.setLocked(false);
        return cellStyle;
    }

    /**
     * 允许换行
     * @param wb
     * @return
     */
    public static CellStyle createBrCellStyle(HSSFWorkbook wb) {
        // 创建列样式
        CellStyle style = wb.createCellStyle();
        // 创建字体
        Font font = wb.createFont();
        // 设置字体颜色 (黑色)
        font.setColor(HSSFColor.BLACK.index);
        // 设置字体
        font.setFontName(&quot;宋体&quot;);
        // 设置粗体
        font.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);
        // 设置字体大小
        font.setFontHeightInPoints((short)12);
        // 设置不换行
        style.setWrapText(true);
        // 设置字体
        style.setFont(font);
        // 设置对齐
        style.setAlignment(CellStyle.ALIGN_LEFT);
        // 垂直居中
        style.setVerticalAlignment(CellStyle.ALIGN_LEFT);
        style.setLocked(false);

        return style;
    }

    /**
     * 表头默认样式：宋体 12号字体，加粗
     * @return
     */
    public static CellStyle createHeadCell(HSSFWorkbook wb) {
        // 创建字体
        Font font = wb.createFont();
        // 创建列样式
        CellStyle cellStyle = wb.createCellStyle();
        // 设置字体颜色 (黑色)
        font.setColor(HSSFColor.BLACK.index);
        font.setFontName(&quot;宋体&quot;);
        // 设置粗体
        font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
        // 设置字体大小
        font.setFontHeightInPoints((short)12);
        // 设置不允许自动换行
        cellStyle.setWrapText(false);
        // 设置字体
        cellStyle.setFont(font);
        // 设置对齐
        cellStyle.setAlignment(CellStyle.ALIGN_CENTER);
        cellStyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        cellStyle.setLocked(false);

        return cellStyle;
    }

    /**
     * 特殊格式自定义，主要用在表头上
     * @return
     */
    public static  CellStyle createHSSFCellStyle(HSSFWorkbook wb,short boldweight, short fontheight, short alignment) {
        // 创建列样式
        CellStyle style = wb.createCellStyle();
        // 创建字体
        Font font = wb.createFont();
        // 设置字体颜色 (黑色)
        font.setColor(HSSFColor.BLACK.index);
        // 设置字体
        font.setFontName(&quot;宋体&quot;);
        // 设置粗体
        font.setBoldweight(boldweight);
        // 设置字体大小
        font.setFontHeightInPoints(fontheight);
        // 设置不换行
        style.setWrapText(false);
        // 设置字体
        style.setFont(font);
        // 设置对齐
        style.setAlignment(alignment);
        // 垂直居中
        style.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        style.setLocked(false);

        return style;
    }

    /**
     * 获取合并单元格的值
     * @return
     */
    public static String getMergedRegionValue(Sheet sheet, int row, int column) {
        int sheetMergeCount = sheet.getNumMergedRegions();

        for (int i = 0; i &lt; sheetMergeCount; i++) {
            CellRangeAddress ca = sheet.getMergedRegion(i);
            int firstColumn = ca.getFirstColumn();
            int lastColumn = ca.getLastColumn();
            int firstRow = ca.getFirstRow();
            int lastRow = ca.getLastRow();

            if (row &gt;= firstRow &amp;&amp; row &lt;= lastRow) {

                if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) {
                    Row fRow = sheet.getRow(firstRow);
                    Cell fCell = fRow.getCell(firstColumn);
                    return ExcelUtils.getCellContent(fCell);
                }
            }
        }

        return null;
    }

    /**
     * 得到合并区域
     * 
     * @param sheet
     * @param row
     * @param column
     * @return
     */
    public static CellRangeAddress getMergedRegion(Sheet sheet, int row, int column) {
        int sheetMergeCount = sheet.getNumMergedRegions();

        for (int i = 0; i &lt; sheetMergeCount; i++) {
            CellRangeAddress region = sheet.getMergedRegion(i);
            int firstColumn = region.getFirstColumn();
            int lastColumn = region.getLastColumn();
            int firstRow = region.getFirstRow();
            int lastRow = region.getLastRow();

            if (row &gt;= firstRow &amp;&amp; row &lt;= lastRow) {
                if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) {
                    return region;
                }
            }
        }
        return null;
    }

    /**
     * 判断合并了行
     * 
     * @param sheet
     * @param row
     * @param column
     * @return
     */
    public static boolean isMergedRow(Sheet sheet, int row, int column) {
        int sheetMergeCount = sheet.getNumMergedRegions();
        for (int i = 0; i &lt; sheetMergeCount; i++) {
            CellRangeAddress range = sheet.getMergedRegion(i);
            int firstColumn = range.getFirstColumn();
            int lastColumn = range.getLastColumn();
            int firstRow = range.getFirstRow();
            int lastRow = range.getLastRow();
            if (row == firstRow &amp;&amp; row == lastRow) {
                if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 判断指定的单元格是否是合并单元格
     * 
     * @param sheet
     *            工作表
     * @param row
     *            行下标
     * @param column
     *            列下标
     * @return
     */
    public static boolean isMergedRegion(Sheet sheet, int row, int column) {
        int sheetMergeCount = sheet.getNumMergedRegions();
        for (int i = 0; i &lt; sheetMergeCount; i++) {
            CellRangeAddress range = sheet.getMergedRegion(i);
            int firstColumn = range.getFirstColumn();
            int lastColumn = range.getLastColumn();
            int firstRow = range.getFirstRow();
            int lastRow = range.getLastRow();
            if (row &gt;= firstRow &amp;&amp; row &lt;= lastRow) {
                if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) {
                    return true;
                }
            }
        }
        return false;
    }
</code></pre>
<p>页面部分分为三步：<br>1、上传文件<br><img src="excel-upload-1.png" alt="导入第一步"><br>2、设置数据更新方式<br><img src="excel-upload-2.png" alt="导入第二步"><br>3、提示（比如说Excel中有重复记录，也需要提示出来，让用户修改后重新导入）<br><img src="excel-upload-3.png" alt="导入第三步"></p>
<p>#结语<br>记录备忘之。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;poi-是什么呢&quot;&gt;&lt;a href=&quot;#poi-是什么呢&quot; class=&quot;headerlink&quot; title=&quot;poi 是什么呢&quot;&gt;&lt;/a&gt;poi 是什么呢&lt;/h1&gt;&lt;p&gt;Apache POI 简介是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对Microsoft Office（Excel、WORD、PowerPoint、Visio等）格式档案读和写的功能。POI为“Poor Obfuscation Implementation”的首字母缩写，意为“可怜的模糊实现”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Excel" scheme="//zeroto.tech/tags/Excel/"/>
    
      <category term="poi" scheme="//zeroto.tech/tags/poi/"/>
    
  </entry>
  
  <entry>
    <title>itext实现录取通知书、成绩单</title>
    <link href="//zeroto.tech/2017/07/03/itext-how/"/>
    <id>//zeroto.tech/2017/07/03/itext-how/</id>
    <published>2017-07-03T07:21:25.000Z</published>
    <updated>2018-03-12T06:46:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="itext5、jfreechart生成成绩分析图表，并写入成绩单pdf"><a href="#itext5、jfreechart生成成绩分析图表，并写入成绩单pdf" class="headerlink" title="itext5、jfreechart生成成绩分析图表，并写入成绩单pdf"></a>itext5、jfreechart生成成绩分析图表，并写入成绩单pdf</h2><p>浏览器中展示图表，一般都是用百度的<a href="http://echarts.baidu.com/" target="_blank" rel="external">ECharts</a>来展现。<br>但是后台导出成绩单，必须要绕过浏览器才最方便。</p>
<a id="more"></a>
<p>在maven中引入itext5、jfreechart、ssj</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
  &lt;artifactId&gt;itextpdf&lt;/artifactId&gt;
  &lt;version&gt;5.5.10&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
  &lt;artifactId&gt;itext-pdfa&lt;/artifactId&gt;
  &lt;version&gt;5.5.10&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
  &lt;artifactId&gt;itext-xtra&lt;/artifactId&gt;
  &lt;version&gt;5.5.10&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.itextpdf.tool&lt;/groupId&gt;
  &lt;artifactId&gt;xmlworker&lt;/artifactId&gt;
  &lt;version&gt;5.5.10&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
    &lt;artifactId&gt;itext-asian&lt;/artifactId&gt;
    &lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
 &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
 &lt;artifactId&gt;commons-math3&lt;/artifactId&gt;
 &lt;version&gt;3.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.jfree&lt;/groupId&gt;
    &lt;artifactId&gt;jfreechart&lt;/artifactId&gt;
    &lt;version&gt;1.0.14&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
           &lt;groupId&gt;com.lowagie&lt;/groupId&gt;
           &lt;artifactId&gt;itext&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;ca.umontreal.iro.simul&lt;/groupId&gt;
    &lt;artifactId&gt;ssj&lt;/artifactId&gt;
    &lt;version&gt;3.2.1&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
             &lt;groupId&gt;jfree&lt;/groupId&gt;
             &lt;artifactId&gt;jfreechart&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>示例如图：<br><img src="/assets/blogImg/itext5_1.png" alt="itext5_1"></p>
<p>中位数、标准差、峰度、偏度等使用 org.apache.commons.math3.analysis.function.*<br>直接函数调用，很方便。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>菜头叔每篇公号文章都有个 <strong>禅定时刻</strong>，很是喜欢。在此有样学样吧。</p>
<p>一个酒鬼的自述<br>“一个人活得拧巴是值得理解的，甚至是值得赞美的，这证明他内心还有冲突，并不甘于和人生妥协。但是，通过酒来发泄显得太过脆弱而虚伪，且对不起那瓶好酒。酒带给人们的应该是被压抑的快乐，而不是被压抑的痛苦。”</p>
<p>不是酒鬼，不咋饮酒，但是挺喜欢这句话。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;itext5、jfreechart生成成绩分析图表，并写入成绩单pdf&quot;&gt;&lt;a href=&quot;#itext5、jfreechart生成成绩分析图表，并写入成绩单pdf&quot; class=&quot;headerlink&quot; title=&quot;itext5、jfreechart生成成绩分析图表，并写入成绩单pdf&quot;&gt;&lt;/a&gt;itext5、jfreechart生成成绩分析图表，并写入成绩单pdf&lt;/h2&gt;&lt;p&gt;浏览器中展示图表，一般都是用百度的&lt;a href=&quot;http://echarts.baidu.com/&quot;&gt;ECharts&lt;/a&gt;来展现。&lt;br&gt;但是后台导出成绩单，必须要绕过浏览器才最方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iText" scheme="//zeroto.tech/tags/iText/"/>
    
      <category term="jfreechart" scheme="//zeroto.tech/tags/jfreechart/"/>
    
  </entry>
  
  <entry>
    <title>Mac上使用Homebrew进行MySQL卸载、安装，解决乱码</title>
    <link href="//zeroto.tech/2017/06/22/MySQL-how/"/>
    <id>//zeroto.tech/2017/06/22/MySQL-how/</id>
    <published>2017-06-22T05:17:06.000Z</published>
    <updated>2018-03-12T03:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac上使用Homebrew进行MySQL卸载、安装，解决乱码"><a href="#Mac上使用Homebrew进行MySQL卸载、安装，解决乱码" class="headerlink" title="Mac上使用Homebrew进行MySQL卸载、安装，解决乱码"></a>Mac上使用Homebrew进行MySQL卸载、安装，解决乱码</h1><h2 id="Mac上使用Homebrew进行MySQL卸载"><a href="#Mac上使用Homebrew进行MySQL卸载" class="headerlink" title="Mac上使用Homebrew进行MySQL卸载"></a>Mac上使用Homebrew进行MySQL卸载</h2><p><strong>系统环境</strong></p>
<blockquote>
<p>Mac 10.12<br>Homebrew 1.2.3<br>MySQL 5.6.36_1<br><a id="more"></a><br><strong>homebrew 卸载</strong></p>
</blockquote>
<pre><code class="bash">$ brew remove mysql@5.6
$ brew cleanup
$ launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql@5.6.plist
</code></pre>
<p><strong>删除文件</strong></p>
<pre><code class="bash">$ sudo rm -f /etc/my.cnf
$ sudo rm -rf /usr/local/var/mysql
$ sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql@5.6.plist
</code></pre>
<h2 id="Mac上使用Homebrew安装MySQL"><a href="#Mac上使用Homebrew安装MySQL" class="headerlink" title="Mac上使用Homebrew安装MySQL"></a>Mac上使用Homebrew安装MySQL</h2><p>$ brew install mysql@5.6</p>
<h3 id="让-MySQL-开机自行启动"><a href="#让-MySQL-开机自行启动" class="headerlink" title="让 MySQL 开机自行启动"></a>让 MySQL 开机自行启动</h3><pre><code class="bash">$ ln -sfv /usr/local/opt/mysql@5.6/*.plist ~/Library/LaunchAgents
$ sudo find /usr/local/Cellar/mysql@5.6/5.6.36_1/ -name &quot;homebrew.mxcl.mysql@5.6.plist&quot; -exec cp {} ~/Library/LaunchAgents/ \;
$ launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql@5.6.plist
</code></pre>
<h3 id="指定MySQL数据存放路径"><a href="#指定MySQL数据存放路径" class="headerlink" title="指定MySQL数据存放路径"></a>指定MySQL数据存放路径</h3><pre><code class="bash">$ mysql_install_db --verbose --user=`whoami` --basedir=&quot;/usr/local/Cellar/mysql@5.6/5.6.36_1&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp
$ cd . ; /usr/local/Cellar/mysql@5.6/5.6.36_1/bin/mysqld_safe &amp;
</code></pre>
<h2 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h2><h3 id="修改-etc-my-cnf，没有就从MySQL安装目录拷贝一个模板过来。"><a href="#修改-etc-my-cnf，没有就从MySQL安装目录拷贝一个模板过来。" class="headerlink" title="修改 /etc/my.cnf，没有就从MySQL安装目录拷贝一个模板过来。"></a>修改 /etc/my.cnf，没有就从MySQL安装目录拷贝一个模板过来。</h3><pre><code># For advice on how to change settings please see
# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html


[mysqld]
port=3306
datadir=/usr/local/var/mysql


# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M

# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin

# These are commonly set, remove the # and set as required.
# basedir = .....
# datadir = .....
# port = .....
# server_id = .....
# socket = .....

# Remove leading # to set options mainly useful for reporting servers.
</code></pre><h3 id="将mysql加入系统环境变量"><a href="#将mysql加入系统环境变量" class="headerlink" title="将mysql加入系统环境变量"></a>将mysql加入系统环境变量</h3><p>执行vim ~/.bash_profile<br>在该文件中添加如下语句，完成后，按esc，然后输入wq保存。<br>export PATH=/usr/local/opt/mysql@5.6/bin:$PATH<br>最后在命令行输入source ~/.bash_profile</p>
<p>ok ,可以启动MySQL了。<br>$ mysql.server start<br>权限配置参见官网：<br><a href="https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html</a></p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>默认是没有密码的，进去mysql后，执行语句：</p>
<pre><code class="bash">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;root&#39;);
Query OK, 0 rows affected (0.01 sec)
</code></pre>
<p>接下来使用密码登录MySQL：</p>
<pre><code class="bash">$ mysql -uroot -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 395
Server version: 5.6.36 Homebrew

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&gt; show variables like &#39;character%&#39;;
+--------------------------+------------------------------------------------------------+
| Variable_name            | Value                                                      |
+--------------------------+------------------------------------------------------------+
| character_set_client     | utf8                                                       |
| character_set_connection | utf8                                                       |
| character_set_database   | utf8                                                       |
| character_set_filesystem | binary                                                     |
| character_set_results    | utf8                                                       |
| character_set_server     | utf8                                                       |
| character_set_system     | utf8                                                       |
| character_sets_dir       | /usr/local/Cellar/mysql@5.6/5.6.36_1/share/mysql/charsets/ |
+--------------------------+------------------------------------------------------------+
8 rows in set (0.04 sec)
</code></pre>
<p>看到utf8，编码就不会出问题了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>之所以写这篇，原因是从Windows转到Mac环境搞开发，碰到了乱码问题，各种配置都试了也没解决。卸载重装妥妥的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac上使用Homebrew进行MySQL卸载、安装，解决乱码&quot;&gt;&lt;a href=&quot;#Mac上使用Homebrew进行MySQL卸载、安装，解决乱码&quot; class=&quot;headerlink&quot; title=&quot;Mac上使用Homebrew进行MySQL卸载、安装，解决乱码&quot;&gt;&lt;/a&gt;Mac上使用Homebrew进行MySQL卸载、安装，解决乱码&lt;/h1&gt;&lt;h2 id=&quot;Mac上使用Homebrew进行MySQL卸载&quot;&gt;&lt;a href=&quot;#Mac上使用Homebrew进行MySQL卸载&quot; class=&quot;headerlink&quot; title=&quot;Mac上使用Homebrew进行MySQL卸载&quot;&gt;&lt;/a&gt;Mac上使用Homebrew进行MySQL卸载&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mac 10.12&lt;br&gt;Homebrew 1.2.3&lt;br&gt;MySQL 5.6.36_1&lt;br&gt;
    
    </summary>
    
    
      <category term="Homebrew" scheme="//zeroto.tech/tags/Homebrew/"/>
    
      <category term="MySQL" scheme="//zeroto.tech/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker初探</title>
    <link href="//zeroto.tech/2017/06/16/docker-how-1/"/>
    <id>//zeroto.tech/2017/06/16/docker-how-1/</id>
    <published>2017-06-16T06:04:53.000Z</published>
    <updated>2018-03-12T03:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始容器与Docker"><a href="#初始容器与Docker" class="headerlink" title="初始容器与Docker"></a>初始容器与Docker</h1><p><a href="https://docs.docker.com/engine/docker-overview/" target="_blank" rel="external">https://docs.docker.com/engine/docker-overview/</a></p>
<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><h3 id="Docker开源项目背景"><a href="#Docker开源项目背景" class="headerlink" title="Docker开源项目背景"></a>Docker开源项目背景</h3><p>Docker是基于Go语言实现的开源容器项目，诞生于2013年年初，最初发起者是dotCloud公司。Docker自开源后受到广泛的关注和讨论，目前已有多个相关项目（包括Docker三剑客、Kubernetes等），逐渐形成了围绕Docker容器的生态体系。<br>由于Docker在业界造成的影响力实在太大，dotCloud公司后来也直接改名为Docker Inc，并专注于Docker相关技术和产品的开发。</p>
<p>对于Docker，目前的定义是一个开源的容器引擎，可以方便地对容器（关于容器，将在第2章详细介绍）进行管理。其对镜像的打包封装，以及引入的Docker Registry对镜像的统一管理，构建了方便快捷的“Build，Ship and Run”流程，它可以统一整个开发、测试和部署的环境和流程，极大地减少运维成本。<br><a id="more"></a></p>
<h3 id="Docker在开发和运维中的优势"><a href="#Docker在开发和运维中的优势" class="headerlink" title="Docker在开发和运维中的优势"></a>Docker在开发和运维中的优势</h3><p>对开发和运维（DevOps）人员来说，可能最梦寐以求的效果就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行。</p>
<p>1.更快速的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同环境来部署代码。只要开发测试过的代码，就可以确保在生产环境无缝运行。Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。<br>2.更高效的资源利用。Docker容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager以及Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。<br>3.更轻松的迁移和扩展。<br>4.更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>1.Docker镜像<br>镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像。<br>与容器相对应，如果说容器提供了一个完整的、隔离的运行环境，那么镜像则是这个运行环境的静态体现，是一个还没有运行起来的“运行环境”。<br>Docker镜像通常是通过Dockerfile来创建的，Dockerfile提供了镜像内容的定制，同时也体现了层级关系的建立。</p>
<p>ps:镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。<br>2.Docker容器<br>在功能上，Docker通过Libcontainer实现对容器生命周期的管理、信息的设置和查询，以及监控和通信等功能。而容器也是对镜像的完美诠释，容器以镜像为基础，同时又为镜像提供了一个标准的和隔离的执行环境。<br>在概念上，容器则很好地诠释了Docker集装箱的理念，集装箱可以存放任何货物，可以通过邮轮将货物运输到世界各地。运输集装箱的邮轮和装载卸载集装箱的码头都不用关心集装箱里的货物，这是一种标准的集装和运输方式。类似的，Docker的容器就是“软件界的集装箱”，它可以安装任意的软件和库文件，做任意的运行环境配置。</p>
<p>3.Docker仓库<br>是Docker集中存放镜像文件的场所。</p>
<h2 id="Install-Docker-for-Mac"><a href="#Install-Docker-for-Mac" class="headerlink" title="Install Docker for Mac"></a>Install Docker for Mac</h2><p><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="external">https://docs.docker.com/docker-for-mac/install/</a></p>
<pre><code class="bash">~ docker version
Client:
 Version:      17.03.1-ce
 API version:  1.27
 Go version:   go1.7.5
 Git commit:   c6d412e
 Built:        Tue Mar 28 00:40:02 2017
 OS/Arch:      darwin/amd64

Server:
 Version:      17.03.1-ce
 API version:  1.27 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   c6d412e
 Built:        Fri Mar 24 00:00:50 2017
 OS/Arch:      linux/amd64
 Experimental: true
</code></pre>
<p>我们看到Client和Server均有输出，则说明Docker for Mac已经正常启动。</p>
<h2 id="CentOS环境下安装Docker"><a href="#CentOS环境下安装Docker" class="headerlink" title="CentOS环境下安装Docker"></a>CentOS环境下安装Docker</h2><p>OS requirements<br>To install Docker, you need the 64-bit version of CentOS 7.<br>我是在Mac上安装的VirtualBox，然后装上CentOS 7镜像。</p>
<p>对于CentOS 7系统，CentOS-Extras源中已内置Docker</p>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><pre><code class="bash">[root@centos-docker yum.repos.d]# sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#39;EOF&#39;
&gt; [dockerrepo]
&gt; name=Docker Repository
&gt; baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/
&gt; enabled=1
&gt; gpgcheck=1
&gt; gpgkey=https://yum.dockerproject.org/gpg
&gt; EOF
</code></pre>
<p>之后更新yum软件源缓存，并安装docker-engine 即可。</p>
<pre><code class="bash">$ sudo yum install -y yum-utils
$ sudo yum update
$ sudo yum makecache fast
$ sudo yum install docker-engine
</code></pre>
<p>这是最新的版本。要想随意指定要安装的版本，如下命令，官网上如下。<br>1.List the available versions:</p>
<p>$ yum list docker-engine.x86_64  –showduplicates |sort -r</p>
<p>2.Install a specific version by adding the version after docker-engine, separated by a hyphen (-):<br>$ sudo yum install docker-engine-version</p>
<h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><p>1.更新系统包到最新。<br>$ yum -y update</p>
<p>2.执行Docker安装脚本</p>
<pre><code class="bash">$ curl -fsSL https://get.docker.com/ | sh
</code></pre>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>Docker Hub 镜像站点</p>
<p>安装／升级你的Docker客户端<br>您可以通过阿里云的镜像仓库下载：mirrors.aliyun.com/help/docker-engine</p>
<p>或执行以下命令：</p>
<pre><code class="bash">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -
</code></pre>
<p>如何使用Docker加速器<br>针对Docker客户端版本大于1.10的用户</p>
<p>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：</p>
<p>sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’<br>{<br>  “registry-mirrors”: [“<a href="https://wgqgbfsb.mirror.aliyuncs.com" target="_blank" rel="external">https://wgqgbfsb.mirror.aliyuncs.com</a>“]<br>}<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker</p>
<p>镜像是运行容器的前提，官方的Docker Hub网站已经提供了数十万个镜像供大家开放下载。<br>可以使用docker pull命令直接从Docker Hub镜像源来下载镜像。该命令的格式为docker pull NAME[：TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。</p>
<p>现在想要获得centos的Docker镜像，<br>1.docker search –no-trunc centos<br>2.docker pull  docker.io/jdeathe/centos-ssh</p>
<h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><p>1.使用images命令列出镜像<br>2.使用tag命令添加镜像标签<br>3.使用inspect命令查看详细信息<br>4.使用history命令查看镜像历史(docker history –no-trunc centos-ssh)</p>
<h3 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h3><p>使用docker search命令可以搜索远端仓库中共享的镜像，默认搜索官方仓库中的镜像。用法为docker search TERM，支持的参数主要包括：<br>·–automated=true|false：仅显示自动创建的镜像，默认为否；<br>·–no-trunc=true|false：输出信息不截断显示，默认为否；<br>·–filter=stars=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像。<br>例如：</p>
<pre><code>$ docker search --filter=stars=3 ubuntu
$ docker search -f stars=25 centos
</code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>使用标签删除镜像<br>使用docker rmi命令可以删除镜像，命令格式为docker rmi IMAGE[IMAGE…]，其中IMAGE可以为标签或ID。</p>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>创建镜像的方法主要有三种：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。<br>本节将重点介绍前两种方法。最后一种基于Dockerfile创建的方法将在后续章节专门予以详细介绍。</p>
<h4 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h4><p>该方法主要是使用docker commit命令。命令格式为docker commit[OPTIONS]CONTAINER[REPOSITORY[：TAG]]，主要选项包括：<br>·-a，–author=””：作者信息；<br>·-c，–change=[]：提交的时候执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等；<br>·-m，–message=””：提交消息；<br>·-p，–pause=true：提交时暂停容器运行。</p>
<h4 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h4><p>要直接导入一个镜像，可以使用OpenVZ提供的模板来创建，或者用其他已导出的镜像模板来创建。OPENVZ模板的下载地址为<a href="http://openvz.org/Download/templates/precreated" target="_blank" rel="external">http://openvz.org/Download/templates/precreated</a></p>
<h4 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h4><p>1.存出镜像</p>
<pre><code class="bash">[root@centos-docker docker]# docker save -o centos_7.tar.gz daocloud.io/centos:7
[root@centos-docker docker]# ls
centos_7.tar.gz  certs.d  daemon.json  key.json
</code></pre>
<p>2.载入镜像</p>
<pre><code class="bash">[root@centos-docker docker]# docker load --input centos_7.tar.gz
Loaded image: daocloud.io/centos:7
</code></pre>
<p>或者<br>$ docker load &lt; centos_7.tar.gz<br>这将导入镜像及其相关的元数据信息（包括标签等）。</p>
<h3 id="创建-amp-启动一个容器："><a href="#创建-amp-启动一个容器：" class="headerlink" title="创建&amp;启动一个容器："></a>创建&amp;启动一个容器：</h3><pre><code class="bash">$ docker run -d -p 10022:22 -v /dfile/:/dfile/ -h &quot;centos-d&quot; --name centos-d centos-ssh /usr/sbin/sshd -D

$ mount -t vboxsf docker_files /docker
</code></pre>
<pre><code class="bash">[root@centos-d /]# netstat -tunlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1/sshd
tcp6       0      0 :::22                   :::*                    LISTEN      1/sshd
</code></pre>
<p>其中10022是宿主主机的端口，22是容器的SSH服务监听端口：<br>-p 10022:22<br>使用HostPort：ContainerPort格式将本地的10022端口映射到容器的22端口。</p>
<p>在宿主主机或其他主机上，可以通过SSH访问10022端口来登录容器。</p>
<p>使用docker inspect来查看容器的基础信息。<br>参见：<a href="https://docs.docker.com/engine/reference/commandline/inspect/" target="_blank" rel="external">https://docs.docker.com/engine/reference/commandline/inspect/</a></p>
<p>-v /dfile(主机):/dfile(容器):ro<br>上面的命令加载主机的/dfile目录到容器的/dfile目录。<br>ps：本地目录的路径必须是绝对路径，如果目录不存在，Docker会自动创建。</p>
<p>Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读。</p>
<p>mount -t vboxsf the_share_name /a_folder_name<br>ps:VirtualBox与Mac共享文件夹为：docker_files<br><img src="VirtualBoxformac.png" alt="VirtualBoxformac"><br>ps: $ docker ps -a<br>查看容器。</p>
<pre><code class="bash">[root@centos-docker docker]# docker start centos-d
centos-d
[root@centos-docker docker]# docker ps -a
CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS                   PORTS                   NAMES
0ffb8ab3f777        centos-ssh          &quot;/usr/sbin/sshd -D&quot;   11 weeks ago        Up 12 seconds            0.0.0.0:10022-&gt;22/tcp   centos-d
</code></pre>
<p>$ docker-enter centos-d 进入容器。<br>可以按Ctrl+d或输入exit命令来退出容器，<br>通过exit命令或Ctrl+d来退出终端时，所创建的容器立刻终止，处于stopped状态。</p>
<h4 id="利用ssh进入到docker中的centos里"><a href="#利用ssh进入到docker中的centos里" class="headerlink" title="利用ssh进入到docker中的centos里"></a>利用ssh进入到docker中的centos里</h4><p>然后 我们试着从宿主机直接进入到docker中的centos里：</p>
<pre><code class="bash">~ ssh root@192.168.99.100 -p 10022
root@192.168.99.100&#39;s password:
Last login: Thu Jun 29 09:03:57 2017 from 192.168.99.1
[root@centos-d ~]#
</code></pre>
<p>避免了先进入虚拟机系统，然后再进入docker中的centos里：</p>
<pre><code class="bash">~ ssh root@192.168.99.100 -p 22
root@192.168.99.100&#39;s password:
Last login: Thu Jun 29 17:11:29 2017 from 192.168.99.1
[root@centos-docker ~]# docker-enter centos-d
Last login: Thu Jun 29 09:21:21 UTC 2017 from 192.168.99.1 on pts/0
[root@centos-d ~]#
</code></pre>
<h4 id="create命令与容器运行模式相关的选项"><a href="#create命令与容器运行模式相关的选项" class="headerlink" title="create命令与容器运行模式相关的选项"></a>create命令与容器运行模式相关的选项</h4><p>-d, –detach=true|false (是否在后台运行容器，默认为否)<br>-P, –publish-all=true|false (通过NAT机制将容器标记暴露的端口自动映射到本地主机的临时端口)<br>-p, –publish=[] (指定如何映射到本地主机端口)<br>–rm=true|false （容器退出后是否自动删除，不能跟-d同时使用）<br>-i, –interactive=true|false (保持标准输入打开，默认为false)<br>-t, –tty=true|false (是否分配一个伪终端，默认是false)<br>–expose=[] (指定容器会暴露出来的端口或端口范围)<br>–group-add=[] (运行容器的用户组)<br>-v|–volume[=[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]] (挂载主机上的文件卷到容器内)<br>-w, –workdir=”” (容器内的默认工作目录)</p>
<h4 id="create命令与容器环境和配置相关的选项"><a href="#create命令与容器环境和配置相关的选项" class="headerlink" title="create命令与容器环境和配置相关的选项"></a>create命令与容器环境和配置相关的选项</h4><p>–add-host=[] (在容器内添加一个主机名到IP地址的映射关系（通过/etc/hosts文件）)<br>-h, –hostname=”” (指定容器内的主机名)<br>–name=”” (指定容器的别名)</p>
<h4 id="create命令与容器资源限制和安全保护相关的选项"><a href="#create命令与容器资源限制和安全保护相关的选项" class="headerlink" title="create命令与容器资源限制和安全保护相关的选项"></a>create命令与容器资源限制和安全保护相关的选项</h4><p>–privileged=true|false (是否给容器以高权限，这意味着容器内应用将不受权限下限制，一般不推荐)<br>–read-only=true|false (是否让容器内的文件系统只读)</p>
<h4 id="启动容器说明"><a href="#启动容器说明" class="headerlink" title="启动容器说明"></a>启动容器说明</h4><p>当利用docker run来创建并启动容器时，Docker在后台运行的标准操作包括：</p>
<p>·检查本地是否存在指定的镜像，不存在就从公有仓库下载；<br>·利用镜像创建一个容器，并启动该容器；<br>·分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；<br>·从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；<br>·从网桥的地址池配置一个IP地址给容器；<br>·执行用户指定的应用程序；<br>·执行完毕后容器被自动终止。</p>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用docker stop来终止一个运行中的容器。该命令的格式为docker stop[-t|–time[=10]][CONTAINER…]。<br>首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。<br>这个时候如果需要进入容器进行操作，有多种方法，包括使用官方的attach或exec命令，以及第三方的nsenter工具等。下面分别介绍一下。</p>
<h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h4><p>attach是Docker自带的命令，命令格式为：</p>
<p>支持三个主要选项：<br>·–detach-keys[=[]]：指定退出attach模式的快捷键序列，默认是CTRL-p CTRL-q；<br>·–no-stdin=true|false：是否关闭标准输入，默认是保持打开；<br>·–sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认为true。<br>ps:当多个窗口同时用attach命令连到同一个容器的时候，所有窗口都会同步显示。不常用。</p>
<h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p>Docker从1.3.0版本起提供了一个更加方便的exec命令，可以在容器内直接执行任意命令。<br>比较重要的参数有：<br>·-i，–interactive=true|false：打开标准输入接受用户输入命令，默认为false；<br>·–privileged=true|false：是否给执行命令以高权限，默认为false；<br>·-t，–tty=true|false：分配伪终端，默认为false；<br>·-u，–user=””：执行命令的用户名或ID。<br>例如进入到刚创建的容器中，并启动一个bash：</p>
<pre><code class="bash">[root@centos-docker docker]# docker exec -it centos-d /bin/bash
[root@centos-d /]# pwd
/
</code></pre>
<p>可以看到，一个bash终端打开了，在不影响容器内其他应用的前提下，用户可以很容易与容器进行交互。<br>注意<br>通过指定-it参数来保持标准输入打开，并且分配一个伪终端。通过exec命令对容器执行操作是最为推荐的方式。</p>
<h4 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h4><p>在util-linux软件包版本2.23+中包含nsenter工具。</p>
<pre><code class="bash">[root@centos-docker docker]# docker start centos-d
centos-d
[root@centos-docker docker]# docker ps
CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                   NAMES
0ffb8ab3f777        centos-ssh          &quot;/usr/sbin/sshd -D&quot;   11 weeks ago        Up 6 seconds        0.0.0.0:10022-&gt;22/tcp   centos-d
[root@centos-docker docker]# PID=$(docker inspect --format &quot;{{ .State.Pid }}&quot; centos-d)
[root@centos-docker docker]# nsenter --target $PID --mount --uts --ipc --net --pid
[root@centos-d /]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 06:04 ?        00:00:00 /usr/sbin/sshd -D
root         5     0  0 06:07 ?        00:00:00 -bash
root        19     5  0 06:09 ?        00:00:00 ps -ef
</code></pre>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用docker rm命令来删除处于终止或退出状态的容器，命令格式为docker rm[-f|–force][-l|–link][-v|–volumes]CONTAINER[CONTAINER…]。<br>主要支持的选项包括：<br>·-f，–force=false：是否强行终止并删除一个运行中的容器；<br>·-l，–link=false：删除容器的连接，但保留容器；<br>·-v，–volumes=false：删除容器挂载的数据卷。</p>
<h3 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><p>某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用Docker的导入和导出功能。这也是Docker自身提供的一个重要特性。</p>
<h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令，该命令的格式为docker export[-o|–output[=””]]CONTAINER。其中，可以通过-o选项来指定导出的tar文件名，也可以直接通过重定向来实现。<br>ps:实现容器的迁移</p>
<pre><code class="bash">[root@centos-docker docker]# docker export -o test_centos-d.tar.gz centos-d
[root@centos-docker docker]# ls
a.txt  b.txt  c.txt  epel-release-7-9.noarch.rpm  test_centos-d.tar.gz
[root@centos-docker docker]# docker export centos-d &gt;test2_centos-d.tar.gz
[root@centos-docker docker]# ls
a.txt  b.txt  c.txt  epel-release-7-9.noarch.rpm  test2_centos-d.tar.gz  test_centos-d.tar.gz
</code></pre>
<p>实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。<br>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>参考在此：<a href="https://read.douban.com/reader/ebook/30546100/" target="_blank" rel="external">Docker技术入门与实践</a><br><a href="https://read.douban.com/reader/ebook/17825949/" target="_blank" rel="external">Docker进阶与实战</a> 作者：华为Docker实践小组</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初始容器与Docker&quot;&gt;&lt;a href=&quot;#初始容器与Docker&quot; class=&quot;headerlink&quot; title=&quot;初始容器与Docker&quot;&gt;&lt;/a&gt;初始容器与Docker&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/docker-overview/&quot;&gt;https://docs.docker.com/engine/docker-overview/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h2&gt;&lt;h3 id=&quot;Docker开源项目背景&quot;&gt;&lt;a href=&quot;#Docker开源项目背景&quot; class=&quot;headerlink&quot; title=&quot;Docker开源项目背景&quot;&gt;&lt;/a&gt;Docker开源项目背景&lt;/h3&gt;&lt;p&gt;Docker是基于Go语言实现的开源容器项目，诞生于2013年年初，最初发起者是dotCloud公司。Docker自开源后受到广泛的关注和讨论，目前已有多个相关项目（包括Docker三剑客、Kubernetes等），逐渐形成了围绕Docker容器的生态体系。&lt;br&gt;由于Docker在业界造成的影响力实在太大，dotCloud公司后来也直接改名为Docker Inc，并专注于Docker相关技术和产品的开发。&lt;/p&gt;
&lt;p&gt;对于Docker，目前的定义是一个开源的容器引擎，可以方便地对容器（关于容器，将在第2章详细介绍）进行管理。其对镜像的打包封装，以及引入的Docker Registry对镜像的统一管理，构建了方便快捷的“Build，Ship and Run”流程，它可以统一整个开发、测试和部署的环境和流程，极大地减少运维成本。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="//zeroto.tech/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Systemd 入门教程：命令篇</title>
    <link href="//zeroto.tech/2017/05/25/systemd/"/>
    <id>//zeroto.tech/2017/05/25/systemd/</id>
    <published>2017-05-25T09:59:57.000Z</published>
    <updated>2018-03-12T03:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Systemd-入门教程：命令篇"><a href="#Systemd-入门教程：命令篇" class="headerlink" title="Systemd 入门教程：命令篇"></a>Systemd 入门教程：命令篇</h1><p>Systemd 是 Linux 系统工具，用来启动<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="external">守护进程</a>，已成为大多数发行版的标准配置。</p>
<p>本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。</p>
<a id="more"></a>
<h2 id="一、由来"><a href="#一、由来" class="headerlink" title="一、由来"></a>一、由来</h2><p>历史上，<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="external">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="external"><code>init</code></a>进程。</p>
<p>下面的命令用来启动服务。</p>
<pre><code class="bash">[root@localhost /]# service httpd start
Redirecting to /bin/systemctl start  httpd.service
</code></pre>
<p>ps:Centos7已经不支持了喔！</p>
<p>这种方法有两个缺点。</p>
<p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p>
<p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>
<h2 id="二、Systemd-概述"><a href="#二、Systemd-概述" class="headerlink" title="二、Systemd 概述"></a>二、Systemd 概述</h2><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p>
<p>根据 Linux 惯例，字母<code>d</code>是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030702.jpg" alt=""></p>
<p>（上图为 Systemd 作者 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering" target="_blank" rel="external">Lennart Poettering</a>）</p>
<p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>
<pre><code class="bash">$ systemctl --version
</code></pre>
<p>上面的命令查看 Systemd 的版本。</p>
<p>Systemd 的优点是功能强大，使用方便，缺点是系统庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反“keep simple, keep stupid”的<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="external">Unix 哲学</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt=""></p>
<p>（上图为 Systemd 架构图）</p>
<h2 id="三、系统管理"><a href="#三、系统管理" class="headerlink" title="三、系统管理"></a>三、系统管理</h2><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<h3 id="3-1-systemctl"><a href="#3-1-systemctl" class="headerlink" title="3.1 systemctl"></a>3.1 systemctl</h3><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p>
<pre><code class="bash"># 重启系统
$ sudo systemctl reboot

# 关闭系统，切断电源
$ sudo systemctl poweroff

# CPU停止工作
$ sudo systemctl halt

# 暂停系统
$ sudo systemctl suspend

# 让系统进入冬眠状态
$ sudo systemctl hibernate

# 让系统进入交互式休眠状态
$ sudo systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
$ sudo systemctl rescue
</code></pre>
<h3 id="3-2-systemd-analyze"><a href="#3-2-systemd-analyze" class="headerlink" title="3.2 systemd-analyze"></a>3.2 systemd-analyze</h3><p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<pre><code class="bash"># 查看启动耗时
$ systemd-analyze                                                                                       

# 查看每个服务的启动耗时
$ systemd-analyze blame

# 显示瀑布状的启动过程流
$ systemd-analyze critical-chain

# 显示指定服务的启动流(eg:sshd.service)
$ systemd-analyze critical-chain sshd.service
</code></pre>
<h3 id="3-3-hostnamectl"><a href="#3-3-hostnamectl" class="headerlink" title="3.3 hostnamectl"></a>3.3 hostnamectl</h3><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<pre><code class="bash"># 显示当前主机的信息
$ hostnamectl

# 设置主机名。
$ sudo hostnamectl set-hostname CentOS-Docker
</code></pre>
<h3 id="3-4-localectl"><a href="#3-4-localectl" class="headerlink" title="3.4 localectl"></a>3.4 localectl</h3><p><code>localectl</code>命令用于查看本地化设置。</p>
<pre><code class="bash"># 查看本地化设置
$ localectl

# 设置本地化参数。
$ sudo localectl set-locale LANG=zh_CN.UTF-8
$ sudo localectl set-keymap cn
</code></pre>
<h3 id="3-5-timedatectl"><a href="#3-5-timedatectl" class="headerlink" title="3.5 timedatectl"></a>3.5 timedatectl</h3><p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<pre><code class="bash"># 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone America/New_York
</code></pre>
<h3 id="3-6-loginctl"><a href="#3-6-loginctl" class="headerlink" title="3.6 loginctl"></a>3.6 loginctl</h3><p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<pre><code class="bash"># 列出当前session
$ loginctl list-sessions

# 列出当前登录用户
$ loginctl list-users

# 列出显示指定用户的信息
$ loginctl show-user root
</code></pre>
<h2 id="四、Unit"><a href="#四、Unit" class="headerlink" title="四、Unit"></a>四、Unit</h2><h3 id="4-1-含义"><a href="#4-1-含义" class="headerlink" title="4.1 含义"></a>4.1 含义</h3><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<p>Unit 一共分成12种。</p>
<blockquote>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
</blockquote>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>
<pre><code class="bash"># 列出正在运行的 Unit
$ systemctl list-units

# 列出所有Unit，包括没有找到配置文件的或者启动失败的
$ systemctl list-units --all

# 列出所有没有运行的 Unit
$ systemctl list-units --all --state=inactive

# 列出所有加载失败的 Unit
$ systemctl list-units --failed

# 列出所有正在运行的、类型为 service 的 Unit
$ systemctl list-units --type=service
</code></pre>
<h3 id="4-2-Unit-的状态"><a href="#4-2-Unit-的状态" class="headerlink" title="4.2 Unit 的状态"></a>4.2 Unit 的状态</h3><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>
<pre><code class="bash"># 显示系统状态
$ systemctl status

# 显示单个 Unit 的状态
$ sysystemctl status httpd.service

# 显示远程主机的某个 Unit 的状态
$ systemctl -H root@rhel7.example.com status httpd.service
</code></pre>
<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<pre><code class="bash"># 显示某个 Unit 是否正在运行
$ systemctl is-active httpd.service

# 显示某个 Unit 是否处于启动失败状态
$ systemctl is-failed httpd.service

# 显示某个 Unit 服务是否建立了启动链接
$ systemctl is-enabled httpd.service
</code></pre>
<h3 id="4-3-Unit-管理"><a href="#4-3-Unit-管理" class="headerlink" title="4.3 Unit 管理"></a>4.3 Unit 管理</h3><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<pre><code class="bash"># 立即启动一个服务
$ sudo systemctl start httpd.service
# 立即停止一个服务
$ sudo systemctl stop httpd.service
# 重启一个服务
$ sudo systemctl restart httpd.service
# 杀死一个服务的所有子进程
$ sudo systemctl kill httpd.service
# 重新加载一个服务的配置文件
$ sudo systemctl reload httpd.service
# 重载所有修改过的配置文件
$ sudo systemctl daemon-reload

# 显示某个 Unit 的所有底层参数
$ systemctl show httpd.service

# 显示某个 Unit 的指定属性的值
$ systemctl show -p CPUShares httpd.service
</code></pre>
<h3 id="4-4-依赖关系"><a href="#4-4-依赖关系" class="headerlink" title="4.4 依赖关系"></a>4.4 依赖关系</h3><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<pre><code class="bash">$ systemctl list-dependencies nginx.service
</code></pre>
<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>
<pre><code class="bash">$ systemctl list-dependencies --all nginx.service
</code></pre>
<h2 id="五、Unit-的配置文件"><a href="#五、Unit-的配置文件" class="headerlink" title="五、Unit 的配置文件"></a>五、Unit 的配置文件</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在这个目录。</p>
<p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p>
<pre><code class="bash">$ sudo systemctl enable sshd.service
# 等同于
$ sudo ln -s &#39;/usr/lib/systemd/system/sshd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/sshd.service&#39;
</code></pre>
<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<pre><code class="bash">$ sudo systemctl disable sshd.service
</code></pre>
<p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p>
<h3 id="5-2-配置文件的状态"><a href="#5-2-配置文件的状态" class="headerlink" title="5.2 配置文件的状态"></a>5.2 配置文件的状态</h3><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>
<pre><code class="bash"># 列出所有配置文件
$ systemctl list-unit-files

# 列出指定类型的配置文件
$ systemctl list-unit-files --type=service
</code></pre>
<p>这个命令会输出一个列表。</p>
<pre><code class="bash">$ systemctl list-unit-files

UNIT FILE              STATE
chronyd.service        enabled
clamd@.service         static
sshd.service     disabled
</code></pre>
<p>这个列表显示每个配置文件的状态，一共有四种。</p>
<blockquote>
<ul>
<li>enabled：已建立启动链接</li>
<li>disabled：没建立启动链接</li>
<li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
</blockquote>
<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>
<pre><code class="bash">$ systemctl status httpd.service
</code></pre>
<p>一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<pre><code class="bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart httpd.service
</code></pre>
<h3 id="5-3-配置文件的格式"><a href="#5-3-配置文件的格式" class="headerlink" title="5.3 配置文件的格式"></a>5.3 配置文件的格式</h3><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容。<br>注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<pre><code class="bash">[Section]
Directive1=value
Directive2=value

. . .
</code></pre>
<p>注意，键值对的等号两侧不能有空格。</p>
<h3 id="5-4-配置文件的区块"><a href="#5-4-配置文件的区块" class="headerlink" title="5.4 配置文件的区块"></a>5.4 配置文件的区块</h3><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Description</code>：简短描述</li>
<li><code>Documentation</code>：文档地址</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li>
<li><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li>
<li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</li>
<li><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
</blockquote>
<p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
</blockquote>
<p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Type</code>：定义启动时的进程行为。它有以下几种值。<ul>
<li><code>simple</code>：默认值，执行<code>ExecStart</code>指定的命令，启动主进程</li>
<li><code>forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>
<li><code>oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>
<li><code>dbus</code>：当前服务通过D-Bus启动</li>
<li><code>notify</code>：当前服务启动完毕，会通知<code>Systemd</code>，再继续往下执行</li>
<li><code>idle</code>：若有其他任务执行完毕，当前服务才会运行</li>
</ul>
</li>
<li><code>ExecStart</code>：启动当前服务的命令</li>
<li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li>
<li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li>
<li><code>ExecReload</code>：重启当前服务时执行的命令</li>
<li><code>ExecStop</code>：停止当前服务时执行的命令</li>
<li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li>
<li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括<code>always</code>（总是重启）、<code>on-success</code>、<code>on-failure</code>、<code>on-abnormal</code>、<code>on-abort</code>、<code>on-watchdog</code></li>
<li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li>
<li><code>Environment</code>：指定环境变量</li>
</ul>
</blockquote>
<p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="六、Target"><a href="#六、Target" class="headerlink" title="六、Target"></a>六、Target</h2><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于“状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<pre><code class="bash"># 查看当前系统的所有 Target
$ systemctl list-unit-files --type=target

# 查看一个 Target 包含的所有 Unit
$ systemctl list-dependencies multi-user.target

# 查看启动时的默认 Target
$ systemctl get-default

# 设置启动时的默认 Target
$ sudo systemctl set-default multi-user.target

# 切换 Target 时，默认不关闭前一个 Target 启动的进程，
# systemctl isolate 命令改变这种行为，
# 关闭前一个 Target 里面所有不属于后一个 Target 的进程
$ sudo systemctl isolate multi-user.target
</code></pre>
<p>Target 与 传统 RunLevel 的对应关系如下。</p>
<pre><code class="bash">Traditional runlevel      New target name     Symbolically linked to...

Runlevel 0           |    runlevel0.target -&gt; poweroff.target
Runlevel 1           |    runlevel1.target -&gt; rescue.target
Runlevel 2           |    runlevel2.target -&gt; multi-user.target
Runlevel 3           |    runlevel3.target -&gt; multi-user.target
Runlevel 4           |    runlevel4.target -&gt; multi-user.target
Runlevel 5           |    runlevel5.target -&gt; graphical.target
Runlevel 6           |    runlevel6.target -&gt; reboot.target
</code></pre>
<p>它与<code>init</code>进程的主要差别如下。</p>
<blockquote>
<p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p>
<p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
</blockquote>
<h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a>七、日志管理</h2><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<p><code>journalctl</code>功能强大，用法非常多。</p>
<pre><code class="bash"># 查看所有日志（默认情况下 ，只保存本次启动的日志）
$ sudo journalctl

# 查看内核日志（不显示应用日志）
$ sudo journalctl -k

# 查看系统本次启动的日志
$ sudo journalctl -b
$ sudo journalctl -b -0

# 查看上一次启动的日志（需更改设置）
$ sudo journalctl -b -1

# 查看指定时间的日志
$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;
$ sudo journalctl --since &quot;20 min ago&quot;
$ sudo journalctl --since yesterday
$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;

# 显示尾部的最新10行日志
$ sudo journalctl -n

# 显示尾部指定行数的日志
$ sudo journalctl -n 20

# 实时滚动显示最新日志
$ sudo journalctl -f

# 查看指定服务的日志
$ sudo journalctl /usr/lib/systemd/systemd

# 查看指定进程的日志
$ sudo journalctl _PID=1

# 查看某个路径的脚本的日志
$ sudo journalctl /usr/bin/bash

# 查看指定用户的日志
$ sudo journalctl _UID=33 --since today

# 查看某个 Unit 的日志
$ sudo journalctl -u nginx.service
$ sudo journalctl -u nginx.service --since today

# 实时滚动显示某个 Unit 的最新日志
$ sudo journalctl -u nginx.service -f

# 合并显示多个 Unit 的日志
$ journalctl -u nginx.service -u php-fpm.service --since today

# 查看指定优先级（及其以上级别）的日志，共有8级
# 0: emerg
# 1: alert
# 2: crit
# 3: err
# 4: warning
# 5: notice
# 6: info
# 7: debug
$ sudo journalctl -p err -b

# 日志默认分页输出，--no-pager 改为正常的标准输出
$ sudo journalctl --no-pager

# 以 JSON 格式（单行）输出
$ sudo journalctl -b -u nginx.service -o json

# 以 JSON 格式（多行）输出，可读性更好
$ sudo journalctl -b -u nginx.service -o json-pretty

# 显示日志占据的硬盘空间
$ sudo journalctl --disk-usage

# 指定日志文件占据的最大空间
$ sudo journalctl --vacuum-size=1G

# 指定日志文件保存多久
$ sudo journalctl --vacuum-time=1years
</code></pre>
<h2 id="八、结语"><a href="#八、结语" class="headerlink" title="八、结语"></a>八、结语</h2><p>转载于<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></p>
<p>引申阅读：</p>
<ul>
<li><a href="http://coolshell.cn/articles/17998.html" target="_blank" rel="external">LINUX PID 1 和 SYSTEMD</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Systemd-入门教程：命令篇&quot;&gt;&lt;a href=&quot;#Systemd-入门教程：命令篇&quot; class=&quot;headerlink&quot; title=&quot;Systemd 入门教程：命令篇&quot;&gt;&lt;/a&gt;Systemd 入门教程：命令篇&lt;/h1&gt;&lt;p&gt;Systemd 是 Linux 系统工具，用来启动&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html&quot;&gt;守护进程&lt;/a&gt;，已成为大多数发行版的标准配置。&lt;/p&gt;
&lt;p&gt;本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="//zeroto.tech/tags/Linux/"/>
    
      <category term="Systemd" scheme="//zeroto.tech/tags/Systemd/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记 - 基本操作</title>
    <link href="//zeroto.tech/2017/05/11/git-how/"/>
    <id>//zeroto.tech/2017/05/11/git-how/</id>
    <published>2017-05-11T09:57:29.000Z</published>
    <updated>2018-03-12T03:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Git 闲话</p>
<blockquote>
<p>1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。<br>2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。<br>“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“<br>只干了两件事啊，毫不夸张的说：惊天地泣鬼神。<br>第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。<br>再接下来，Git 就是我们的主题了，记录以备忘。</p>
</blockquote>
<a id="more"></a>
<h2 id="Git安装与配置"><a href="#Git安装与配置" class="headerlink" title="Git安装与配置"></a>Git安装与配置</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Mac 上brew安装算是最便捷的了</p>
<pre><code class="zsh">~ brew install git 
~ brew --version
Homebrew 1.1.13
Homebrew/homebrew-core (git revision ea163; last commit 2017-04-20)
~ git --version
git version 2.11.0
</code></pre>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>可以通过 git config –list –global 命令来查看：</p>
<pre><code class="zsh">~ git config --list --global
user.email=1250114609@qq.com
user.name=千古不见一人闲
color.ui=auto
alias.st=status
alias.lg=log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit
</code></pre>
<p>可以看到有两个alias出现，这里使用了别名。</p>
<p>配置别名</p>
<p>这个功能在shell中是很常用的。我们可以做一些别名来取代比较复杂的指令。<br>比如上面就是使用了以下两个配置</p>
<pre><code class="zsh">~ git config --global alias.st status

~ git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;
</code></pre>
<h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>当本地git仓库与git远程仓库通信的时候，需要进行SSH身份认证。<br>打开根目录下的.ssh目录：</p>
<pre><code class="zsh">~/.ssh la
.              ..             config         github_rsa     github_rsa.pub id_rsa         id_rsa.pub     known_hosts
</code></pre>
<p>如果没有id_rsa和id_rsa.pub这两个文件，就通过如下的命令生成：</p>
<p>ssh-keygen -t rsa -C “youremail@example.com”<br>id_rsa和id_rsa.pub这两个文件，就是SSH Key的秘钥对，id_rsa是私钥，id_rsa.pub是公钥，用在github上表明身份。<br>在GitHub上的SSH keys中添加刚刚生成的key。(id_rsa.pub)</p>
<h4 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h4><p>创建一个目录，并cd到目录下，通过调用git init来将现有目录初始化为git仓库，或者直接在git init后面跟上目录名，同样也可以创建一个新的仓库。</p>
<p>git clone 直接clone一个远程仓库也是可以的。</p>
<h4 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h4><pre><code class="zsh">~/Documents/workspace git_springboot
~/Documents/workspace/git_springboot(master ✔) la
.    ..   .git
~/Documents/workspace/git_springboot(master ✔) touch README.md
~/Documents/workspace/git_springboot(master ✗) vim README.md
~/Documents/workspace/git_springboot(master ✗) git add README.md
~/Documents/workspace/git_springboot(master ✗) git commit -m &quot;add README.md&quot;
[master be9081a] add README.md
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
~/Documents/workspace/git_springboot(master ✔)
</code></pre>
<h4 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h4><p>修改README.md文件，git st查看修改</p>
<pre><code class="zsh">~/Documents/workspace/git_springboot(master ✗) git st
On branch master
Your branch is ahead of &#39;origin/master&#39; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   README.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Git 比较不同版本文件差异的常用命令格式：</p>
<blockquote>
<p>git diff  查看尚未暂存的文件更新了哪些部分      </p>
<p>git diff filename 查看尚未暂存的某个文件更新了哪些</p>
<p>git diff –cached 查看已经暂存起来的文件和上次提交的版本之间的差异</p>
<p>git diff –cached filename 查看已经暂存起来的某个文件和上次提交的版本之间的差异</p>
</blockquote>
<p>使用git diff README.md 命令看一下修改的具体内容</p>
<blockquote>
<p>diff –git a/README.md b/README.md<br>index e8281cd..f1729fb 100644<br>— a/README.md<br>+++ b/README.md<br>@@ -1 +1 @@<br>-this’s ok.<br>+this’s ok,modify.</p>
</blockquote>
<p>add和commit之后，我们都使用status来查看下状态，可以发现，在commit之后，git提示我们，工作区是干净的。</p>
<pre><code class="zsh">~/Documents/workspace/git_springboot(master ✗) git st
On branch master
Your branch is ahead of &#39;origin/master&#39; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   README.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
~/Documents/workspace/git_springboot(master ✗) git add README.md
~/Documents/workspace/git_springboot(master ✗) git commit -m &quot;modify README.md&quot;
[master a77107b] modify README.md
 1 file changed, 1 insertion(+), 1 deletion(-)
~/Documents/workspace/git_springboot(master ✔) git st
On branch master
Your branch is ahead of &#39;origin/master&#39; by 2 commits.
  (use &quot;git push&quot; to publish your local commits)
nothing to commit, working tree clean
</code></pre>
<h4 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h4><p>使用git lg 命令来查看<br>也可以使用gitk命令来查看图形化的log记录</p>
<h4 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h4><p>Git通常是工作在三个区域上：</p>
<p>工作区<br>暂存区<br>历史区<br>其中工作区就是我们平时工作、修改代码的区域；而历史区，用来保存各个版本；而暂存区，则是Git的核心所在。<br><a href="https://git-scm.com/" target="_blank" rel="external">Git官网</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解Git</a></p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>回退版本是必不可少的操作啊</p>
<p>我们来考虑以下常见的几种情况：</p>
<ol>
<li>文件已经修改，但是还没有git add</li>
<li>文件已经add到暂存区，又作了修改</li>
<li>文件的修改已经add到了暂存区</li>
</ol>
<p>分别执行以下操作：</p>
<p>➜git checkout – README.md<br>修改被删除，完全还原到上次commit的状态，也就是服务器版本(1.)<br>最后的修改被删除，还原到上次add的状态，也就是修改前的暂存区状态(2.)<br>➜git reset HEAD README.md(3.)</p>
<pre><code class="zsh">~/Documents/workspace/git_springboot(master ✗) git st
On branch master
Your branch is ahead of &#39;origin/master&#39; by 2 commits.
  (use &quot;git push&quot; to publish your local commits)
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        modified:   README.md

~/Documents/workspace/git_springboot(master ✗) git reset HEAD README.md
Unstaged changes after reset:
M       README.md
~/Documents/workspace/git_springboot(master ✗) git st
On branch master
Your branch is ahead of &#39;origin/master&#39; by 2 commits.
  (use &quot;git push&quot; to publish your local commits)
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   README.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>通过git reset HEAD README.md，我们就把暂存区的文件清除了。这样，在本地就是add前的状态，通过checkout操作，就可以进行修改回退了。<br>在Git中，用HEAD表示当前版本，上一个版本就是<code>HEAD^</code>，<br>上上一个版本就是<code>HEAD^^</code>。（git reset –hard HEAD）<br>要回退到哪个版本，也可以写commit id。</p>
<h4 id="前进版本"><a href="#前进版本" class="headerlink" title="前进版本"></a>前进版本</h4><p>如果我们回退到了旧的版本，但是却后悔了想回到后面某个新的版本,git reflog 查看操作历史。找到 commit id。<br>版本号没必要写全，前7位就可以了，Git会自动去找。</p>
<h4 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h4><p>这里的暂存不是前面说的暂存区，而是只一次备份与恢复操作。<br>git stash<br>指令来将当前修改暂存，这样就可以切换到其他分支或者就在当前干净的分支上checkout了。<br>比如你checkout了一个issue分支，修改了bug，使用git merge合并到了master分支，删除issue分支，切换到dev分支，想继续之前的新功能开发。<br>这时候，就需要恢复现场了：</p>
<p>git stash list<br>指令来查看当前暂存的内容记录。<br>然后，通过git stash apply或者git stash pop来进行恢复，它们的区别是，前者不会删除记录（当然你可以使用git stash drop来删除），而后者会。</p>
<h4 id="远程仓库-amp-同步协作"><a href="#远程仓库-amp-同步协作" class="headerlink" title="远程仓库&amp;同步协作"></a>远程仓库&amp;同步协作</h4><ul>
<li><a href="http://blog.csdn.net/u012702547/article/details/78954832" target="_blank" rel="external">Git关联远程仓库</a></li>
</ul>
<h1 id="Git学习资料"><a href="#Git学习资料" class="headerlink" title="Git学习资料"></a>Git学习资料</h1><p>*<a href="http://blog.csdn.net/u012702547/article/details/78971096" target="_blank" rel="external">Git学习资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Git 闲话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。&lt;br&gt;2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。&lt;br&gt;“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“&lt;br&gt;只干了两件事啊，毫不夸张的说：惊天地泣鬼神。&lt;br&gt;第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。&lt;br&gt;再接下来，Git 就是我们的主题了，记录以备忘。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Git" scheme="//zeroto.tech/tags/Git/"/>
    
  </entry>
  
</feed>
