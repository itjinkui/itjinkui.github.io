<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://itjinkui.github.io/"/>
  <updated>2017-05-26T05:53:35.000Z</updated>
  <id>http://itjinkui.github.io/</id>
  
  <author>
    <name>千古不见一人闲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux</title>
    <link href="http://itjinkui.github.io/2017/05/25/systemd/"/>
    <id>http://itjinkui.github.io/2017/05/25/systemd/</id>
    <published>2017-05-25T09:59:57.000Z</published>
    <updated>2017-05-26T05:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Systemd-入门教程：命令篇"><a href="#Systemd-入门教程：命令篇" class="headerlink" title="Systemd 入门教程：命令篇"></a>Systemd 入门教程：命令篇</h1><p>Systemd 是 Linux 系统工具，用来启动<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="external">守护进程</a>，已成为大多数发行版的标准配置。</p>
<p>本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。</p>
<a id="more"></a>
<h2 id="一、由来"><a href="#一、由来" class="headerlink" title="一、由来"></a>一、由来</h2><p>历史上，<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="external">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="external"><code>init</code></a>进程。</p>
<p>下面的命令用来启动服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost /]<span class="comment"># service httpd start</span></div><div class="line">Redirecting to /bin/systemctl start  httpd.service</div></pre></td></tr></table></figure>
<p>ps:Centos7已经不支持了喔！</p>
<p>这种方法有两个缺点。</p>
<p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p>
<p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>
<h2 id="二、Systemd-概述"><a href="#二、Systemd-概述" class="headerlink" title="二、Systemd 概述"></a>二、Systemd 概述</h2><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p>
<p>根据 Linux 惯例，字母<code>d</code>是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030702.jpg" alt=""></p>
<p>（上图为 Systemd 作者 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering" target="_blank" rel="external">Lennart Poettering</a>）</p>
<p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl --version</div></pre></td></tr></table></figure>
<p>上面的命令查看 Systemd 的版本。</p>
<p>Systemd 的优点是功能强大，使用方便，缺点是系统庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反“keep simple, keep stupid”的<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="external">Unix 哲学</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt=""></p>
<p>（上图为 Systemd 架构图）</p>
<h2 id="三、系统管理"><a href="#三、系统管理" class="headerlink" title="三、系统管理"></a>三、系统管理</h2><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<h3 id="3-1-systemctl"><a href="#3-1-systemctl" class="headerlink" title="3.1 systemctl"></a>3.1 systemctl</h3><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重启系统</span></div><div class="line">$ sudo systemctl reboot</div><div class="line"></div><div class="line"><span class="comment"># 关闭系统，切断电源</span></div><div class="line">$ sudo systemctl poweroff</div><div class="line"></div><div class="line"><span class="comment"># CPU停止工作</span></div><div class="line">$ sudo systemctl halt</div><div class="line"></div><div class="line"><span class="comment"># 暂停系统</span></div><div class="line">$ sudo systemctl <span class="built_in">suspend</span></div><div class="line"></div><div class="line"><span class="comment"># 让系统进入冬眠状态</span></div><div class="line">$ sudo systemctl hibernate</div><div class="line"></div><div class="line"><span class="comment"># 让系统进入交互式休眠状态</span></div><div class="line">$ sudo systemctl hybrid-sleep</div><div class="line"></div><div class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></div><div class="line">$ sudo systemctl rescue</div></pre></td></tr></table></figure>
<h3 id="3-2-systemd-analyze"><a href="#3-2-systemd-analyze" class="headerlink" title="3.2 systemd-analyze"></a>3.2 systemd-analyze</h3><p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看启动耗时</span></div><div class="line">$ systemd-analyze                                                                                       </div><div class="line"></div><div class="line"><span class="comment"># 查看每个服务的启动耗时</span></div><div class="line">$ systemd-analyze blame</div><div class="line"></div><div class="line"><span class="comment"># 显示瀑布状的启动过程流</span></div><div class="line">$ systemd-analyze critical-chain</div><div class="line"></div><div class="line"><span class="comment"># 显示指定服务的启动流(eg:sshd.service)</span></div><div class="line">$ systemd-analyze critical-chain sshd.service</div></pre></td></tr></table></figure>
<h3 id="3-3-hostnamectl"><a href="#3-3-hostnamectl" class="headerlink" title="3.3 hostnamectl"></a>3.3 hostnamectl</h3><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示当前主机的信息</span></div><div class="line">$ hostnamectl</div><div class="line"></div><div class="line"><span class="comment"># 设置主机名。</span></div><div class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname CentOS-Docker</div></pre></td></tr></table></figure>
<h3 id="3-4-localectl"><a href="#3-4-localectl" class="headerlink" title="3.4 localectl"></a>3.4 localectl</h3><p><code>localectl</code>命令用于查看本地化设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看本地化设置</span></div><div class="line">$ localectl</div><div class="line"></div><div class="line"><span class="comment"># 设置本地化参数。</span></div><div class="line">$ sudo localectl <span class="built_in">set</span>-locale LANG=zh_CN.UTF-8</div><div class="line">$ sudo localectl <span class="built_in">set</span>-keymap cn</div></pre></td></tr></table></figure>
<h3 id="3-5-timedatectl"><a href="#3-5-timedatectl" class="headerlink" title="3.5 timedatectl"></a>3.5 timedatectl</h3><p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看当前时区设置</span></div><div class="line">$ timedatectl</div><div class="line"></div><div class="line"><span class="comment"># 显示所有可用的时区</span></div><div class="line">$ timedatectl list-timezones                                                                                   </div><div class="line"></div><div class="line"><span class="comment"># 设置当前时区</span></div><div class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone America/New_York</div><div class="line">$ sudo timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</div><div class="line">$ sudo timedatectl <span class="built_in">set</span>-time HH:MM:SS</div></pre></td></tr></table></figure>
<h3 id="3-6-loginctl"><a href="#3-6-loginctl" class="headerlink" title="3.6 loginctl"></a>3.6 loginctl</h3><p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出当前session</span></div><div class="line">$ loginctl list-sessions</div><div class="line"></div><div class="line"><span class="comment"># 列出当前登录用户</span></div><div class="line">$ loginctl list-users</div><div class="line"></div><div class="line"><span class="comment"># 列出显示指定用户的信息</span></div><div class="line">$ loginctl show-user root</div></pre></td></tr></table></figure>
<h2 id="四、Unit"><a href="#四、Unit" class="headerlink" title="四、Unit"></a>四、Unit</h2><h3 id="4-1-含义"><a href="#4-1-含义" class="headerlink" title="4.1 含义"></a>4.1 含义</h3><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<p>Unit 一共分成12种。</p>
<blockquote>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
</blockquote>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出正在运行的 Unit</span></div><div class="line">$ systemctl list-units</div><div class="line"></div><div class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></div><div class="line">$ systemctl list-units --all</div><div class="line"></div><div class="line"><span class="comment"># 列出所有没有运行的 Unit</span></div><div class="line">$ systemctl list-units --all --state=inactive</div><div class="line"></div><div class="line"><span class="comment"># 列出所有加载失败的 Unit</span></div><div class="line">$ systemctl list-units --failed</div><div class="line"></div><div class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></div><div class="line">$ systemctl list-units --type=service</div></pre></td></tr></table></figure>
<h3 id="4-2-Unit-的状态"><a href="#4-2-Unit-的状态" class="headerlink" title="4.2 Unit 的状态"></a>4.2 Unit 的状态</h3><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示系统状态</span></div><div class="line">$ systemctl status</div><div class="line"></div><div class="line"><span class="comment"># 显示单个 Unit 的状态</span></div><div class="line">$ sysystemctl status httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示远程主机的某个 Unit 的状态</span></div><div class="line">$ systemctl -H root@rhel7.example.com status httpd.service</div></pre></td></tr></table></figure>
<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示某个 Unit 是否正在运行</span></div><div class="line">$ systemctl is-active httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 是否处于启动失败状态</span></div><div class="line">$ systemctl is-failed httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 服务是否建立了启动链接</span></div><div class="line">$ systemctl is-enabled httpd.service</div></pre></td></tr></table></figure>
<h3 id="4-3-Unit-管理"><a href="#4-3-Unit-管理" class="headerlink" title="4.3 Unit 管理"></a>4.3 Unit 管理</h3><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 立即启动一个服务</span></div><div class="line">$ sudo systemctl start httpd.service</div><div class="line"><span class="comment"># 立即停止一个服务</span></div><div class="line">$ sudo systemctl stop httpd.service</div><div class="line"><span class="comment"># 重启一个服务</span></div><div class="line">$ sudo systemctl restart httpd.service</div><div class="line"><span class="comment"># 杀死一个服务的所有子进程</span></div><div class="line">$ sudo systemctl <span class="built_in">kill</span> httpd.service</div><div class="line"><span class="comment"># 重新加载一个服务的配置文件</span></div><div class="line">$ sudo systemctl reload httpd.service</div><div class="line"><span class="comment"># 重载所有修改过的配置文件</span></div><div class="line">$ sudo systemctl daemon-reload</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 的所有底层参数</span></div><div class="line">$ systemctl show httpd.service</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 Unit 的指定属性的值</span></div><div class="line">$ systemctl show -p CPUShares httpd.service</div></pre></td></tr></table></figure>
<h3 id="4-4-依赖关系"><a href="#4-4-依赖关系" class="headerlink" title="4.4 依赖关系"></a>4.4 依赖关系</h3><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl list-dependencies nginx.service</div></pre></td></tr></table></figure>
<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl list-dependencies --all nginx.service</div></pre></td></tr></table></figure>
<h2 id="五、Unit-的配置文件"><a href="#五、Unit-的配置文件" class="headerlink" title="五、Unit 的配置文件"></a>五、Unit 的配置文件</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在这个目录。</p>
<p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl <span class="built_in">enable</span> sshd.service</div><div class="line"><span class="comment"># 等同于</span></div><div class="line">$ sudo ln <span class="_">-s</span> <span class="string">'/usr/lib/systemd/system/sshd.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/sshd.service'</span></div></pre></td></tr></table></figure>
<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl <span class="built_in">disable</span> sshd.service</div></pre></td></tr></table></figure>
<p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p>
<h3 id="5-2-配置文件的状态"><a href="#5-2-配置文件的状态" class="headerlink" title="5.2 配置文件的状态"></a>5.2 配置文件的状态</h3><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出所有配置文件</span></div><div class="line">$ systemctl list-unit-files</div><div class="line"></div><div class="line"><span class="comment"># 列出指定类型的配置文件</span></div><div class="line">$ systemctl list-unit-files --type=service</div></pre></td></tr></table></figure>
<p>这个命令会输出一个列表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ systemctl list-unit-files</div><div class="line"></div><div class="line">UNIT FILE              STATE</div><div class="line">chronyd.service        enabled</div><div class="line">clamd@.service         static</div><div class="line">sshd.service     disabled</div></pre></td></tr></table></figure>
<p>这个列表显示每个配置文件的状态，一共有四种。</p>
<blockquote>
<ul>
<li>enabled：已建立启动链接</li>
<li>disabled：没建立启动链接</li>
<li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
</blockquote>
<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl status httpd.service</div></pre></td></tr></table></figure>
<p>一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl daemon-reload</div><div class="line">$ sudo systemctl restart httpd.service</div></pre></td></tr></table></figure>
<h3 id="5-3-配置文件的格式"><a href="#5-3-配置文件的格式" class="headerlink" title="5.3 配置文件的格式"></a>5.3 配置文件的格式</h3><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ systemctl cat atd.service</div><div class="line"></div><div class="line">[Unit]</div><div class="line">Description=ATD daemon</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">ExecStart=/usr/bin/atd</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure>
<p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[Section]</div><div class="line">Directive1=value</div><div class="line">Directive2=value</div><div class="line"></div><div class="line">. . .</div></pre></td></tr></table></figure>
<p>注意，键值对的等号两侧不能有空格。</p>
<h3 id="5-4-配置文件的区块"><a href="#5-4-配置文件的区块" class="headerlink" title="5.4 配置文件的区块"></a>5.4 配置文件的区块</h3><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Description</code>：简短描述</li>
<li><code>Documentation</code>：文档地址</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li>
<li><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li>
<li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</li>
<li><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
</blockquote>
<p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
</blockquote>
<p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Type</code>：定义启动时的进程行为。它有以下几种值。<ul>
<li><code>simple</code>：默认值，执行<code>ExecStart</code>指定的命令，启动主进程</li>
<li><code>forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>
<li><code>oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>
<li><code>dbus</code>：当前服务通过D-Bus启动</li>
<li><code>notify</code>：当前服务启动完毕，会通知<code>Systemd</code>，再继续往下执行</li>
<li><code>idle</code>：若有其他任务执行完毕，当前服务才会运行</li>
</ul>
</li>
<li><code>ExecStart</code>：启动当前服务的命令</li>
<li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li>
<li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li>
<li><code>ExecReload</code>：重启当前服务时执行的命令</li>
<li><code>ExecStop</code>：停止当前服务时执行的命令</li>
<li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li>
<li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括<code>always</code>（总是重启）、<code>on-success</code>、<code>on-failure</code>、<code>on-abnormal</code>、<code>on-abort</code>、<code>on-watchdog</code></li>
<li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li>
<li><code>Environment</code>：指定环境变量</li>
</ul>
</blockquote>
<p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="六、Target"><a href="#六、Target" class="headerlink" title="六、Target"></a>六、Target</h2><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于“状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看当前系统的所有 Target</span></div><div class="line">$ systemctl list-unit-files --type=target</div><div class="line"></div><div class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></div><div class="line">$ systemctl list-dependencies multi-user.target</div><div class="line"></div><div class="line"><span class="comment"># 查看启动时的默认 Target</span></div><div class="line">$ systemctl get-default</div><div class="line"></div><div class="line"><span class="comment"># 设置启动时的默认 Target</span></div><div class="line">$ sudo systemctl <span class="built_in">set</span>-default multi-user.target</div><div class="line"></div><div class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></div><div class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></div><div class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></div><div class="line">$ sudo systemctl isolate multi-user.target</div></pre></td></tr></table></figure>
<p>Target 与 传统 RunLevel 的对应关系如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Traditional runlevel      New target name     Symbolically linked to...</div><div class="line"></div><div class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</div><div class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</div><div class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</div><div class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</div><div class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</div><div class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</div><div class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</div></pre></td></tr></table></figure>
<p>它与<code>init</code>进程的主要差别如下。</p>
<blockquote>
<p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p>
<p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
</blockquote>
<h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a>七、日志管理</h2><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<p><code>journalctl</code>功能强大，用法非常多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></div><div class="line">$ sudo journalctl</div><div class="line"></div><div class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></div><div class="line">$ sudo journalctl -k</div><div class="line"></div><div class="line"><span class="comment"># 查看系统本次启动的日志</span></div><div class="line">$ sudo journalctl -b</div><div class="line">$ sudo journalctl -b -0</div><div class="line"></div><div class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></div><div class="line">$ sudo journalctl -b -1</div><div class="line"></div><div class="line"><span class="comment"># 查看指定时间的日志</span></div><div class="line">$ sudo journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></div><div class="line">$ sudo journalctl --since <span class="string">"20 min ago"</span></div><div class="line">$ sudo journalctl --since yesterday</div><div class="line">$ sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></div><div class="line"></div><div class="line"><span class="comment"># 显示尾部的最新10行日志</span></div><div class="line">$ sudo journalctl -n</div><div class="line"></div><div class="line"><span class="comment"># 显示尾部指定行数的日志</span></div><div class="line">$ sudo journalctl -n 20</div><div class="line"></div><div class="line"><span class="comment"># 实时滚动显示最新日志</span></div><div class="line">$ sudo journalctl <span class="_">-f</span></div><div class="line"></div><div class="line"><span class="comment"># 查看指定服务的日志</span></div><div class="line">$ sudo journalctl /usr/lib/systemd/systemd</div><div class="line"></div><div class="line"><span class="comment"># 查看指定进程的日志</span></div><div class="line">$ sudo journalctl _PID=1</div><div class="line"></div><div class="line"><span class="comment"># 查看某个路径的脚本的日志</span></div><div class="line">$ sudo journalctl /usr/bin/bash</div><div class="line"></div><div class="line"><span class="comment"># 查看指定用户的日志</span></div><div class="line">$ sudo journalctl _UID=33 --since today</div><div class="line"></div><div class="line"><span class="comment"># 查看某个 Unit 的日志</span></div><div class="line">$ sudo journalctl -u nginx.service</div><div class="line">$ sudo journalctl -u nginx.service --since today</div><div class="line"></div><div class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></div><div class="line">$ sudo journalctl -u nginx.service <span class="_">-f</span></div><div class="line"></div><div class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></div><div class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</div><div class="line"></div><div class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></div><div class="line"><span class="comment"># 0: emerg</span></div><div class="line"><span class="comment"># 1: alert</span></div><div class="line"><span class="comment"># 2: crit</span></div><div class="line"><span class="comment"># 3: err</span></div><div class="line"><span class="comment"># 4: warning</span></div><div class="line"><span class="comment"># 5: notice</span></div><div class="line"><span class="comment"># 6: info</span></div><div class="line"><span class="comment"># 7: debug</span></div><div class="line">$ sudo journalctl -p err -b</div><div class="line"></div><div class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></div><div class="line">$ sudo journalctl --no-pager</div><div class="line"></div><div class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></div><div class="line">$ sudo journalctl -b -u nginx.service -o json</div><div class="line"></div><div class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></div><div class="line">$ sudo journalctl -b -u nginx.serviceqq</div><div class="line"> -o json-pretty</div><div class="line"></div><div class="line"><span class="comment"># 显示日志占据的硬盘空间</span></div><div class="line">$ sudo journalctl --disk-usage</div><div class="line"></div><div class="line"><span class="comment"># 指定日志文件占据的最大空间</span></div><div class="line">$ sudo journalctl --vacuum-size=1G</div><div class="line"></div><div class="line"><span class="comment"># 指定日志文件保存多久</span></div><div class="line">$ sudo journalctl --vacuum-time=1years</div></pre></td></tr></table></figure>
<p>（完）<br>转载于<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a><br>如何编写 Unit 的配置文件</p>
<ul>
<li><a href="https://fedoramagazine.org/what-is-an-init-system/" target="_blank" rel="external">What is an init system?</a></li>
<li><a href="http://fedoramagazine.org/systemd-converting-sysvinit-scripts/" target="_blank" rel="external">systemd: Converting sysvinit scripts</a></li>
<li><a href="https://fedoramagazine.org/systemd-unit-dependencies-and-order/" target="_blank" rel="external">systemd: Unit dependencies and order</a></li>
<li><a href="https://fedoraproject.org/wiki/Systemd" target="_blank" rel="external">Systemd</a></li>
<li><a href="http://fedoraproject.org/wiki/Packaging%3aSystemd" target="_blank" rel="external">Packaging:Systemd</a></li>
<li><a href="http://patrakov.blogspot.jp/2011/01/writing-systemd-service-files.html" target="_blank" rel="external">Writing systemd service files</a></li>
<li><a href="http://unix.stackexchange.com/questions/47695/how-to-write-startup-script-for-systemd" target="_blank" rel="external">How to write startup script for systemd</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Systemd-入门教程：命令篇&quot;&gt;&lt;a href=&quot;#Systemd-入门教程：命令篇&quot; class=&quot;headerlink&quot; title=&quot;Systemd 入门教程：命令篇&quot;&gt;&lt;/a&gt;Systemd 入门教程：命令篇&lt;/h1&gt;&lt;p&gt;Systemd 是 Linux 系统工具，用来启动&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html&quot;&gt;守护进程&lt;/a&gt;，已成为大多数发行版的标准配置。&lt;/p&gt;
&lt;p&gt;本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://itjinkui.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://itjinkui.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://itjinkui.github.io/2017/05/11/git-how/"/>
    <id>http://itjinkui.github.io/2017/05/11/git-how/</id>
    <published>2017-05-11T09:57:29.000Z</published>
    <updated>2017-05-15T08:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Git 闲话</p>
<blockquote>
<p>1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。<br>2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。<br>“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“<br>只干了两件事啊，毫不夸张的说：惊天地泣鬼神。<br>第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。<br>再接下来，Git 就是我们的主题了，记录以备忘。</p>
</blockquote>
<a id="more"></a>
<h2 id="Git安装与配置"><a href="#Git安装与配置" class="headerlink" title="Git安装与配置"></a>Git安装与配置</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Mac 上brew安装算是最便捷的了</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~ brew install git </div><div class="line">~ brew --version</div><div class="line">Homebrew 1.1.13</div><div class="line">Homebrew/homebrew-core (git revision ea163; last commit 2017-04-20)</div><div class="line">~ git --version</div><div class="line">git version 2.11.0</div></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>可以通过 git config –list –global 命令来查看：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~ git config --list --global</div><div class="line">user.email=1250114609@qq.com</div><div class="line">user.name=千古不见一人闲</div><div class="line">color.ui=auto</div><div class="line">alias.st=status</div><div class="line">alias.lg=<span class="built_in">log</span> --color --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</div></pre></td></tr></table></figure>
<p>可以看到有两个alias出现，这里使用了别名。</p>
<p>配置别名</p>
<p>这个功能在shell中是很常用的。我们可以做一些别名来取代比较复杂的指令。<br>比如上面就是使用了以下两个配置</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~ git config --global alias.st status</div><div class="line"></div><div class="line">~ git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></div></pre></td></tr></table></figure>
<h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>当本地git仓库与git远程仓库通信的时候，需要进行SSH身份认证。<br>打开根目录下的.ssh目录：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~/.ssh la</div><div class="line">.              ..             config         github_rsa     github_rsa.pub id_rsa         id_rsa.pub     known_hosts</div></pre></td></tr></table></figure>
<p>如果没有id_rsa和id_rsa.pub这两个文件，就通过如下的命令生成：</p>
<p>ssh-keygen -t rsa -C “youremail@example.com”<br>id_rsa和id_rsa.pub这两个文件，就是SSH Key的秘钥对，id_rsa是私钥，id_rsa.pub是公钥，用在github上表明身份。<br>在GitHub上的SSH keys中添加刚刚生成的key。(id_rsa.pub)</p>
<h4 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h4><p>创建一个目录，并cd到目录下，通过调用git init来将现有目录初始化为git仓库，或者直接在git init后面跟上目录名，同样也可以创建一个新的仓库。</p>
<p>git clone 直接clone一个远程仓库也是可以的。</p>
<h4 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace git_springboot</div><div class="line">~/Documents/workspace/git_springboot(master ✔) la</div><div class="line">.    ..   .git</div><div class="line">~/Documents/workspace/git_springboot(master ✔) touch README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) vim README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git add README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git commit -m <span class="string">"add README.md"</span></div><div class="line">[master be9081a] add README.md</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line"> create mode 100644 README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✔)</div></pre></td></tr></table></figure>
<h4 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h4><p>修改README.md文件，git st查看修改</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>Git 比较不同版本文件差异的常用命令格式：</p>
<blockquote>
<p>git diff  查看尚未暂存的文件更新了哪些部分      </p>
<p>git diff filename 查看尚未暂存的某个文件更新了哪些</p>
<p>git diff –cached 查看已经暂存起来的文件和上次提交的版本之间的差异</p>
<p>git diff –cached filename 查看已经暂存起来的某个文件和上次提交的版本之间的差异</p>
</blockquote>
<p>使用git diff README.md 命令看一下修改的具体内容</p>
<blockquote>
<p>diff –git a/README.md b/README.md<br>index e8281cd..f1729fb 100644<br>— a/README.md<br>+++ b/README.md<br>@@ -1 +1 @@<br>-this’s ok.<br>+this’s ok,modify.</p>
</blockquote>
<p>add和commit之后，我们都使用status来查看下状态，可以发现，在commit之后，git提示我们，工作区是干净的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git add README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git commit -m <span class="string">"modify README.md"</span></div><div class="line">[master a77107b] modify README.md</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div><div class="line">~/Documents/workspace/git_springboot(master ✔) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure>
<h4 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h4><p>使用git lg 命令来查看<br>也可以使用gitk命令来查看图形化的log记录</p>
<h4 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h4><p>Git通常是工作在三个区域上：</p>
<p>工作区<br>暂存区<br>历史区<br>其中工作区就是我们平时工作、修改代码的区域；而历史区，用来保存各个版本；而暂存区，则是Git的核心所在。<br><a href="https://git-scm.com/" target="_blank" rel="external">Git官网</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解Git</a></p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>回退版本是必不可少的操作啊</p>
<p>我们来考虑以下常见的几种情况：</p>
<ol>
<li>文件已经修改，但是还没有git add</li>
<li>文件已经add到暂存区，又作了修改</li>
<li>文件的修改已经add到了暂存区</li>
</ol>
<p>分别执行以下操作：</p>
<p>➜git checkout – README.md<br>修改被删除，完全还原到上次commit的状态，也就是服务器版本(1.)<br>最后的修改被删除，还原到上次add的状态，也就是修改前的暂存区状态(2.)<br>➜git reset HEAD README.md(3.)</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">~/Documents/workspace/git_springboot(master ✗) git reset HEAD README.md</div><div class="line">Unstaged changes after reset:</div><div class="line">M       README.md</div><div class="line">~/Documents/workspace/git_springboot(master ✗) git st</div><div class="line">On branch master</div><div class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</div><div class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>通过git reset HEAD README.md，我们就把暂存区的文件清除了。这样，在本地就是add前的状态，通过checkout操作，就可以进行修改回退了。<br>在Git中，用HEAD表示当前版本，上一个版本就是<code>HEAD^</code>，<br>上上一个版本就是<code>HEAD^^</code>。（git reset –hard HEAD）<br>要回退到哪个版本，也可以写commit id。</p>
<h4 id="前进版本"><a href="#前进版本" class="headerlink" title="前进版本"></a>前进版本</h4><p>如果我们回退到了旧的版本，但是却后悔了想回到后面某个新的版本,git reflog 查看操作历史。找到 commit id。<br>版本号没必要写全，前7位就可以了，Git会自动去找。</p>
<h4 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h4><p>这里的暂存不是前面说的暂存区，而是只一次备份与恢复操作。<br>git stash<br>指令来将当前修改暂存，这样就可以切换到其他分支或者就在当前干净的分支上checkout了。<br>比如你checkout了一个issue分支，修改了bug，使用git merge合并到了master分支，删除issue分支，切换到dev分支，想继续之前的新功能开发。<br>这时候，就需要恢复现场了：</p>
<p>git stash list<br>指令来查看当前暂存的内容记录。<br>然后，通过git stash apply或者git stash pop来进行恢复，它们的区别是，前者不会删除记录（当然你可以使用git stash drop来删除），而后者会。</p>
<h4 id="远程仓库-amp-同步协作"><a href="#远程仓库-amp-同步协作" class="headerlink" title="远程仓库&amp;同步协作"></a>远程仓库&amp;同步协作</h4><p>现在你在本地建立了git仓库，想与远程git仓库同步。</p>
<p>我们先在github上创建一个repo（仓库），<br>创建之后，github给我们提示：<br><img src="git.png" alt="git_createrepository"><br>可以看出，执行以下指令就和远程仓库建立关联了，自然也就可以多人同步协作开发了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:itjinkui/git_springboot.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>git 入门操作算是完成了。企业可以通过GitLab搭建自己的版本管理系统。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Git 闲话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、最近阅读《数学之美》、《浪潮之巅》惊叹于大神的眼界、文化功底，所以就在得到专栏上订阅了吴军博士的硅谷来信。总之，就是膜拜了。想了解一个人，就先了解一个的思想对不对，所谓见贤与之思齐就是这样了。&lt;br&gt;2、接下来说一说我心目中的另一位大神 林纳斯•托瓦兹，编程界公认的啊。&lt;br&gt;“我不是个有远见的人，我是一名工程师，”托瓦兹说，“我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹……但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去。“&lt;br&gt;只干了两件事啊，毫不夸张的说：惊天地泣鬼神。&lt;br&gt;第一件是开发出Linux内核，驱动了因特网，第二件是开发出Git，一种源代码管理系统，被全世界开发者广泛使用。&lt;br&gt;再接下来，Git 就是我们的主题了，记录以备忘。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="git" scheme="http://itjinkui.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://itjinkui.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://itjinkui.github.io/2017/03/28/hello-world/"/>
    <id>http://itjinkui.github.io/2017/03/28/hello-world/</id>
    <published>2017-03-28T10:29:41.000Z</published>
    <updated>2017-05-11T08:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
